[{"title":"Hexo-阅读页面(微信阅读)","url":"/posts/WeRead.html","content":"\n## 效果预览\n\n![image-20231114195045170](WeRead/image-20231114195045170.png)\n\n## 生成Token\n\n进入网站 [登录微信读书 (weread.islu.cn)](https://weread.islu.cn/login.html) 扫码登录\n\nF12打开控制台复制Token\n\n![image-20231114200140462](WeRead/image-20231114200140462.png)\n\n## 静态生成网页\n\n在适当位置创建`read.js` 文件   我以根目录举例\n\n![image-20231114200424550](WeRead/image-20231114200424550.png)\n\n粘贴一下代码内容 `记得看注释   根据自己的目录文件修改`\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nvar myHeaders = new Headers();\nmyHeaders.append(\"token\", \"01HF5Z180R39PQ8RXXXXXXXXXX\"); // 此处为你的Token\nmyHeaders.append(\"User-Agent\", \"WeRead/7.4.2 (iPhone; iOS 17.1; Scale/3.00)\");\n\nvar requestOptions = {\n    method: 'GET',\n    headers: myHeaders,\n    redirect: 'follow'\n};\n\nconst outputDir = path.join(process.cwd(), 'source', '_data'); // 文件输出目录\nif (!fs.existsSync(outputDir)) {\n    fs.mkdirSync(outputDir, {recursive: true});\n}\n\nconst outputPath = path.join(outputDir, 'read.json'); // 生成文件命名\n\nfetch(\"https://weread.islu.cn/api/shelf/book/list\", requestOptions)\n    .then(response => response.json())\n    .then(jsonResult => {\n        console.log('Wechat Reading File writteing');\n        fs.writeFile(outputPath, JSON.stringify(jsonResult), (err) => {\n            if (err) {\n                console.error('Error writing Wechat Reading file:', err);\n            } else {\n                console.log('Wechat Reading File written successfully');\n            }\n        })\n    })\n    .catch(error => console.log('Wechat Reading error', error));\n\n```\n\n运行 `node read.js` 获取数据生成的 JSON 文件\n\n在页面中加入以下代码\n\n```html\n    <div class=\"bookshelf_preview_container\">\n        <div id=\"books\" class=\"bookshelf_preview_body\">\n            <% var books = site.data.read.data.books; %>\n            <% for (var i = 0, len = books.length; i < len; i++) { %>\n                <% var book = books[i]; %>\n                <div class=\"bookshelf_preview_item\" title=\"<%= book.title %>\">\n                    <div class=\"bookshelf_preview_item_container\">\n                        <div class=\"wr_bookCover bookshelf_preview_cover\">\n                            <img class=\"wr_bookCover_img\" alt=\"书籍封面\" src=\"<%= book.cover %>\">\n                            <div class=\"wr_bookCover_border\"></div>\n                            <span class=\"wr_bookCover_decor wr_bookCover_gradientDecor wr_bookCover_borderDecor\"></span>\n                        </div>\n                        <div class=\"bookshelf_preview_content\">\n                            <p class=\"bookshelf_preview_title\"><%= book.title %></p>\n                            <span class=\"bookshelf_preview_author\"><%= book.author %></span>\n                        </div>\n                    </div>\n                    <% var bookProgress = site.data.read.data.bookProgress; %>\n                    <% for (var j = 0, len = bookProgress.length; j < len; j++) { %>\n                        <% if (bookProgress[j].bookId == book.bookId) { %>\n                        <div class=\"bookshelf_preview_progressBar\" title=\"<%= bookProgress[j].progress %>%\">\n                            <span style=\"width: <%= bookProgress[j].progress %>%\"></span>\n                        </div>\n                        <% } %>\n                    <% } %>\n                </div>\n            <% } %>\n        </div>\n    </div>\n\n```\n\n> 注：代码仅供参考   请结合自己的代码修改\n\n## 自动部署\n\n改天分享一下我的 Github Action 的yml文件希望能够对大家的自动化有所优化","tags":["Hexo","微信阅读"],"categories":["经验分享"]},{"title":"备份？看似无用却很重要","url":"/posts/EggsInTheSameBasket.html","content":"\n## 起因\n\n语雀不久前刚刚崩过了一次，但是这次阿里云的很多服务都崩了，各位有没有被惊吓到\n\n## 数据的备份\n\n我采用的均为云端加本地的方式\n\n博客——本地+Github+语雀\n\n手机——本机+阿里云盘+百度云盘\n\n平板——本机+小米云\n\niphone——本机+icloud\n\n## 关于博客的备份分享\n\n有时会使用语雀记录一下，有时会在本地写一些东西，但是如何同步呢\n\n![image-20231114210939639](EggsInTheSameBasket/image-20231114210939639.png)\n\n使用Github Action获取语雀的文章并将文章转为markdown文件、图片本地化  都存储到GitHub仓库中\n\nGitHub Action将生成的静态文件到Github Pages和Vercel中  再使用又拍云的CDN加速\n\n每次的Github Action运行都是对Github仓库的一次生成，后续会加入对Gitee的同步 如下图\n\n![image-20231114211235104](EggsInTheSameBasket/image-20231114211235104.png)\n\n多一个平台备份  多一份保障","tags":["文章备份"],"categories":["值得一看"]},{"title":"星火大模型API","url":"/posts/XingHuoApi.html","content":"\n在当今的数字化时代，人工智能（AI）已经成为了我们生活中不可或缺的一部分。科大讯飞作为中国领先的人工智能公司，提供了一系列的AI服务，其中包括讯飞星火。\n\n##  讯飞星火简介\n\n讯飞星火是科大讯飞提供的一项语音识别服务，可以将用户的语音转换为文字。这项服务可以广泛应用于各种场景，如智能家居、语音助手、在线教育等。[讯飞星火认知大模型-AI大语言模型-星火大模型-科大讯飞 (xfyun.cn)](https://xinghuo.xfyun.cn/)\n\n##  Vercel简介\n\nVercel是一个基于Git的前端部署平台，可以帮助开发者快速、简单地部署和发布他们的应用。Vercel支持多种前端框架，如React、Vue、Angular等，并且提供了一键部署的功能。[Vercel](https://vercel.com)\n\n> 虽然被墙，但是绑定自定义域名依然可以访问使用\n\n## 结合使用星火大模型和Vercel的API\n\n###  注册并获取API密钥\n\n首先，你需要在科大讯飞的官网上注册一个账号，并创建一个应用。在创建应用的过程中，你将获得一个API密钥，这个密钥将在后续的操作中用到。\n\n![认证信息展示](XingHuoApi/image-20231019213740103.png)\n\n###  导入Vercel项目\n\n进入本项目，Fork[本项目](https://islu.cn/posts/XingHuoApi.html)\n\n![Fork](XingHuoApi/image-20231019224332247.png)\n\n在Vercel中导入该仓库\n\n![导入仓库](XingHuoApi/image-20231019224430772.png)\n\n\n\n### 编辑环境变量\n\n进入Seting中找到环境配置\n\n![环境变量编辑](XingHuoApi/image-20231019220226622.png)\n\n添加以下环境\n\n| 环境变量名 | 参数值              |\n| ---------- | ------------------- |\n| APPID      | APPID               |\n| API_SECRET | APISecret           |\n| API_KEY    | APIKey              |\n| DOMAIN     | general / generalv2 |\n\n> 默认 DOMAIN为星火大模型V1.5版本，如需使用星火大模型V2.0版本记得编辑Vercel环境变量`DOMAIN`为`generalv2`\n\n### 完成项目部署\n\n编辑完环境变量后重新部署项目\n\n![重新部署](XingHuoApi/image-20231019224641927.png)\n\n自定义访问域名（由于不可抗因素，需绑定自定义域名才可访问）\n\n![绑定域名](XingHuoApi/image-20231019224719043.png)\n\n访问自定义域名输入访问参数进行访问\n\n>https://example.com/chat/{content}\n\n![示例](XingHuoApi/image-20231020101151180.png)","tags":["星火大模型","Vercel"],"categories":["值得一看"]},{"title":"Typora增强插件","url":"/posts/CreateTyporaScript.html","content":"\n## 插件介绍\n\n先贴上插件[Github地址](https://github.com/obgnail/typora_plugin)\n\n目前支持的功能：\n\n| 序号 | 文件名                     | 功能                                 |\n| ---- | -------------------------- | ------------------------------------ |\n| 1    | window_tab                 | 标签页管理                           |\n| 2    | search_multi               | 全局多关键字搜索                     |\n| 3    | multi_highlighter          | 多关键字高亮                         |\n| 4    | collapse_paragraph         | 章节折叠                             |\n| 5    | md_padding                 | 中英文混排优化                       |\n| 6    | templater                  | 文件模板                             |\n| 7    | resource_operation         | 一键清除无用图片，生成报告           |\n| 8    | fence_enhance              | 一键复制代码，折叠代码               |\n| 9    | commander                  | 命令行环境                           |\n| 10   | mindmap                    | 根据文档大纲一键生成思维导图         |\n| 11   | toolbar                    | 多功能搜索栏                         |\n| 12   | right_click_menu           | 右键菜单统一管理、调用插件           |\n| 13   | markmap                    | 提供 markmap 组件支持                |\n| 14   | echarts                    | 提供 echarts 组件支持                |\n| 15   | chart                      | 提供 chartjs 组件支持                |\n| 16   | calendar                   | 提供 tui.calendar 组件支持           |\n| 17   | callouts                   | 提供 callouts 支持                   |\n| 18   | read_only                  | 只读模式                             |\n| 19   | blur                       | 模糊模式                             |\n| 20   | kanban                     | 看板                                 |\n| 21   | timeline                   | 时间线                               |\n| 22   | file_counter               | 显示目录下的文件数                   |\n| 23   | outline                    | 以表格、图片、代码块形式的大纲       |\n| 24   | auto_number                | 章节、表格、图片、代码块等自动编号   |\n| 25   | chinese_symbol_auto_pairer | 中文符号自动补全                     |\n| 26   | datatables                 | 表格增强（搜索、过滤、分页、排序等） |\n| 27   | resize_table               | 调整表格行高列宽                     |\n| 28   | resize_image               | 调整图片显示大小                     |\n| 29   | export_enhance             | 导出 html 时避免图片丢失             |\n| 30   | go_top                     | 一键到文章顶部、底部                 |\n| 31   | truncate_text              | 暂时隐藏内容，提高大文件渲染性能     |\n| 32   | markdown_lint              | markdown 格式规范检测                |\n| 33   | plugin_updater             | 一键升级插件                         |\n| 34   | extract_range_to_new_file  | 提取选区文字到新文件                 |\n| 35   | full_path_copy             | 复制标题路径                         |\n| 36   | auto_trailing_white_space  | 自动添加结尾空格                     |\n| 37   | open_in_total_commander    | 在 total commander 打开              |\n| 38   | mermaid_replace            | 替换 mermaid 组件                    |\n| 38   | custom                     | 用户自定义命令（高级）               |\n| 40   | hotkey_hub                 | 快捷键注册中心（高级）               |\n| 41   | old_window_tab             | 标签页管理（已废弃）                 |\n\n## 下载链接\n\n[原作者下载链接](https://github.com/obgnail/typora_plugin/archive/refs/tags/1.5.9.zip)\n\n[阿里云分享链接]()\n\n## 使用方法\n\n1. 进入 Typora 安装路径，找到包含 `window.html` 的文件夹 A（一般是 `Typora/resources/window.html` 或者 `Typora/resources/app/window.html`，推荐使用 everything 找一下）\n2. 打开文件夹 A，将源码的 plugin 文件夹粘贴进该文件夹下。\n3. 打开文件 `A/window.html`。搜索文件内容 `<script src=\"./app/window/frame.js\" defer=\"defer\"></script>` 或者 `<script src=\"./appsrc/window/frame.js\" defer=\"defer\"></script>`，并在 **后面** 加入 `<script src=\"./plugin/index.js\" defer=\"defer\"></script>`。保存。\n4. 验证：重启 Typora，在正文区域点击鼠标右键，弹出右键菜单栏，如果能看到 `常用插件` 栏目，说明一切顺利\n\n![image-20231014130634028](CreateTyporaScript/image-20231014130634028.png)\n\n![image-20231014130838102](CreateTyporaScript/image-20231014130838102.png)\n\n重启Typora 出现下面的标签栏即为安装成功\n\n![image-20231014130954275](CreateTyporaScript/image-20231014130954275.png)\n\n","tags":["Typora"],"categories":["资源推荐"]},{"title":"Hyper-V配置固定IP","url":"/posts/Hyper-VConfigStaticIP.html","content":"## 方式一\n\n开启有线连接\n\n![image-20231014122046230](Hyper-VConfigStaticIP/image-20231014122046230.png)\n\n点击有线设置\n\n![image-20231014122213971](Hyper-VConfigStaticIP/image-20231014122213971.png)\n\n\n\n![image-20231014122340545](Hyper-VConfigStaticIP/image-20231014122340545.png)\n\n![image-20231014122727396](Hyper-VConfigStaticIP/image-20231014122727396.png)\n\n> 应用后记得重启哦 ~\n\n## 方式二\n\n![image-20231014161644707](Hyper-VConfigStaticIP/image-20231014161644707.png)\n\n![image-20231014161723559](Hyper-VConfigStaticIP/image-20231014161723559.png)\n\n![image-20231014161747995](Hyper-VConfigStaticIP/image-20231014161747995.png)\n\n\n\n![image-20231014161821040](Hyper-VConfigStaticIP/image-20231014161821040.png)\n\n![image-20231014161839048](Hyper-VConfigStaticIP/image-20231014161839048.png)\n\n> 重启虚拟机","tags":["Hyper-V配置IP","Linux"],"categories":["经验分享"]},{"title":"Virtual Machine Boot Summary解决","url":"/posts/Hyper-VRestart.html","content":"\n## 报错截图\n\n![image-20231014100016475](Hyper-VRestart/image-20231014100016475.png)\n\n## 解决方案\n\n1. 首先关闭虚拟机\n\n2. 打开设置-->点击安全-->取消勾选(如下图)\n\n   ![image-20231014100454865](Hyper-VRestart/image-20231014100454865.png)","tags":["Hyper-V"],"categories":["学习笔记"]},{"title":"MySQL","url":"/posts/MySQL.html","content":"\n## 通过命令操作数据库【重点】\n\n### 连接数据库\n\n标准格式\n\n```sql\nC:\\Users\\FC>mysql -h localhost -u root -P 3306 -p\nEnter password: ****\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 10\nServer version: 5.7.31-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```\n\n简化步骤\n\n```sql\nC:\\Users\\FC>mysql -uroot -p\nEnter password: ****\nWelcome to the MySQL monitor.  Commands end with ; or \\g.\nYour MySQL connection id is 9\nServer version: 5.7.31-log MySQL Community Server (GPL)\n\nCopyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.\n\nOracle is a registered trademark of Oracle Corporation and/or its\naffiliates. Other names may be trademarks of their respective\nowners.\n\nType 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.\n\nmysql>\n```\n\n### 查看数据库\n\n```sql\nshow databases;\n```\n\n> 注意分号不要忘\n\n### 内置数据库\n\n<font color='#FF0000'>不要动！！！</font>\n\n|       数据库名称        |                                  描述                                  |\n|:------------------:|:--------------------------------------------------------------------:|\n| information_schema | 信息数据库，其中保存着关于所有数据库的信息（元数据）。<br />元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。 |\n|       mysql        |       核心数据库，主要负责存储数据库的用户、权限设置、关键字等，<br />以及需要使用的控制和管理信息，不可以删除。       |\n| performance_schema |                  性能优化的数据库，MySQL 5.5版本中新增的一个性能优化的引擎。                  |\n|        sys         |   系统数据库，MySQL5.7版本中新增的可以快速的了解元数据信息的系统库<br/>便于发现数据库的多样信息，解决性能瓶颈问题。    |\n\n### 创建数据库\n\n```sql\n# 创建数据库\ncreate database 数据库名;\n\n# 指定字符集创建数据库\ncreate database 数据库名 character set = 编码集;\n# 例如：create database student character set = gbk;\n\n# 指定字符集创建数据库\ncreate database 数据库名 charset 编码集;\n# 例如：create database student charset utf8;\n```\n\n### 删除数据库\n\n```sql\n# 删除数据库\ndrop database 数据库名;\n# 例：drop database student;\n```\n\n### 使用/选择数据库\n\n```sql\n# 切换到指定数据库\nuse 数据库名;\n# 例：use student;\n```\n\n> 选择数据库（因为服务器下面有可能有很多数据库， 我要选择哪一个数据库下面进行表的操作）\n\n### 查看数据库的创建\n\n```sql\n# 查看数据库的创建过程\nshow create database 数据库名;\n# 例：show create database student;\n```\n\n### 查看数据库的结构\n\n```sql\n# 查看数据库的结构\ndesc 表名\n# 例：desc student;\n```\n\n## 数据类型【重点】\n\n### 数值类型\n\nMySQL支持所有标准SQL数值数据类型。\n\n这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。\n\n关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。\n\nBIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。\n\n作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。\n\n| 数据类型            | 取值范围                           |\n|-----------------|--------------------------------|\n| tinyint         | -128 ~ 127                     |\n| int(integer)    | 4个字节，括号中代表显示的长度（无效），一般不加       |\n| bigint          | 8个字节存储                         |\n| float           | 浮点型，4个字节，精度到6位                 |\n| double          | 浮点型，8个字节，精度到第15位小数             |\n| decimal(p, [s]) | p为精度（默认为0），s为小数位数（默认为10，不能为负数） |\n\n> 【注意事项】\n>\n>decimal(p, [s])的小数位随便写，只保留有效位(s)，小数位有效位加整数位不能超过精度位(p)\n>\n\n### 字符串类型【重点】\n\n|    数据类型    |          取值范围           |\n|:----------:|:-----------------------:|\n|  char(n)   | 定长字符串，n的范围：大于等于1小于等于255 |\n| varchar(n) |   可变长字符串，n的返回为0~65535   |\n|    text    |      文本类型，最大长度为64k      |\n\n> 【注意事项】\n>\n>\n>1、char可以存储对应长度的数值，varchar也是允许的\n> 类似于java中的类型转换\n>\n>2、char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。\n>\n\n### 日期和时间类型\n\n|   数据类型    |        日期格式         |                       日期范围                        | 存储空间 |\n|:---------:|:-------------------:|:-------------------------------------------------:|:----:|\n|   YEAR    |        YYYY         |                    1901 ~ 2155                    | 1个字节 |\n|   TIME    |      HH:MM:SS       |              -838:59:59 ~ 838:59:59               | 3个字节 |\n|   DATE    |     YYYY-MM-DD      |              1000-01-01 ~ 9999-12-3               | 3个字节 |\n| DATETIME  | YYYY-MM-DD HH:MM:SS |     1000-01-01 00:00:00 ~ 9999-12-3 23:59:59      | 8个字节 |\n| TIMESTAMP | YYYY-MM-DD HH:MM:SS | 1970-01-01 00:00:01 UTC ~ 2038-01-19 03:14:07 UTC | 8个字节 |\n\n> 注意事项\n>\n>\n>要用字符形式添加\n>\n\n## 通过命令操作数据表\n\n### 查看数据表\n\n```sql\nshow tables;\n```\n\n> 这里会提示空表\n\n### 创建数据表【重点】\n\n```sql\ncreate table 表名(字段名 数据类型, 字段名 数据类型...);\n\n# 例如：\ncreate table student(\nid char(10),\nname varchar(25),\nage tinyint,\ninfo text);\n```\n\n### 查看当前表结构\n\n```sql\ndesc 表名;\n# 例如：desc student;\n```\n\n### 修改表 - 删除表字段\n\n```sql\nalter table 表名 drop 字段名;\n# 例如： alter table student drop times;\n```\n\n> 这个只能一个一个删除，如果想批量删除需要借助存储过程\n\n### 修改表 - 添加表字段\n\n添加一个字段\n\n```sql\nalter table 表名 add 字段名 数据类型;\n# 例如：alter table student add age tinyint(4);\n```\n\n在指定字段后添加字段\n\n```sql\n# 在指定字段后添加字段\nalter table 表名 add 字段名 数据类型 after 字段名;\n# 例如：alter table student add id int after birth;\n```\n\n添加多个字段\n\n```sql\n# 添加多个字段\nalter table 表名 add 字段名 数据类型, add 字段名 数据类型;\n# 例如：alter table student add username varchar(10), add password varchar(10);\n```\n\n添加多个字段在指定字段后\n\n```sql\n# 添加多个字段在指定字段后\nalter table 表名 add 字段名 数据类型 after 字段名, add 字段名 数据类型 after 字段名;\n# 例如：alter table student add sex varchar(10) after password, add hobby varchar(10) after age;\n```\n\n### 修改表 - 修改表字段\n\n```sql\n# 修改指定字段的数据类型\nalter table 表名 modify 字段名 字段类型\n# 例如：alter table student modify sex char;\n```\n\n修改指定字段的字段名和数据类型\n\n```sql\n# 修改指定字段的字段名和数据类型\nalter table 表名 change 要更改的字段名 更改后的字段名 更改后的字段类型\n# 例如：mysql> alter table student change sex gender boolean;\n```\n\n### 删除数据表\n\n```sql\ndrop table 数据表名;\n# 例如：drop table student;\n```\n\n## 通过命令操作数据【重点】\n\n### 插入数据(insert into)\n\n插入完整数据\n\n```sql\n# 插入完整数据\ninsert into 表名(字段名 ...) values(对应类型的数据 ...);\n# 例如：insert into student(id, name, age, sex, info) values(1, \"Buffer\", 23, 0, \"我是文本类型\");\n```\n\n插入指定数据\n\n```sql\n# 插入指定数据\ninsert into 表名(指定字段名 ...) values(对应类型的数据 ...);\n# 例： insert into student(id, info) values(1, \"再次测试\");\n```\n\n快捷插入数据\n\n```sql\n# 快捷插入数据：\ninsert into 表名 values(表中所有字段对应的数据);\n# 例： insert into student values(2, \"Wizard\", 22, 0, \"我是DBA\");\n```\n\n> 【注意】一一对应\n\n### 修改数据(update)\n\n```sql\n# 修改指定的数据\nupdate 表名 set 字段名 = 数据 where 用于判断的字段名 = 数据;\n# 例：mysql> uodate student set name = \"烤羊排\" where id = 1;\n```\n\n> 【注意】慎用，必须加上 where 及判断的条件\n\n### 删除数据(delete)\n\n```sql\n# 删除指定的数据\ndelete from 表名 where 用于判断的字段名 = 数据;\n# 例： delete from student where id = 3;\n```\n\n> 【注意】慎用，必须加上 where 及判断的条件\n\n### 查看数据(select)\n\n*代表通配符\n\n```sql\n# 查询表中所有字段的全部数据\nselect * from 表名;\n# 例如：select * from student;\n```\n\n> 注意：这种格式真实开发中不要使用，会严重拖慢运行速度\n\n```sql\n# 按照指定字段进行查询\nselect 字段名, 字段名 ... from student;\n# 例如：select id, age from student;\n```\n\n```sql\n# 通过别名的方式进行查询\nselect 字段名 as 别名, 字段名 as 别名, ... from 表名;\n# 例如：select id as \"编号\", name as \"姓名\", info as \"信息\" from student;\n```\n\n```sql\n# 最基本的条件查询\nselect 字段名... from 表名 where 用于判断的字段名 运算符 数据;\n# 例如：select * from student where id > 1;\n```\n\n通过逻辑运算符使用多个条件进行查询\n\n```sql\nselect 字段名... from 表名 where 条件判断1 and或者or 条件判断2;\n# 例如：select name from student where id = 1 and name = 'XXX';\n```\n\n## 数据约束【重点】\n\n其实我们昨天创建表的方式是错的，只是针对于初学者来说，我们没有足够的只是储备，只能这么来写，并不符合开发的标准，因为不够严谨，需要对数据进行约束，比如我们的数据类型，就是一种最基本的约束，再比如我们的java中，也有类似的约束，private，static，final，abstract，native，synchronized，volatile，transient等都是对我们数据的约束，我们的mysql中同样也需要对数据进行一个约束\n\n### 默认值(default)\n\n用户在插入数据的时候，如果没有给予当前字段一个数据的话，当前字段会按照你设置的默认的值进行填充\n\n ```sql\n # 使用默认值对数据进行约束\n create table 表名(\n     字段名 字段类型 default 默认值\n );\n # 例：create table person(country varchar(10) default 'PRC');\n ```\n\n修改数据库表字段并添加默认值\n\n ```sql\n alter table test modify id int default 0;\n ```\n\n### 非空(not null)\n\n指定的字段必须有数据，不能为空\n\n```sql\n# 插入数据时必须给予对应的值，不能为空\ncreate table 表名(\n    字段名 字段类型 not null\n);\n# 例：alter table person(id int not null);\n# 例：alter table person change id ssid int not null;\n```\n\n### 唯一(unique)\n\n被修饰的字段唯一，不能有重复数据\n\n ```sql\n # 插入数据时不能添加重复的数据\n create table 表/名(\n     字段名 字段类型 unique\n );\n # 例：create table person(id int unique);\n # 例：alter table test modify id int unique;\n ```\n\n### 主键(primary key)\n\n主键一般是该行数据的唯一的一个索引，并且修饰的这个字段只能类似于id字段\n\n ```sql\n # 声明主键\n create table 表名(字段名 字段类型 primary key);\n # 例：create table person(id int primary key);\n # 例：alter table person modify id int primary key;\n ```\n\n第二种写法，是我们官方推荐的写法，但我们并不这样写\n\n ```sql\n # 声明主键\n create table 表名(字段名 字段类型, primary key(字段名));\n # 例：create table person1(id int, primary key(id));\n ```\n\n> 【注意】：\n>\n> 1、任何情况下都应该给一张表添加一个主键字段\n>\n> 2、unique 和 not null 同时修饰一个字段时，等同于被 primary key 修饰\n>\n> 3、主键只能有一个\n>\n> 4、数据库设计中，一般会找一个与业务逻辑无关的字段设置为主键，性别，年龄，地址...都不能\n\n### 自增长(auto_increment)\n\n插入数据的时候会自己增加，一般和主键一起使用修饰类似于id的字段\n\n ```sql\n create table 表名(字段名 字段类型 primary key auto_increment);\n # 例：create table person(id int primary key auto_increment);\n ```\n\n> 【注意】\n>\n> 1、只能有一个字段使用 auto_increment ，它必须定义为键\n>\n> 2、auto_increment 只能修饰整型数据类型\n\n### 外键约束【了解】\n\n首先先写一个表中，可以正常插入\n\n ```sql\n create table employee(\n     employee_id int primary key auto_increment,\n     employee_name varchar(65) not null,\n     gender char(1) default '女', \n     dept_name varchar(10)  not null\n );\n ```\n\n这时候我们发现了一个问题，员工表和部门表应该是分开的，耦合度太高了，怎么办\n\n拆开成两张表\n\n ```sql\n create table department(\n     department_id int primary key  auto_increment,\n     department_name varchar(10) not null default '销售部'\n );\n \n create table employee(\n     employee_id int primary key auto_increment,\n     employee_name varchar(65) not null, \n     gender char(1) default '女', \n     dept_id int not null\n );\n ```\n\n然后发现没有部门id也能插入成功，并且删除了部门表中的字段，员工表中的数据还存在，这也是不符合逻辑的。我们可以使用外键约束使员工表中的部门id和部门表中的id进行关联。\n\n外键约束的格式：\n\n ```sql\n # 使用外键约束，让两个表的字段存在关联关系con\n create table 表名(\n     constraint 外键名 foreign key (受到约束的字段) references 约束数据表 (约束数据表中对应的字段)\n );\n # 例：create table employee(employee_id int primary key auto_increment, employee_name varchar(65) not null, gender char(1) default '女', dept_id int not null, constraint fk_employee_department foreign key (dept_id) references department (department_id));\n ```\n\n> 时间戳 从1970年1月1日0点0分0秒到现在的秒数 timestamp 修饰时间的数据类型\n>\n> 一般会设置 default current_timestamp ，表示默认由当前时间创建\n\n ```sql\n create table employee(\n     employee_id int primary key auto_increment,\n     employee_name varchar(65) not null, \n     gender char(1) default '女',\n     dept_id int not null,\n     create_time timestamp default current_timestamp,\n     constraint fk_employee_department foreign key (dept_id) references department (department_id)\n );\n ```\n\n> 【注意】外键约束之后会有如下特点：\n\n> 1、先添加主表（部门表），再添加从表（员工表）\n>\n> 2、先删除从表，再删除主表\n>\n> 3、先修改从表，再修改主表\n>\n> 4、使用外键以后约束以后，数据就会变的非常乱，不利于程序员的思维方式\n\n### 级联操作\n\n使用外键的时候，操作从表和主表都会存在问题 可以使用级联，通过级联删除和级联修改，可以直接操作主表中与子表中的字段\n\n ```sql\n 级联删除：\n \ton delete cascade\n \n 级联修改：\n \ton update cascade\n ```\n\n ```sql\n # 级联删除格式\n create table 表名(constraint 外键名 foreign key (受到约束的字段) references 约束数据表 (约束数据表中对应的字段) on delete cascade);\n ```\n\n ```sql\n # 级联修改格式\n create table 表名(constraint 外键名 foreign key (受到约束的字段) references 约束数据表 (约束数据表中对应的字段) on update cascade);\n ```\n\n## 数据查询【重点】\n\n### 基本查询\n\n#### 使用通配符查询全部字段\n\n ```sql\n# 查询表中所有字段的全部数据\nselect * from 表名;\n# 例如：select * from student;\n```\n\n#### 查询部分字段\n\n ```sql\n# 查询表中的指定字段\nselect 字段名1, 字段名2... from 表名;\n# 例：SELECT employee_id,first_name,email FROM t_employees;\n```\n\n#### 查询所有字段\n\n ```sql\n# 查询表中的所有字段\nselect 所有字段名 from 表名\n# 例：select id, name, age, sex, info from student;\n```\n\n> [注意：生产环境下，优先使用列名查询。* 的方式需转换成全列名，效率低，可读性差。]()\n\n### 对字段的数据进行运算\n\n ```sql\n# 对查询结果进行运算\nselect 字段名 运算符 操作数 from 表名;\n# 例：select salary * 12 from t_employees;\n# 例：select salary * 12 as '年薪' from t_employees;\n```\n\n| 算数运算符 |   描述    |\n|:-----:|:-------:|\n|   +   | 两列做加法运算 |\n|   -   | 两列做减法运算 |\n|   *   | 两列做乘法运算 |\n|   /   | 两列做除法运算 |\n\n> [注意：%是占位符，而非模运算符。]()\n\n### 通过别名查询(as)\n\n ```sql\n# 通过别名的方式进行查询\nselect 字段名 as 别名, 字段名 as 别名, ... from 表名;\n# 例如：select id as \"编号\", name as \"姓名\", info as \"信息\" from student;\n```\n\n### 查询结果去重(distinct)\n\n```sql\n# 查询结果去重\nselect distinct 字段名 from 表名;\n# 例：select distinct salary from student;\n```\n\n### 排序查询\n\n| 排序规则 |     描述      |\n|:----:|:-----------:|\n| asc  | 对前面排序列做升序排序 |\n| desc | 对前面排序列做降序排序 |\n\n#### 依据单字段排序\n\n ```sql\n# 单列排序\nselect 字段名 from 表名 order by 指定排序字段 [asc或desc];\n# 例：select * from student order by salary;\n# 例：select * from student order by salary asc;\n# 例：select * from student order by salary desc;\n```\n\n> 【注意】不加排序为默认为升序\n\n#### 依据多字段排序\n\n ```sql\n# 多列排序\nselect 字段名 from 表名 order by 指定排序字段 [asc或desc], 指定排序字段 [asc或desc]...; \n# 例：select * from student order by id asc, age desc;\n```\n\n> 【注意】先根据第一个排序字段排序，如果第一个字段相同，再根据第二个字段排序\n\n### 条件查询\n\n#### 等值判断（=）\n\n ```sql\n# 等值判断查询\nselect 字段名 from 表名 where 字段名 = 值;\n# 例：select * from student where salary = 6200;\n```\n\n> [注意：与 java 不同（==），mysql 中等值判断使用 =]()\n\n#### 逻辑判断（and、or、not）\n\n ```sql\n# 逻辑判断查询\nselect 字段名 from 表名 where [not] 条件一 逻辑运算符 条件二...;\n# 例：select * from student where salary != 0 and email = 'SKING';\n# 例：select * from student where salary = 6200 or email = 'SKING' or LAST_NAME = 'Steven';\n# 例：select * from student where not SALARY = 9000;\n```\n\n#### 不等值判断（> 、< 、>= 、<= 、!= 、<>）\n\n ```sql\n# 不等值判断查询\nselect 字段名 from 表名 where 字段名 关系运算符 值\n# 例：select * from student where salary > 6200;\n# 例：select * from student where salary <= 6200;\n# 例：select * from student where salary != 6200;\n# 例：select * from student where salary <> 6200;\n```\n\n> 【注意】<>表示不等于\n\n#### 区间判断（between and）\n\n```sql\n#查询员工的薪资在6000~10000之间的员工信息（编号，名字，薪资）\nSELECT employee_id , first_name , salary\nFROM t_employees\nWHERE salary BETWEEN 6000 AND 10000; #闭区间，包含区间边界的两个值\n```\n\n- [注：在区间判断语法中，小值在前，大值在后，反之，得不到正确结果]()\n\n#### NULL 值判断（IS NULL、IS NOT NULL）\n\n> IS NULL\n>\n>   列名 IS NULL\n>\n> IS NOT NULL\n>\n>   列名 IS NOT NULL\n\n```sql\n#查询没有提成的员工信息（编号，名字，薪资 , 提成）\nSELECT employee_id , first_name , salary , commission_pct\nFROM t_employees\nWHERE commission_pct IS NULL;\n```\n\n#### 枚举查询（ IN (值 1，值 2，值 3 ) ）（后面会用，尽管效率低）\n\n```sql\n#查询部门编号为70、80、90的员工信息（编号，名字，薪资 , 部门编号）\nSELECT employee_id , first_name , salary , department_id\nFROM t_employees\nWHERE department_id IN(70,80,90);\n```\n\n> 注：in的查询效率较低，可通过多条件拼接。\n\n#### 模糊查询\n\n> LIKE _ （单个任意字符）\n>\n>   列名 LIKE '张_'\n>\n>  %（任意长度的任意字符）\n>\n>   列名 LIKE '张%'\n\n- [注意：模糊查询只能和 LIKE 关键字结合使用]()\n\n```sql\n#查询名字以\"L\"开头的员工信息（编号，名字，薪资 , 部门编号）\nSELECT employee_id , first_name , salary , department_id\nFROM t_employees\nWHERE first_name LIKE 'L%';\n\n\n#查询名字以\"L\"开头并且长度为4的员工信息（编号，名字，薪资 , 部门编号）\nSELECT employee_id , first_name , salary , department_id\nFROM t_employees\nWHERE first_name LIKE 'L___';\n```\n\n#### 分支结构查询\n\n```sql\nCASE\n\tWHEN 条件1 THEN 结果1\n\tWHEN 条件2 THEN 结果2\n\tWHEN 条件3 THEN 结果3\nEND\n```\n\n> [注意：通过使用CASE END进行条件判断，每条数据对应生成一个值。]()\n> [经验：类似 Java 中的switch。]()\n\n```sql\n#查询员工信息（编号，名字，薪资 , 薪资级别<对应条件表达式生成>）\nSELECT employee_id , first_name , salary , department_id , \n       CASE\n           WHEN salary>=10000 THEN 'A'\n           WHEN salary>=8000 AND salary<10000 THEN 'B'\n           WHEN salary>=6000 AND salary<8000  THEN 'C'\n           WHEN salary>=4000 AND salary<6000  THEN 'D'\n   ELSE 'E'\n       END as \"LEVEL\"\nFROM t_employees;\n```\n\n### 分组查询\n\n> 语法：SELECT 列名 FROM 表名 WHERE 条件  [GROUP BY 分组依据（列）;]()\n\n| 关键字      | 说明                  |\n|----------|---------------------|\n| GROUP BY | 分组依据，必须在 WHERE 之后生效 |\n\n#### 7.8.1 查询各部门的总人数\n\n```sql\n#思路：\n#1.按照部门编号进行分组（分组依据是 department_id）\n#2.再针对各部门的人数进行统计（count）\nSELECT department_id,COUNT(employee_id)\nFROM t_employees\nGROUP BY department_id; \n```\n\n#### 7.8.2 查询各部门的平均工资\n\n```sql\n#思路：\n#1.按照部门编号进行分组（分组依据department_id）。\n#2.针对每个部门进行平均工资统计（avg）。\nSELECT department_id , AVG(salary)\nFROM t_employees\nGROUP BY department_id\n```\n\n#### 7.8.3 查询各个部门、各个岗位的人数\n\n```sql\n#思路：\n#1.按照部门编号进行分组（分组依据 department_id）。\n#2.按照岗位名称进行分组（分组依据 job_id）。\n#3.针对每个部门中的各个岗位进行人数统计（count）。\nSELECT department_id , job_id , COUNT(employee_id)\nFROM t_employees\nGROUP BY department_id , job_id;\n```\n\n#### 7.8.4 常见问题\n\n```sql\n#查询各个部门id、总人数、first_name\nSELECT department_id , COUNT(*) , first_name\nFROM t_employees\nGROUP BY department_id; #error\n```\n\n- [注：分组查询中，select显示的列只能是分组依据列，或者聚合函数列，不能出现其他列。]()\n\n### 分组过滤查询\n\n> 语法：SELECT 列名 FROM 表名 WHERE 条件 GROUP BY 分组列 [HAVING 过滤规则]()\n\n| 关键字         | 说明                |\n|-------------|-------------------|\n| HAVING 过滤规则 | 过滤规则定义对分组后的数据进行过滤 |\n\n#### 7.9.1 统计部门的最高工资\n\n```sql\n#统计60、70、90号部门的最高工资\n#思路：\n#1).\t确定分组依据（department_id）\n#2).\t对分组后的数据，过滤出部门编号是60、70、90信息\n#3).\tmax()函数处理\n\nSELECT department_id , MAX(salary) --查什么\nFROM t_employees--从哪查\nGROUP BY department_id--以。。。分组\nHAVING department_id in (60,70,90)。。。过滤掉不应该出现的部门id\n\n# group确定分组依据department_id \n#having过滤出60 70 90部门\n#select查看部门编号和max函数。\n```\n\n### 限定查询(limit)\n\n可以减缓服务器压力\n\n ```sql\n# 限定查询\nselect 字段名 from 表名 limit 起始行, 查询行数;\n```\n\n> 【注意】\n\n> 起始行是从 0 开始，代表了第一行。第二个参数代表的是从指定行开始查询几行\n>\n> 如果只有一个数字，会默认从第一条数据开始，显示数字对应的条数\n\n#### 分页查询\n\n一页显示 10 条，一共查询三页\n\n```sql\n# 思路：第一页是从 0开始，显示 10 条\nSELECT * FROM student LIMIT 0,10;\n\n# 第二页是从第 10 条开始，显示 10 条\nSELECT * FROM student LIMIT 10,10;\n\n# 第三页是从 20 条开始，显示 10 条\nSELECT * FROM student LIMIT 20,10;\n```\n\n注意：\n\n```sql\n1、在分页应用场景中，起始行是变化的，但是一页显示的条数是不变的\n\n2、分页公式：pageCount是页数，length是每页显示多少条\n\n\tlimit (pageCount - 1) * length, length\n```\n\n### 模糊查询\n\n搜索里面很常用\n\n格式：\n\n```sql\nselect 字段名 from 表名 where 指定查询字段 like 匹配值;\n```\n\n> 【注意】这里的匹配值需要使用占位符来占位，占位符分为两种：下划线和百分号\n\n| 占位符 |         占多少位         |\n|:---:|:--------------------:|\n|  _  |         单个字符         |\n|  %  | 不限定字符个数（可以是0个1个或者多个） |\n\n```sql\n# 使用单个字符占位符进行模糊查询\nselect 字段名 from 表名 where 指定查询字段 like 匹配值;\n# 例：select * from student where name like '呵__';\n# 例：select * from student where name like '呵_';\n# 例：select * from student where name like '_呵';\n```\n\n```sql\n# 使用多个字符占位符进行模糊查询\nselect 字段名 from 表名 where 指定查询字段 like 匹配值;\n# 例：select * from student where name like '呵%';\n# 例：select * from student where name like '%呵%';\n# 例：select * from student where name like '%呵';\n```\n\n最常用：\n\n```sql\nselect * from student where name like '%呵%';\n```\n\n### 合并查询（了解）\n\n ```sql\n# 合并两张表的结果，去除重复记录\nselect 字段... from 表1 union select 字段... from 表2;\n# 例：select * from father union select * from son;\n```\n\n> [注意：合并结果的两张表，列数必须相同，列的数据类型可以不同]()\n\n```sql\n# 合并两张表的结果，不去除重复记录（显示所有）\nselect 字段... from 表1 union all select 字段... from 表2;\n# 例：select * from father union all select * from son;\n```\n\n> [经验：使用 UNION 合并结果集，会去除掉两张表中重复的数据](\n\n## 联表查询【重点】\n\n### 注意事项\n\n> 1、查什么\n>\n>2、从哪查\n>\n>3、查询条件\n\n### **交叉连接**\n\n左表中的所有行，左表中的每一行与右表中的所有行再一一组合，形成的结果集的数据行数相当于两个表数据行数“相乘”后的结果。这种情况在数据库连接查询中，被称为交叉连接（也称为笛卡尔乘积连接）。在数据库中创建连接查询非常简单，只需要指明连接的表以及他们之间的关系即可\n\n格式\n\n ```sql\n select 字段名  from 表1, 表2... where 条件;\n ```\n\n####    \n\n```sql\n# 查询员工的姓名和对应的部门名称\nselect emp.EMPNO, emp.ENAME, dept.DNAME from emp, dept where emp.DEPTNO = dept.DEPTNO;\n```\n\n【注意】查询的字段需要通过 表名. 的形式来指明是哪张具体的表，如果查询条件中的字段，如果不指明是哪张表会报错，因为对于相同的字段无法判断到底是哪张表下的\n\n ```sql\n# 直接通过字段名进行查询员工的姓名和对应的部门名称，不指定具体某个表下的字段，因为字段是不重复的\nselect EMPNO, ENAME, DNAME from emp, dept where emp.DEPTNO = dept.DEPTNO;\n ```\n\n```sql\n# 错误演示：重复字段没有指明表\nselect EMPNO, ENAME, DNAME, DEPTNO from emp, dept where emp.DEPTNO = dept.DEPTNO;\n\n# 正确演示，指明表中的字段\nselect EMPNO, ENAME, DNAME, emp.DEPTNO from emp, dept where emp.DEPTNO = dept.DEPTNO;\n```\n\n```sql\n# 通过对表起别名进行查询员工的姓名和对应的部门名称以及部门编号\nselect e.EMPNO, e.ENAME, d.DNAME, e.DEPTNO from emp as e, dept as d where e.DEPTNO = d.DEPTNO;\n```\n\n【注意】as可以省略\n\n```sql\n# 通过对表起别名（省略as）进行查询员工的姓名和对应的部门名称以及部门编号\nselect e.EMPNO, e.ENAME, d.DNAME, e.DEPTNO from emp e, dept d where e.DEPTNO = d.DEPTNO;\n```\n\n```sql\n# 对字段进行起别名查询\nselect e.EMPNO as `员工号`, e.ENAME as `员工姓名`, d.DNAME as `部门名称` from emp as e, dept as d where e.DEPTNO = d.DEPTNO;\n```\n\n```sql\n# 省略as对字段进行起别名查询\nselect e.EMPNO `员工号`, e.ENAME `员工姓名`, d.DNAME `部门名称` from emp e, dept d where e.DEPTNO = d.DEPTNO;\n```\n\n```sql\n# 对查询的结果根据薪资进行倒序排序\nselect e.EMPNO as `员工号`, e.ENAME `员工姓名`, d.DNAME `部门名称` from emp as e, dept as d where e.DEPTNO = d.DEPTNO order by e.EMPNO desc;\n```\n\n### 内连接查询（INNER JOIN ON）\n\n和交叉连接的效果是一样的\n\n ```sql\n select 字段名 from 表1 inner join 表2 on 条件;\n ```\n\n```sql\n# 使用内连接查询员工号，员工姓名及部门名称并对其起别名\nselect e.EMPNO `员工号`, e.ENAME `员工姓名`, d.DNAME `部门名称` from emp e\ninner join dept d \non e.DEPTNO = d.DEPTNO;\n```\n\n> [经验：在 MySql 中，第交叉查询方式也可以作为内连接查询，不>符合 SQL 标准]()\n> [而内连接属于 SQL 标准，与其他关系型数据库通用]()\n\n### 三表连接查询\n\n```sql\n#查询所有员工工号、名字、部门名称、部门所在国家ID\nSELECT * FROM t_employees e \nINNER JOIN t_departments d \non e.department_id = d.department_id\nINNER JOIN t_locations l\nON d.location_id = l.location_id\n```\n\n### 左外连接（LEFT JOIN ON）\n\n> [注意：左外连接，是以左表为主表，依次向右匹配，匹配到，返回结果]()\n> [匹配不到，则返回 NULL 值填充]()\n\n```sql\nselect 字段名 from 表1 left outer join 表2 on 条件;\n```\n\n```sql\n# 使用左外连接查询员工号、员工姓名和部门名称\nselect e.EMPNO `员工号`, e.ENAME `员工姓名`, d.DNAME `部门名称` from emp e \nleft outer join dept d \non e.DEPTNO = d.DEPTNO;\n```\n\n### 右外连接（RIGHT JOIN ON）\n\n> [[注意：右外连接，是以右表为主表，依次向左匹配，匹配到，返回结果]()]()\n> [匹配不到，则返回 NULL 值填充]()\n\n```sql\n# 使用右外连接查询员工号、员工姓名和部门名称\nselect e.EMPNO `员工号`, e.ENAME `员工姓名`, d.DNAME `部门名称` from emp e \nright outer join dept d \non e.DEPTNO = d.DEPTNO;\n```\n\n## 子查询【掌握】\n\n#### 查询结果作为条件\n\n> SELECT 列名 FROM 表名  [Where 条件 (子查询结果)]()\n\n##### 查询工资大于螺蛳粉的员工信息\n\n```sql\n# 1.先查询到 螺蛳粉 的工资（一行一列）\nselect salary from student where name = '螺蛳粉'\n# 工资是 5000\n\n# 2.查询工资大于 螺蛳粉 的员工信息\nselect * from student where salary > 5000;\n\n# 3.将 1、2 两条语句整合\nselect * from student where salary > (select salary from student where name = '螺蛳粉');\n```\n\n> [注意：将子查询 ”一行一列“的结果作为外部查询的条件，做第二次查询]()\n> [子查询得到一行一列的结果才能作为外部查询的等值判断条件]()\n\n#### 作为枚举查询条件\n\n> SELECT 列名 FROM 表名 Where 列名 [in(子查询结果);]()\n\n##### 查询薪资与年龄等于20岁的员工的薪资相同的信息\n\n```sql\n#思路：\n# 1. 先查询年龄为20的人员的薪资(多行单列)\nselect salary from student where age = 20\n# 5000和6000\n\n# 2. 再查询薪资为5000、6000的员工信息\nselect * from student where salary in (5000, 6000);\n\n# 3.SQL：合并\nselect * from student where salary in (select salary from student where age = 20); \n```\n\n- [将子查询 ”多行一列“的结果作为外部查询的枚举查询条件，做第二次查询]()\n\n##### 查询薪资高于年龄等于20岁的员工的薪资相同的信息\n\n```sql\n# 1.先查询年龄为20的人员的薪资(多行单列)\nselect salary from student where age = 20\n\n# 2.查询薪资高于年龄为20的所有人的员工信息（高于所有）\nselect * from student where salary > all (select salary from student where age = 20);\n\n# 3.查询薪资高于年龄为20的部分人的员工信息（高于部分）\nselect * from student where salary > any (select salary from student where age = 20);\n```\n\n- [注意：当子查询结果集形式为多行单列时可以使用 ANY 或 ALL 关键字]()\n\n#### 派生表\n\n> SELECT 列名 FROM[（子查询的结果集）]() as 表名 WHERE 条件;\n\n##### 查询工资排名前 5 名的员工中薪资最低的员工\n\n```sql\n# 思路：\n# 1.先拿到排名前5名的员工所有信息\nselect * from student order by salary desc limit 0, 5\n\n# 2.再查询临时表中前5行员工信息\nselect min(salary) from (派生表);\n\n# SQL：合并\nselect min(test.salary) `薪水` from (select * from student order by salary desc limit 0, 5) as test;\n```\n\n将子查询 ”多行多列“的结果作为外部查询的一张表，做第二次查询\n\n## 查询执行顺序【掌握】\n\n介绍完了所有查询相关的语法，我们来把之前的所有语法集中到一个句子中。\n\n这才是完整的SELECT查询\n\n```sql\nSELECT DISTINCT colume, AGG_FUNC ( * column_or_expression * ), … \nFROM\n\tmytable\nJOIN another_table ON mytable.COLUMN = another_table.COLUMN \nWHERE\n\tconstraint_expression \nGROUP BY column \nHAVING\n\tconstraint_expression \nORDER BY\n\tcolumn ASC / DESC \nLIMIT count OFFSET COUNT;\n```\n\n一个查询SQL的执行总是先从数据里按条件选出数据，然后对这些数据再次做一些整理处理，按要求返回成结果，让结果尽可能是简单直接的。因为一个\n查询SQL由很多部分组成，所以搞清楚这些部分的执行顺序还挺重要的，这有助于我们更深刻的理解SQL执行过程.\n\n查询执行顺序\n\n1. `FROM` 和 `JOIN`s\n\n`FROM` 或 `JOIN`会第一个执行，确定一个整体的数据范围. 如果要JOIN不同表，可能会生成一个临时Table来用于\n下面的过程。总之第一步可以简单理解为确定一个数据源表（含临时表)\n\n2. `WHERE`\n\n我们确定了数据来源 `WHERE` 语句就将在这个数据源中按要求进行数据筛选，并丢弃不符合要求的数据行，所有的筛选col属性\n只能来自`FROM`圈定的表. AS别名还不能在这个阶段使用，因为可能别名是一个还没执行的表达式\n\n3. `GROUP BY`\n\n如果你用了 `GROUP BY` 分组，那`GROUP BY` 将对之前的数据进行分组，统计等，并将是结果集缩小为分组数.这意味着 其他的数据在分组后丢弃.\n\n4. `HAVING`\n\n如果你用了 `GROUP BY` 分组, `HAVING` 会在分组完成后对结果集再次筛选。AS别名也不能在这个阶段使用.\n\n5. `SELECT`\n\n确定结果之后，`SELECT`用来对结果col简单筛选或计算，决定输出什么数据.\n\n6. `DISTINCT`\n\n如果数据行有重复`DISTINCT` 将负责排重.\n\n7. `ORDER BY`\n\n在结果集确定的情况下，`ORDER BY` 对结果做排序。因为`SELECT`中的表达式已经执行完了。此时可以用AS别名.\n\n8. `LIMIT` / `OFFSET`\n\n最后 `LIMIT` 和 `OFFSET` 从排序的结果中截取部分数据.\n\n结论\n\n> 不是每一个SQL语句都要用到所有的句法，但灵活运用以上的句法组合和深刻理解SQL执行原理将能在SQL层面更好的解决数据问题，而不用把问题都抛给程序逻辑.\n\n## 内置函数【了解】\n\n如果没有特别的需求，就不要使用，因为会拖慢数据库的执行效率\n\n### 时间函数\n\n> 语法：SELECT [时间函数([参数列表]) ]()\n\n> [经验：执行时间函数查询，会自动生成一张虚表（一行一列）]()\n\n| 时间函数                   | 描述                                      |\n|------------------------|:----------------------------------------|\n| sysdate()              | 当前系统时间（年-月-日 时:分:秒）                     |\n| current_timestamp()    | 当前系统时间（年-月-日 时:分:秒）                     |\n| now()                  | 当前系统时间（年-月-日 时:分:秒）                     |\n| curdate()              | 获取当前日期（年-月-日）                           |\n| current_date()         | 获取当前日期（年-月-日）                           |\n| curtime()              | 获取当前时间（时:分:秒）                           |\n| current_time()         | 获取当前时间（时:分:秒）                           |\n| week(指定日期)             | 获取指定日期为一年中的第几周                          |\n| year(指定日期)             | 获取指定日期的年份                               |\n| month(指定日期)            | 获取指定日期的月份                               |\n| day(指定日期)              | 获取指定日期的日                                |\n| hour(指定时间)             | 获取指定时间的小时值                              |\n| minute(指定时间)           | 获取时间的分钟值                                |\n| second(指定时间)           | 获取时间的秒值                                 |\n| datediff(date1, date2) | 获取 date1 和 date2 之间相隔的天数（date1 - date2） |\n| adddate(date, N)       | 计算 date 加上 N 天后的日期                      |\n\n```sql\n# 获取当前时间的年月日时分秒\nselect sysdate();\nselect current_timestamp();\nselect now();\n```\n\n```sql\n# 获取当前时间的年月日\nselect curdate();\nselect current_date();\n```\n\n```sql\n# 获取当前时间的时分秒\nselect curtime();\nselect current_time();\n```\n\n```sql\n# 获取指定日期对应一年中的星期数\nselect week('2020-10-24');\n\n# 获取当前日期对应一年中的星期数\nselect week(curdate());\n```\n\n```sql\n# 获取指定日期中的年\nselect year('2020-10-24');\n\n# 获取当前日期的年\nselect year(curdate());\n```\n\n```sql\n# 获取指定日期中的月份\nselect month('2020-10-24');\n\n# 获取当前日期的月份\nselect month(curdate());\n```\n\n```sql\n# 获取指定日期中的天\nselect day('2020-10-24');\n\n# 获取当前日期的天\nselect day(curdate());\n```\n\n```sql\n# 获取指定时间中的小时\nselect hour('10:20:30');\n\n# 获取当前时间中的小时\nselect hour(curtime());\n```\n\n```sql\n# 获取指定时间中的分钟\nselect minute(‘10:20:30’);\n\n# 获取当前时间中的分钟\nselect minute(curtime());\n```\n\n```sql\n# 获取指定时间中的秒\nselect second(‘10:20:30’);\n\n# 获取当前时间中的秒\nselect second(curtime());\n```\n\n```sql\n# 获取两个日期之间的差值\nselect datediff('2021-03-01', curdate());\n```\n\n```sql\n# 获取指定日期加上指定天数后的日期\nselect adddate(curdate(), 7);\n```\n\n### 字符串查询\n\n> 语法： SELECT [字符串函数 ([参数列表])]()\n\n| 字符串函数                      | 描述                                     |\n|----------------------------|----------------------------------------|\n| concat(str1,str2,str....)  | 将多个字符串连接                               |\n| insert(str,pos,len,newStr) | 将 str 中指定 pos 位置开始 len 长度的内容替换为 newStr |\n| lower(str)                 | 将指定字符串转换为小写                            |\n| upper(str)                 | 将指定字符串转换为大写                            |\n| substring(str,num,len)     | 将 str 字符串从指定 num 位置开始截取  len 个长度的内容    |\n\n```sql\n# 拼接字符串\nselect concat('My', 'S', 'QL');\n```\n\n```sql\n# 在指定位置使用新字符串替换指定长度的旧字符串\nselect insert('这是数据库', 3, 0, 'MySQL');\n```\n\n```sql\n# 将指定字符串转换为小写\nselect lower('MYSQL');\n```\n\n```sql\n# 指定内容转换为大写\nselect upper('mysql');\n```\n\n```sql\n# 从指定位置开始截取指定长度的字符串\nselect substring('MySQL', 3, 3);\n```\n\n### 聚合函数\n\n> 语法：SELECT [聚合函数(字段名)]() FROM 表名;\n\n[经验：对多条数据的单列进行统计，返回统计后的一行结果。]()\n\n| 聚合函数                  | 描述           |\n|-----------------------|--------------|\n| sum(字段名)              | 求所有行中单列结果的总和 |\n| avg([distinct] 字段名)   | 平均值          |\n| max([distinct] 字段名)   | 最大值          |\n| min([distinct] 字段名)   | 最小值          |\n| count([distinct] 字段名) | 计数           |\n\n```sql\n# 获取学生表中薪水的最大值\nselect sum(salary) from student;\n```\n\n```sql\n# 获取学生表中薪水的平均值\nselect avg(salary) from student;\n\n# 获取学生表中不重复的薪水的平均值\nselect avg(distinct salary) from student;\n```\n\n```sql\n# 获取学生表中薪水的最大值\nselect max(salary) from student;\n\n# 获取学生表中不重复的薪水的最大值\nselect max(distinct salary) from student;\n```\n\n```sql\n# 获取学生表中薪水的最小值\nselect min(salary) from student;\n\n# 获取学生表中不重复的薪水的最小值\nselect min(distinct salary) from student;\n```\n\n```sql\n# 获取表中数据的行数\nselect count(*) from student;\nselect count(1) from student;\n\n# 获取指定字段的行数\nselect count(salary) from student;\n\n# 获取指定字段去重后的行数\nselect count(distinct salary) from student;\n```\n\n[注意：聚合函数自动忽略null值，不进行统计。]()\n\n### 数学函数\n\n| 数学函数        | 描述                          |\n|-------------|-----------------------------|\n| abs(X)      | 绝对值                         |\n| ceil(X)     | 向上取整                        |\n| floor(X)    | 向下取整                        |\n| round(X, D) | 对 X 四舍五入，D为保留的位数，可以是正数负数或者0 |\n| rand()      | 随机数，[0, 1)                  |\n| mod(M, N)   | 取 M 除以 N 的余数                |\n\n```sql\n# 获取绝对值\nselect abs(-1);\n```\n\n```sql\n# 向上取整\nselect ceil(12.45);\n```\n\n```sql\n# 向下取整\nselect floor(12.45);\n```\n\n```sql\n# 四舍五入，保留一位小数\nselect round(12.45, 1);\n```\n\n```sql\n# 取0到1之间的随机数，能取到0取不到1\nselect rand();\n```\n\n```sql\n# 取余数\nselect mod(10, 3);\n```\n\n### 系统函数\n\n| 系统函数       | 描述          |\n|------------|-------------|\n| database() | 获取当前数据库名    |\n| user()     | 获取当前用户名     |\n| version()  | 获取当前MySQL版本 |\n\n```sql\n# 获取当前数据库名\nselect database();\n```\n\n```sql\n# 获取当前用户名\nselect user();\n```\n\n```sql\n# 获取当前MySQL版本\nselect version();\n```\n\n### **加密函数**\n\n| 加密函数                  | 描述                         |\n|-----------------------|----------------------------|\n| password(str)         | 返回字符串str的加密版本              |\n| md5(str)              | 使用 MD5 算法进行加密              |\n| encode(str,key)       | 使用 key 作为密钥解密加密字符串 str     |\n| decode(str, pswd_str) | 使用 pswd_str 作为密匙对 str 进行解密 |\n\n```sql\n# 对指定字符串进行加密\nselect password('123');\n```\n\n```sql\n# 对指定字符串进行加密\nselect md5('123');\n```\n\n```sql\n# 加密\nselect encode('123', '123');\n\n# 解密\nselect decode(encode('123', '123'), '123');\n```\n\n## 事务【重点】\n\n### 事务介绍\n\n#### 事务的概念\n\n> 事务指逻辑上的一组原子性的操作，组成这组操作的各个单元，要不全部成功，要不全部不成功\n\n#### 事务相关命令\n\n```sql\n# 开启事务 \n#（等同于set autocommit = off ）\n#（等同于set autocommit = 0 ）\nstart transaction \n\n# 回滚事务\nrollback\n\n# 提交事务\ncommit\n```\n\n### Mysql中使用事务\n\n#### MySQL中事务默认自动提交的\n\n每当执行一条SQL，就会提交一个事务 （一条SQL 就是一个事务）；Oracle 中事务默认 不自动提交，需要在执行SQL 语句后 通过 commit\n手动提交事务。\n\n#### MySQL 管理事务的方式【重要】\n\n方式一 ：通过手动事务管理 SQL 语句\n\n```sql\n# 开启事务\nstart transaction\n\n# 回滚事务 （将数据恢复到事务开始时状态）\nrollback\n\n# 提交事务 （对事务中进行操作，进行确认操作，事务在提交后，数据就不可恢复）\ncommit\n```\n\n方式二：设置自动提交\n\n数据库中存在一个自动提交变量 ，通过\n\n```sql\nshow variables like '%commit%';\n```\n\n---- autocommint 值是 on，说明开启自动提交，通过命令可以关闭自动提交\n\n```sql\nset autocommit = off / set autocommit = 0\n```\n\n> 如果设置 autocommit 为 off，意味着以后每条SQL 都会处于一个事务中，相当于每条SQL执行前 都执行 start transaction\n>\n> 补充：Oracle中 autocommit 默认就是 off\n\n### JDBC 使用事务【了解】\n\n#### 概述\n\n> 当Jdbc程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据库提交在它上面发送的SQL语句。可以通过命令关闭这种默认提交方式，让多条SQL在一个事务中执行\n\n#### JDBC控制事务语句\n\n```java\n// 相当于start transaction\nconnection.setAutoCommit(false);\n\n// rollback\nconnection.rollback();\n\n// commit\nconnection.commit();\n```\n\n### 事务特性(ACID)\n\n#### 原子性（Atomicity）\n\n原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。\n\n#### 一致性（Consistency）\n\n事务前后数据的完整性必须保持一致。\n\n#### 隔离性（Isolation）\n\n事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离。\n\n#### 持久性（Durability）\n\n持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。\n\n> 【注】：多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性\n\n### 为什么要有事务的隔离级别\n\n多个线程开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个线程在获取数据时的准确性，避免脏读、不可重复读和幻读的问题。\n\n### 事务的四种隔离级别\n\n> 数据库内部定义了四种隔离级别，用于解决三种隔离问题\n\n1、Serializable：可避免脏读、不可重复读、虚读情况的发生。（串行化、序列化）\n\n2、Repeatable Read：可避免脏读、不可重复读情况的发生。（可重复读）不可以避免虚读\n\n3、Read Committed：可避免脏读情况发生（读已提交）\n\n4、Read uncommitted：最低级别，以上情况均无法保证。(读未提交)\n\n> 【注意】事务的隔离级别越高，效率越低！！！\n\n### 设置事务的隔离级别\n\n#### mysql中设置\n\n##### 查看事务隔离级别\n\n```sql\n# 查询当前事务隔离级别\nselect @@tx_isolation \n```\n\n> mysql中默认的事务隔离级别是 Repeatable read.\n\n> 扩展:oracle 中默认的事务隔离级别是 Read committed\n\n##### mysql中设置事务隔离级别\n\n```sql\n# 设置事务隔离级别（当前会话）\nset session transaction isolation level   \n\n# 设置事务隔离级别（全局）\nset global transaction isolation level  \n```\n\n##### JDBC中设置事务隔离级别\n\nConnection接口中定义事务隔离级别四个常量：\n\n```java\n// 指示不可以发生脏读的常量；不可重复读和虚读可以发生。 \nstatic int TRANSACTION_READ_COMMITTED \n\n// 指示可以发生脏读 (dirty read)、不可重复读和虚读 (phantom read) 的常量。 \nstatic int TRANSACTION_READ_UNCOMMITTED \n\n// 指示不可以发生脏读和不可重复读的常量；虚读可以发生。 \nstatic int TRANSACTION_REPEATABLE_READ \n\n// 指示不可以发生脏读、不可重复读和虚读的常量。 \nstatic int TRANSACTION_SERIALIZABLE \n```\n\n设置隔离级别\n\n```java\n// 设置数据库隔离级别\nvoid setTransactionIsolation(int level) \n```\n\n### 三种隔离问题\n\n##### 脏读\n\n> 读取到了其他事务未提交的数据\n\nA 转账 给B 100，未提交\n\nB 查询账户多了100\n\nA 回滚\n\nB 查询账户那100不见了\n\n##### 不可重复读\n\n> 读取到了其他事务提交的数据（强调数据更新 update和 delete）\n>\n> 简单理解：一个事务范围内两个相同的查询却返回了不同结果\n\nA 查询账户 5000\n\nB 向 A 账户转入 5000\n\nA 查询账户 10000\n\n##### 虚读(幻读)\n\n> 读取到了其他事务提交的数据 （强调数据记录变化 insert ）\n\nA 第一次读取 存在5条记录\n\nB 向 A 插入一条新的记录\n\nA 第二次读取 存在6条记录\n\n### 总结\n\n>\n当我们进行增删改操作的时候，涉及到一些数据安全性的问题，可以使用事务来进行完善处理，首先关闭自动提交（[set autocommit = 0;]()\n），如果我们发现我们的增删改操作是有问题的，那我们可以回滚到[autocommit = 0]()\n之前，如果我们的操作是没有问题的，就使用[commit]()进行提交操作，此时我们set [autocommit = 0]()到[commit]()中间的所有操作都会生效。\n\n## 索引【重点】\n\n### 概述\n\n> MySQL 官方对索引的定义为：索引是帮助 MySQL 高效获取数据的数据结构。\n>\n>数据本身之外，数据库还维护着一个满足特定查找算法的数据结构，这些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引。\n>\n>简单理解：排好序的快速查找数据结构！\n\n### 目的\n\n> 提高查找效率\n\n### 索引的特点\n\n> 我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)\n>\n结构组织的索引。其中聚集索引，次要索引复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(\n> hashindex)等。\n\n### 素引的优点\n\n> 1、类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本\n>\n> 2、通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗\n\n### 索引的缺点\n\n> 1、实际上索引也是一张表，该表保存了主键与索引字段、并指向实体表的记录，所以索引列也是要占用空间的。虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。每次更新添加了索引列的字段，都会调整，因为更新所带来的键值变化后的索引信息会发生改变。\n>\n> 2、索引需要占用磁盘空间，甚至有可能比数据本身占用的空间还要大。\n>\n> 3、索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立和维护最优秀的索引，或优化查询条件\n\n### 索引的分类\n\n#### 普通索引(单列索引)【常用】\n\n一个索引只包含单个列，一个表可以有多个单列索引\n\n普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。\n\n#### 唯一索引【常用】\n\n索引列的值必须唯一，但允许有空值(但只能有一个)。\n\n#### 主键索引\n\n主键索引是一种特殊的唯一索引，不允许有空值。主键索引一定是唯一索引，但是唯一索引不一定是主键索引。\n\n#### 组合索引(复合索引)【重要】\n\n组合素引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。\n\n> 【注意】\n>\n>1、当需要频繁地将两列或多列作为一个整体进行搜索时，可以创建组合索引\n>\n>2、创建组合索引时先列出唯一性良好的列。\n>\n>3、组合索引中列的顺序和数量会影响查询的性能。\n\n#### 全文索引\n\n全文索引类型为 FULTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文案引可以在 CHAR、VARCHAR\n成者 TEXT 类型的列上设置，同时在 MySQL 中只有 MyISAM 存储引擎支持全文索引。\n\n#### 空间索引\n\n空间索引是对空间数据类型的字段建立的案引，MySQL 中的空间数据类型有4种，分储是：GEOMETRY、POINT、LINESTRING 和 POLYGON。MySQL\n使用SPATIAL 关键字进行扩展，使得能够用于创建正规索引类似的语法创建建空间索引。创建空间索引的字段，必须设置NOT\nNULL约束。空间索引只能在存储引擎为 MyISAM 的表中创建。\n\n### 索引的设计原则\n\n索引的设计不合理或者缺少索引都会影响数据库和应用程序的性能。高效的索引对于获得良好的性能非常重要。设计索引时，应该考虑以下准则:\n\n1、索引并非越多越好，一个表中如果有大量的索引，不仅占用磁盘空间，而且会影响 INSERT、DELETE、UPDATE\n等语句的性能，因为当表中的数据更改时，索引也会进行调整和更新。\n\n2、避免对经常更新的列设置索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。\n\n3、数据量小的表最好不要使用索引，由于数据量较少，查询花费的时间可能比遍历索引的时间还短，索引可能不会产生优化效果。\n\n4、在不同值较少的字段上不必要建立索引，如性别字段。\n\n5、在频繁进行排序或分组的列上建立索引，如果经常需要排序的列有多个，可以在这些列上建立组合索引。\n\n### 查看索引\n\n```sql\n# 查看指定表中的索引相关信息\nshow index from 表名;\n# 例：show index from student;\n```\n\n### 创建索引\n\n添加主键索引\n\n```sql\n# 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。\nalter table 表名 add primary key (列名);\n# 例：alter table student add primary key (id);\n```\n\n添加唯一索引\n\n```sql\n# 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次)。\nalter table 表名 add unique [索引名] (列名);\n# 例：alter table student add unique index_name (name);\n```\n\n添加普通索引\n\n```sql\n# 添加普通索引，索引值可出现多次。\nalter table 表名 add index [索引名] (列名);\n# 例：alter table student add index index_age (age);\n```\n\n添加全文索引\n\n```sql\n# 该语句指定了索引为 FULLTEXT，用于全文索引。\nalter table 表名 add fulltext [索引名] (列名);\n# 例：alter table student add fulltext index_full (info);\n```\n\n创建表时指定索引\n\n```sql\n# 创建表时可以同时声明索引\ncreate table 表名(字段名 数据类型 [数据约束...], 字段名 数据类型 [数据约束...], 索引1, 索引2...);\n# 例：create table student(id int, name varchar(10), primary key (id), index index_name (name));\n```\n\n> 【注意】索引名不是必须的，如果没有声明会由默认的字段名代替\n\n### 删除索引\n\n> ```sql\n># 删除指定表中的指定索引\n>drop index [索引名] on 表名;\n># 例：drop index username on account;\n>```\n\n### 索引结构\n\n#### BTree索引\n\n#### Hash索引\n\n#### full-text全文索引\n\n#### R-Tree索引\n","tags":["MySQL"],"categories":["学习笔记"]},{"title":"安装Hyper-V创建虚拟机","url":"/posts/InstallHyper-VAndCreateVirtualMachine.html","content":"\n## 先决条件\n\n- 具有计算机管理员权限的用户帐户。\n- 足够的内存来运行您计划同时运行的所有虚拟机。\n- 作为虚拟机的来宾操作系统安装的软件。\n- 该教程仅适用于在 Windows 8 或 Windows 8.1 以上\n\n## 安装Hyper-V\n\n### 使用程序和功能启用Hyper-V\n\n1. 在控制面板中，单击**程序**>**程序和功能**。\n\n   ![ProgramsAndFeatures](InstallHyper-VAndCreateVirtualMachine/ProgramsAndFeatures.png)\n\n2. 单击**打开或关闭 Windows 功能**。\n\n   ![OpenHyper-V](InstallHyper-VAndCreateVirtualMachine/OpenHyper-V.png)\n\n3. 单击**Hyper-V**，单击**确定**，然后单击**关闭**。\n\n> Hyper-V 是一项可选功能，因此安装所需的文件可能存在也可能不存在于您的计算机上，具体取决于您组织的 IT 策略。如果您已连接到 Internet 并启用了该功能，所需的文件将自动下载。如果您没有连接到 Internet，您可以下载所需的文件并手动将它们复制到您的计算机上。否则，您必须提供安装介质。\n\n### 使用 PowerShell 启用Hyper-V\n\n1. 使用提升的用户权限打开 Windows PowerShell 会话。为此，请单击 Windows**开始**按钮并键入**PowerShell**。右键单击**PowerShell**，然后单击**以管理员身份运行**。\n\n2. 运行以下命令。\n\n   ```shell\n   enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Hyper-V -All\n   ```\n\n3. 安装完成后，重新启动计算机。\n\n## 创建虚拟机\n\n您可以使用 Hyper-V 管理器中的向导或使用 Windows PowerShell 创建虚拟机。\n\n### 在 Hyper-V 管理器中创建虚拟机\n\n1. 打开 Hyper-V 管理器。\n2. 从 Hyper-V 管理器的导航窗格中，选择运行 Hyper-V 的计算机。\n3. 在“操作”窗格中，单击**新建**>**虚拟机**。\n4. 在新建虚拟机向导中单击**下一步。**\n5. 在**指定名称和位置**页面上，键入适当的名称。\n6. 在**分配内存**页面上，指定足够的内存来启动客户操作系统。\n7. 在**配置网络**页面上，将虚拟机连接到您在安装 Hyper-V 时创建的交换机。\n8. 在**连接虚拟硬盘**和**安装选项**页面上，选择适合您计划安装来宾操作系统的选项：\n   - 如果您要从 DVD 或映像文件（.ISO 文件）安装来宾操作系统，请选择**Create a virtual hard disk**。单击**下一步**，然后单击描述您将使用的媒体类型的选项。例如，要使用 .iso 文件，请单击**从引导 CD/DVD 安装操作系统**，然后指定 .iso 文件的路径。\n   - 如果客户机操作系统已安装在虚拟硬盘中，请选择**使用现有虚拟硬盘**并单击**下一步**。然后，选择**稍后安装操作系统**。\n9. 在摘要页面上，验证您的选择，然后单击**完成**。\n\n### Windows PowerShell创建虚拟机\n\n您可以使用[New-VM](https://technet.microsoft.com/library/hh848537(v=wps.630).aspx) cmdlet 在 Windows PowerShell 中创建虚拟机。例如，运行以下命令来创建一个名为 web server 的虚拟机，它具有 1 GB 的启动内存，并使用已经安装了客户操作系统的现有虚拟硬盘。\n\n```shell\nNew-VM –Name “web server” –MemoryStartupBytes 1GB –VHDPath d:\\vhd\\BaseImage.vhdx\n```\n\n\n\n参考教程 [Microsoft Docs](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh846766(v=ws.11))\n","tags":["Hyper-V"],"categories":["学习笔记"]},{"title":"JDK安装和配置","url":"/posts/WindowsInstallJDK.html","content":"\n## 下载\n\n[官方连接](https://www.oracle.com/java/technologies/downloads/#java8)\n\n[阿里云盘](https://www.aliyundrive.com/s/hgcoATujH3r)\n\n## 安装\n\n![install_process](WindowsInstallJDK/install_process.png)\n\n![choose_path](WindowsInstallJDK/choose_path.png)\n\n![install_success](WindowsInstallJDK/install_success.png)\n\n## 配置环境变量\n\n[参考文章](https://islu.cn/posts/9977.html)\n\n参考上文中环境变量文章，将 `MySQL` 的环境变量换为 `JDK` 即可\n\n新建 `JAVA_HOME` 值 `JDK安装路径`\n\n![path_javaHome](WindowsInstallJDK/path_javaHome.png)\n\n添加 `Path` 值 ` %JAVA_HOME%\\bin`\n\n![path_path](WindowsInstallJDK/path_path.png)\n\n## 检验\n\n使用 `CMD` 打开命令窗口后输入 `javac` \n\n![success](WindowsInstallJDK/success.png)\n","tags":["Java","Windows"],"categories":["学习笔记"]},{"title":"MySQL安装和配置","url":"/posts/WindowsInstallMySQL.html","content":"\n## 下载\n\n从 [传送门](https://dev.mysql.com/downloads/) 内寻找安装方式\n\n![install_url](WindowsInstallMySQL/install_url.png)\n\n选择版本及下载安装方式\n\n![install_version](WindowsInstallMySQL/install_v.png)\n\n下载成功\n\n![down_success](WindowsInstallMySQL/down_success.png)\n\n## 安装\n\n选择安装方式\n![install_type](WindowsInstallMySQL/install_type.jpg)\n\n选择后点击 `Next` 进行下一步，此处我选择 `自定义` 安装方式\n\n![choose_install_server](WindowsInstallMySQL/choose_install_server.jpg)\n\n![set_install_url](WindowsInstallMySQL/set_install_url.jpg)\n\n基本上一路 `Next`\n\n![installing](WindowsInstallMySQL/installing.jpg)\n\n![type_networking](WindowsInstallMySQL/type_networking.jpg)\n\n![method](WindowsInstallMySQL/method.jpg)\n\n设置 `root` 账户密码\n\n![root_password](WindowsInstallMySQL/root_password.jpg)\n\n继续 `Next`\n\n![choose_service](WindowsInstallMySQL/choose_service.jpg)\n\n应用配置\n\n![apply_config](WindowsInstallMySQL/apply_config.jpg)\n\n显示下图，配置成功\n\n![config_success](WindowsInstallMySQL/config_success.jpg)\n\n继续 `Next`\n\n![config_success](WindowsInstallMySQL/config_success.jpg)\n\n安装成功\n\n![success](WindowsInstallMySQL/success.jpg)\n\n## 配置环境变量\n\n打开 `此电脑` > 右键 `属性` > `高级系统设置`\n\n![system_setting](WindowsInstallMySQL/system_setting.png)\n\n打开 `环境变量` > 系统变量下的 `Path`\n\n![setting_path](WindowsInstallMySQL/setting_path.png)\n\n复制 `MySQL` 安装路径 `D:\\development\\MySQL\\MySQL Server 8.0\\bin` 打开 `Path` 新建\n\n将安装路径复制到 `Path` 后一路确定 后大功告成  最后一步检验\n\n## 检验\n\n使用 `CMD` 打开命令窗口后输入 `mysql -u root -p` 即可输入密码连接\n\n> 按 Win + R 输入 cmd 回车打开命令窗口\n> \n![mysql_test](WindowsInstallMySQL/mysql_test.jpg)\n\n","tags":["MySQL","Windows"],"categories":["学习笔记"]},{"title":"Matery主题添加Pjax","url":"/posts/MateryAddPjax.html","content":"\n# 如何给matery主题添加Pjax\n\n## Pjax优点\n\n1. 减轻服务端压力\n\n   > 按需请求，每次只需加载页面的部分内容，而不用重复加载一些公共的资源文件和不变的页面结构，大大减小了数据请求量，以减轻对服务器的带宽和性能压力，还大大提升了页面的加载速度。\n\n2. 优化页面跳转体验\n\n   > 使用pjax后，只刷新部分页面，切换效果更加流畅，而且可以定制过度动画，在等待页面加载的时候体验就比较舒服了。\n\n> 我知道你们在意的是教程不是这些啰嗦的废话，下面就是正文\n\n## 教程\n\n### 基本了解\n\nPjax的使用可以在保证`Nav` `Header` `Footer` 不变的基础上改变 `Main` 的内容(适用于页面结构相对简单的主体)\n\n![页面基本构成](WindowsPowerShellOperationHexo/layout.png)\n\n### 步骤\n\n#### 新建pjax.ejs\n\n在 `_widget` 目录下新建 `pjax.ejs` 文件\n\n```html\n<% if(theme.pjax){ %>\n    <script type=\"text/javascript\">\n        $.getScript(\"https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\", loadPjax)\n\n        function loadPjax() {\n            var pjax = new Pjax({\n                selectors: [\n                    \"head title\",\n                    'head meta[name=\"keywords\"]',\n                    'head meta[name=\"description\"]',\n                    \"main#main_wrap\"\n                ],\n                cache: true,\n                cacheBust: false\n            });\n        }\n\n        // Pjax请求错误时，跳转到404页面\n        document.addEventListener('pjax:error', (err) => {\n            if (err.request.status === 404) {\n                pjax.loadUrl('/401.html')\n            }\n        })\n    </script>\n<% } %>\n\n```\n\n#### 添加容器\n\n找到 `layout.eje` 为 `<%- body %>` 套一个 `<main>` 标签\n\n```html\n<main id=\"main_wrap\">\n    <%- body %>\n</main>\n```\n\n#### 引入pjax.ejs\n\n找到 `layout.ejs` 在底部(首次加载没必要优先加载Pjax)添加\n\n```html\n<%- partial('_widget/pjax') %>\n```\n\n#### 添加pjax开关\n\n在 `themes\\_config.yml`中添加\n\n```yaml\npjax: true\n```\n\n#### bug的解决\n\n由于Pjax会导致容器内的函数不会重载，要重载一下函数\n\n在此仅提供重载方法，不一一做演示了\n\n##### 部分修改页面\n\n由于时间问题，仅提供一些需要修改的 `ejs` 内容作为参考\n\n1. 评论页面ejs（我使用的是valine，故我需要将valine.ejs页面进行修改）\n2. 谷歌统计页面（google-analytics.ejs）\n3. 文章目录（post-detail-toc.ejs）\n4. 说说页面（artitalk.ejs）\n5. 标签页面（tags）的词云（tag-wordcloud.ejs）\n6. 分类页面（categories）雷达图(category-radar.ejs)\n7. 归档页面(archives)统计图(post-calendar.ejs)\n8. 关于页面（about）的统计图(post-charts.ejs)\n\n> 欢迎提交遗漏bug\n\n##### 标签 (tags)页面为例\n\n1. 当操作完以上步骤后从首页点进标签(tags)页面时会有一下报错\n\n   ![error](WindowsPowerShellOperationHexo/error.png)\n\n2. 打开 `tags.ejs` 该页面由 `tag-cloud` `tag-wordcloud` 两个ejs组成，故要查看这两个 `ejs` 页面哪里出现了 `jQCloud` 函数\n\n   ![tag_do](WindowsPowerShellOperationHexo/tag_do.png)\n\n3. 找到bug处进行修改，原页面\n\n   1. 原页面\n\n      ```html\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"<%- theme.jsDelivr.url %><%- url_for(theme.libs.css.jqcloud) %>\">\n      <div class=\"container\" style=\"padding-bottom: 20px\" data-aos=\"fade-up\">\n          <div id=\"tag-wordcloud\" class=\"card-content\"></div>\n      </div>\n      \n      <script  type=\"text/javascript\" src=\"<%- theme.jsDelivr.url %><%- url_for(theme.libs.js.jqcloud) %>\"></script>\n      <script  type=\"text/javascript\">\n          <%\n          let tagWordArr = [];\n          site.tags.map(function(tag) {\n              tagWordArr.push({'text': tag.name, 'weight': tag.length, 'link': decodeURI(url_for(tag.path))});\n          });\n      \n          let tagWords = JSON.stringify(tagWordArr);\n          %>\n      \n          $('#tag-wordcloud').jQCloud(<%- tagWords %>, {\n              autoResize: true\n          });\n      </script>\n      ```\n\n   2. 修改后\n\n      ```html\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"<%- theme.jsDelivr.url %><%- url_for(theme.libs.css.jqcloud) %>\">\n      <style type=\"text/css\">\n          #tag-wordcloud {\n              width: 100%;\n              height: 300px;\n          }\n      </style>\n      \n      <div class=\"container\" data-aos=\"fade-up\">\n          <div class=\"card\">\n              <div id=\"tag-wordcloud\" class=\"card-content\"></div>\n          </div>\n      </div>\n      \n      <script type=\"text/javascript\">\n          $.getScript(\"<%- theme.jsDelivr.url %><%- url_for(theme.libs.js.jqcloud) %>\",function () {\n              <%\n              let tagWordArr = [];\n              site.tags.map(function(tag) {\n                  tagWordArr.push({'text': tag.name, 'weight': tag.length, 'link': decodeURI(url_for(tag.path))});\n              });\n      \n              let tagWords = JSON.stringify(tagWordArr);\n              %>\n      \n              $('#tag-wordcloud').jQCloud(<%- tagWords %>, {\n                  autoResize: true\n              });\n          })\n      </script>\n      ```\n\n   3. 修改内容\n\n      > 将未重载的函数利用 `Jquery` 的 `getScript` 方法进行重载\n      >\n      > ```javascript\n      > $.getScript(\"文件引用路径\",function(){\n      >     //重载函数\n      > })\n      > ```\n\n##### 以评论(valine)为例\n\n打开 `valine.ejs`\n\n+ 原主代码\n\n  ```html\n  <script src=\"<%- theme.jsDelivr.url %><%- url_for('/libs/valine/av-min.js') %>\"></script>\n  <script src=\"<%- theme.jsDelivr.url %><%- url_for(theme.libs.js.valine) %>\"></script>\n  <script>\n      let metaPlaceholder = <%-  JSON.stringify(theme.valine.metaPlaceholder) %> ;\n      //这里要换行\n      new Valine({\n   \t\tel: '#vcomments',\n          appId: '<%- theme.valine.appId %>',\n          appKey: '<%- theme.valine.appKey %>',\n          notify: '<%- theme.valine.notify %>' === 'true',\n          verify: '<%- theme.valine.verify %>' === 'true',\n          visitor: '<%- theme.valine.visitor %>' === 'true',\n          avatar: '<%- theme.valine.avatar %>',\n          pageSize: '<%- theme.valine.pageSize %>',\n          lang: '<% if (config.language == \"zh-CN\") { %>zh-cn<% } else { %>en<% } %>',\n          placeholder: '<%= theme.valine.placeholder %>'\n      });\n  </script>\n  ```\n\n+ 修改后代码\n\n  ```html\n  <script>\n  $.getScript(\"<%- theme.jsDelivr.url %><%- url_for('/libs/valine/av-min.js') %>\", function () {\n          $.getScript(\"<%- theme.jsDelivr.url %><%- url_for(theme.libs.js.valine) %>\", function () {\n              new Valine({\n                  el: '#vcomments',\n                  appId: '<%- theme.valine.appId %>',\n                  appKey: '<%- theme.valine.appKey %>',\n                  notify: '<%- theme.valine.notify %>' === 'true',\n                  verify: '<%- theme.valine.verify %>' === 'true',\n                  visitor: '<%- theme.valine.visitor %>' === 'true',\n                  avatar: '<%- theme.valine.avatar %>',\n                  pageSize: '<%- theme.valine.pageSize %>',\n                  lang: '<% if (config.language == \"zh-CN\") { %>zh-cn<% } else { %>en<% } %>',\n                  placeholder: '<%= theme.valine.placeholder %>'\n              });\n  \n          })\n      })\n  </script>\n  ```\n\n  \n\n### 推荐\n\n#### 页面切换加载动画\n\n1. 在 `pjax.ejs` 的 `script`标签中添加以下代码\n\n   ```javascript\n   // 清除时间\n   var timer = null;\n   // 执行进度条\n   function ProgressStart(){\n       // 设置初始进度\n       var progress = 10;\n       // 创建进度条 及 css样式\n       var div = document.createElement('div');\n       div.className = \"pjax_progress\";\n       document.body.prepend(div);\n       // 定义随机数最大值最小值\n       var max=10,mini=3;\n       var result=max-mini;\n       // 清除\n       clearInterval(timer);\n       // 0.5秒内累加进度\n       timer = setInterval(function(){\n           // 随机数\n           var num = parseInt(Math.random()*result);\n           var randomResult = num+mini;\n           // 累加\n           progress+=randomResult\n           $queryAll(\".pjax_progress\")[0].style.width = progress+\"%\";\n           // 当进度达到95%时停止\n           if(progress>95)progress=95\n       },500)\n   }\n   // 加载进度条加载完毕\n   function ProgressFinish(){\n       clearInterval(timer);\n       // 页面加载完毕后进度100% 并在0.7秒后删除\n       var progress = $queryAll(\".pjax_progress\");\n       progress[0].style.width = \"100%\";\n       timer = setTimeout(function () {\n           progress[0].parentNode.removeChild(progress[0])\n       }, 700);\n   }\n   // 开始 PJAX 执行的函数\n   document.addEventListener('pjax:send', function () {\n   \t// 执行进度条\n       ProgressStart()\n   });\n   // PJAX 完成之后执行的函数，可以和上面的重载放在一起\n   document.addEventListener('pjax:complete', function () {\n   \t// 加载进度条加载完毕\n       ProgressFinish()\n   });\n   ```\n\n   \n\n2. 在 `my.css` 中添加以下样式代码\n\n   ```css\n   .pjax_progress{\n       position: fixed;\n       top: 0;\n       left: 0;\n       width: 10%;\n       height: 2px;\n       z-index: 103;\n       background: linear-gradient(130deg, #ff0, red);\n       transition: width .4s ease 0s;\n   }\n   ```\n\n\n\n#### 页面切换加载进度条\n\n1. 在 `pjax.ejs` 的 `script`标签中添加以下代码\n\n   ```javascript\n   // 开始 PJAX 执行的函数\n   document.addEventListener('pjax:send', function () {\n   \t$(\"#loading\").css(\"display\",\"flex\")\n   });\n   // PJAX 完成之后执行的函数，可以和上面的重载放在一起\n   document.addEventListener('pjax:complete', function () {\n   \t$(\"#loading\").css(\"display\",\"none\")\n   });\n   ```\n\n2. 在 `my.css` 中添加以下样式代码\n\n   ```css\n   #loading {\n     position: fixed;\n     top: 0;\n     left: 0;\n     min-height: 100vh;\n     width: 100vw;\n     z-index: 9999;\n     display: none;\n     flex-direction: column;\n     justify-content: center;\n     align-items: center;\n     text-align: center;\n   }\n   #loading .loader {\n     width: 20em;\n     height: 20em;\n     font-size: 10px;\n     position: relative;\n     display: flex;\n     align-items: center;\n     justify-content: center;\n   }\n   #loading .loader .face {\n     position: absolute;\n     border-radius: 50%;\n     border-style: solid;\n     animation: CW 3s linear infinite;\n   }\n   #loading .loader .face:nth-child(1) {\n     width: 100%;\n     height: 100%;\n     color: #ffd700;\n     border-color: currentColor transparent transparent currentColor;\n     border-width: 0.2em 0.2em 0 0;\n     --deg: -45deg;\n     animation-direction: normal;\n   }\n   #loading .loader .face:nth-child(2) {\n     width: 70%;\n     height: 70%;\n     color: #0f0;\n     border-color: currentColor currentColor transparent transparent;\n     border-width: 0.2em 0 0 0.2em;\n     --deg: -135deg;\n     animation-direction: reverse;\n   }\n   #loading .loader .face .circle {\n     position: absolute;\n     width: 50%;\n     height: 0.1em;\n     top: 50%;\n     left: 50%;\n     background-color: transparent;\n     transform: rotate(var(--deg));\n     transform-origin: left;\n   }\n   #loading .loader .face .circle::before {\n     position: absolute;\n     top: -0.5em;\n     right: -0.5em;\n     content: '';\n     width: 1em;\n     height: 1em;\n     background-color: currentColor;\n     border-radius: 50%;\n     box-shadow: 0 0 2em, 0 0 4em, 0 0 6em, 0 0 8em, 0 0 10em, 0 0 0 0.5em rgba(255,255,0,0.1);\n   }\n   ```","tags":["Hexo"],"categories":["经验分享"]},{"title":"JavaScript对象的继承","url":"/posts/JavaScriptInheritanceOfObjects.html","content":"\n# JavaScript 对象的继承\n\n### 原型链继承\n\n基于原型链，即把一个对象的原型设置为另一个对象的实例，那么这个对象实例也就拥有了另一个对象上的属性。\n\n````JavaScript\nfunction Father(){\n  this.nationality = \"中国🇨🇳\"\n}\nFather.prototype.getNational = function(){\n  console.log('中国🇨🇳')\n}\n\nfunction Son(){ }\n\nSon.prototype = new Father()\n\nvar s = new Son()\n\ns.getNational() _//中国🇨🇳_\n_```_\n原型和实例的关系\n```JavaScript\ns instanceof Son _//true_\ns instanceof Father _//true_\n_```_\n子类也可以继续添加其他的方法，但是需要注意，子类添加方法的代码要写在替换原型的代码之后\n```JavaScript\nfunction Father(){\n  this.nationality = \"中国🇨🇳\"\n}\nFather.prototype.getNational = function(){\n  console.log('中国🇨🇳')\n}\n\nfunction Son(){ }\n\nSon.prototype = new Father()\n\n_// 子类添加其他方法_\nSon.prototype.learn = function(){\n  console.log('好好学习天天向上')\n}\n````\n\n### 借用构造函数\n\n使用父类的实例设置为子类的原型，也就意味着父类的属性变成了子类原型上共享的属性了。我们在之前将面向对象时，说过，对象的属性最好定义在构造函数中，需要共享的引用类型的属性再定义在原型上。为了解决这个问题，我们可以在子类的构造函数中调用父类的构造函数，这样父类的属性就会变成子类构造函数上的属性，子类的实例对象也就有了独立的属性：\n\n```JavaScript\nfunction Father() {\n  this.nationality = \"中国🇨🇳\"\n}\n\nfunction Son() {\n  _// 在子类的构造函数中调用父类构造函数_\n  Father.call(this)\n}\n传递参数：\nfunction Father(name) {\n  this.name = name;\n  this.nationality = \"中国🇨🇳\"\n}\n\nfunction Son(name) {\n  // 在子类的构造函数中调用父类构造函数\n  Father.call(this,name)\n}\n```\n\n###  组合继承模式\n\n结合原型链和构造函数，原型链实现对原型属性和方法的基础，构造函数实现实例方法的继承：\n\n```JavaScript\nfunction Father(name) {\n  this.name = name;\n  this.nationality = \"中国🇨🇳\"\n}\n\nFather.prototype.getNational = function () {\n  console.log('中国🇨🇳')\n}\n\nfunction Son(name) {\n  _// 在子类的构造函数中调用父类构造函数_\n  Father.call(this,name)\n}\n\nSon.prototype = new Father()\n\nSon.prototype.constructor = Son;\n```\n\n**这种方法也是推荐的实现继承的方式**\n\n### 寄生式继承\n\n```JavaScript\nfunction createPerson(origin) {\n  var clone = Object(origin)\n  clone.sayHello = function () {\n    console.log('hello')\n  }\n  return clone;\n}\n\nvar person = {\n  name: \"davie\",\n  age: 20\n}\n\nvar p2 = createPerson(person)\np2.sayHello()\n```\n\ncreatePerson 方法返回了一个新的对象，具有 person 的属性，而且还有自己的方法。\n当继承的父对象不是自定义类型和构造函数的情况下，可以采用寄生继承模式。\n\n### 寄生组合式继承\n\n组合继承模式是最常用的模式，但也不是完美的。组合继承会执行两次父类构造函数。一次是在子类构造函数中，一次在创建子类原型的时候。结合寄生模式，可以进一步优化：\n\n```JavaScript\nfunction _inherit(subClass,supClass){\n  var prototype = Object(supClass.prototype)\n  prototype.constructor = subClass\n  subClass.prototype = prototype\n}\n\nfunction Father(name){\n  this.name = name;\n}\nFather.prototype.sayHi = function(){\n  console.log(this.name)\n}\n\nfunction Son(name,age){\n  Father.call(this.name)\n  this.age = age;\n}\n\n_inherit(Son,Father)\n```\n\n这种方法的高效之处体现在只调用了一次父类构造函数。因此避免了在子类的原型上添加不必要的、多余的属性。同时原型链还能保持不变，因此可以正常使用 instanceof 判断类型。\n\n### ES6 中类的继承\n\n在 ES6 中，有了 class(JavaScript 的 class 只是一种语法糖，覆盖在基于构造函数和原型的模式上)，我们就可以使用 extends 来实现类的继承了：\n\n```JavaScript\nclass Father {\n   constructor(name) {\n     this.name = name\n   }\n\n   sayHi() {\n     console.log(this.name)\n   }\n }\n\nclass Son extends Father {\n  constructor(name) {\n    // 在子类中通过super函数调用父类构造函数\n    super(name)\n  }\n\n  learn() {\n    console.log('好好学习天天向上')\n  }\n}\n\nvar s = new Son(\"Davie\")\ns.sayHi()\ns.sayHi()\n```\n\n子类的构造函数可以不写。但是如果要写的话，一定要记得执行 super 函数。super 函数用来调用父类的构造函数。否则会报错：\n\n![error](JavaScriptInheritanceOfObjects/error.jpg)\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"JavaScript闭包","url":"/posts/JavaScriptClosure.html","content":"\n# 闭包\n\n## 什么是闭包\n\n先来说下概念：\n\n> 一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。\n\n##  词法作用域\n\n说到闭包，必须要说下作用域，看下面代码 👇：\n\n```javascript\nfunction init() {\n  var name = \"Davie\"; // name 是一个被 init 创建的局部变量\n  function displayName() {\n    // displayName() 是内部函数，一个闭包\n    alert(name); // 使用了父函数中声明的变量\n  }\n  displayName();\n}\ninit();\n```\n\n`init()` 创建了一个局部变量 `name` 和一个名为 `displayName()` 的函数。`displayName()` 是定义在 `init()` 里的内部函数，并且仅在 `init()` 函数体内可用。`displayName()` 没有自己的局部变量。然而，因为它可以访问到外部函数的变量，所以 `displayName()` 可以使用父函数 `init()` 中声明的变量 `name` 。\n\n运行该代码后发现， `displayName()` 函数内的 `alert()` 语句成功显示出了变量 `name` 的值（该变量在其父函数中声明）。词法（lexical）一词指的是，**词法作用域根据源代码中声明变量的位置来确定该变量在何处可用**。嵌套函数可访问声明于它们外部作用域的变量。\n\n重要的话说三遍：\n\n**词法作用域根据源代码中声明变量的位置来确定该变量在何处可用**\n\n**词法作用域根据源代码中声明变量的位置来确定该变量在何处可用**\n\n**词法作用域根据源代码中声明变量的位置来确定该变量在何处可用**\n\n一定是声明变量的位置，而不是调用的位置。\n\n## 3. 闭包\n\n再来看一段代码：\n\n```javascript\nfunction makeFunc() {\n    var name = \"Davie\";\n    function displayName() {\n        alert(name);\n    }\n    return displayName;\n}\nvar name = \"大卫\"\nvar myFunc = makeFunc();\n\nmyFunc();\n```\n\n代码运行结果是 “Davie”，`displayName`函数形成一个闭包，如果没有`displayName`函数，`makeFunc`函数执行完之后，name 属性就不能再被访问。而由于`displayName`的存在，维持了对`name`的引用，因此，当 `myFunc` 被调用时，变量 `name` 仍然可用。\n​\n\n另一个有趣的代码：\n​\n\n```javascript\nfunction makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\n\nvar add5 = makeAdder(5);\nvar add10 = makeAdder(10);\n\nconsole.log(add5(2));  // 7\nconsole.log(add10(2)); // 12\n```\n\n`makeAdder`函数在执行完毕之后，参数`x`仍然存在，保留在内存中，当在此执行内部的闭包函数时，就可以被内部函数访问到。\n\n##  使用闭包实现模块化\n\n在一些编程语言，比如 Java 中，是支持将方法声明为私有的，即它们只能被同一个类中的其它方法所调用。\n\n而 JavaScript 没有这种原生支持（TypeScript 已经支持），但我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。\n\n下面的示例展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为**模块模式**：\n\n```javascript\nvar Counter = (function() {\n  var _privateCounter = 0;\n  function changeBy(val) {\n    _privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return _privateCounter;\n    }\n  }\n})();\n\nconsole.log(Counter.value()); /* logs 0 */\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); /* logs 2 */\nCounter.decrement();\nconsole.log(Counter.value()); /* logs 1 */\n```\n\n通过立即执行函数创建了一个模块。模块内部的两个变量`privateCounter`和`changeBy`都不能再外部访问到，于是提供了三个函数用于在外部访问。这三个公共函数是共享同一个环境的闭包。多亏 JavaScript 的词法作用域，它们都可以访问 `privateCounter` 变量和 `changeBy` 函数。\n\n把上面的代码稍加改造，变成有名函数，通过执行这个函数得到多个计数器：\n\n```JavaScript\nvar makeCounter = function() {\n  var privateCounter = 0;\n  function changeBy(val) {\n    privateCounter += val;\n  }\n  return {\n    increment: function() {\n      changeBy(1);\n    },\n    decrement: function() {\n      changeBy(-1);\n    },\n    value: function() {\n      return privateCounter;\n    }\n  }\n};\n\nvar Counter1 = makeCounter();\nvar Counter2 = makeCounter();\nconsole.log(Counter1.value()); /* logs 0 */\nCounter1.increment();\nCounter1.increment();\nconsole.log(Counter1.value()); /* logs 2 */\nCounter1.decrement();\nconsole.log(Counter1.value()); /* logs 1 */\nconsole.log(Counter2.value()); /* logs 0 */\n```\n\n两个计数器 `Counter1` 和 `Counter2` 是如何维护它们各自的独立性的。每个闭包都是引用自己词法作用域内的变量 `privateCounter` 。\n\n每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境。然而在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。\n\n> 通过这种方式可以实现很多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。\n\n##  一个常见错误\n\n我们在开发中，经常会遇到一个问题就是通过循环的方式给元素添加事件：\n\n```html\n<p id=\"html\">HTML</p>\n<p id=\"css\">CSS</p>\n<p id=\"js\">JavaScript</p>\n```\n\n需求是给每一个`p`标添加点击事件，当点击`p`标签时，使用`alert`弹出里面的文字内容：\n\n通过 for 循环添加：\n\n```javascript\n var list = document.getElementsByTagName('p')\n\n for(var i = 0;i < list.length;i++){\n   var item = list[i]\n   item.onclick = function(){\n        alert(item.innerText)\n    }\n }\n```\n\n如果这样写的话，执行代码会发现不管点击那个元素，弹出的始终是\"JavaScript\"。\n\n原因是赋值给 onclick 的是闭包。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量 item。变量 item 使用 var 进行声明，由于变量提升，所以具有函数作用域。由于循环在事件触发之前早已执行完毕，变量对象`item`（被三个闭包所共享）的值已经变成了最后一个`p`。\n\n解决这个问题的办法是使用工厂模式：\n\n```javascript\n function showText(item){\n   return function(){\n     alert(item.innerText)\n   }\n }\n\nvar list = document.getElementsByTagName('p')\n\nfor(var i = 0;i < list.length;i++){\n  var item = list[i]\n  item.onclick = showText(item)\n}\n```\n\n所有的回调不再共享同一个环境， showText 函数为每一个回调创建一个新的词法环境。三个闭包中，三个 item 会被单独保存下来。\n\n当然使用匿名函数也可以：\n\n```javascript\nvar list = document.getElementsByTagName('p')\n\n for(var i = 0; i < list.length;i++){\n   (function(){\n     var item = list[i]\n     item.onclick = function(){\n       alert(item.innerText)\n     }\n   })()\n }\n```\n\n当然，使用 ES6 的 let 关键字就单间多了：\n\n```javascript\nfor (var i = 0; i < list.length; i++) {\n  let item = list[i];\n  item.onclick = function () {\n    alert(item.innerText);\n  };\n}\n```\n\n使用 let 定义 item，每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。\n\n另外有一种方法是使用 forEach 函数：\n\n```javascript\n// 使用forEach方法\nnew Array().forEach.call(list, (item) => {\n  item.onclick = function () {\n    alert(item.innerText);\n  };\n});\n```\n\n## 性能问题\n\n闭包虽然有很多好处，然而也要谨慎使用，由于闭包会保存变量，不会立即被垃圾回收机制处理，所以创建过多的闭包可能会造成内存泄漏。\n\n例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。\n\n```javascript\nfunction Person(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n\n  this.getName = function() {\n    return this.name;\n  };\n    \n  this.getMessage = function() {\n    return this.message;\n  };\n}\n```\n\n上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下：\n\n```javascript\nfunction Person(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n}\n\nMyObject.prototype.getName = function() {\n  return this.name;\n};\n\nMyObject.prototype.getMessage = function() {\n  return this.message;\n};\n```\n\n1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n## 总结\n\n闭包能够读取另一个函数作用域的变量的函数。\n\n闭包具有：封闭性、持久性的有点。\n\n同时又由于持久性，处理不当易造成内存泄漏。\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"JavaScript类型隐式转换","url":"/posts/JavaScriptDataTypeTransition.html","content":"\n# JavaScript 数据类型隐式转换\n\n## 面试题\n\n在讲 JavaScript 的数据类型隐式转换前，我们先看道面试题：\n\n```javascript\nconsole.log(new String(\"abc\") == true);\n\nconsole.log({} == true);\n\nconsole.log([] == ![]);\n```\n\n结果是什么呢？\n\n先把结果写下来，放在一边，然后继续看\n\n## 字面量形式、包装器方式，new 方式的区别\n\n创建字符串的三种方式：\n\n```javascript\nvar a = \"Davie\"; //申明的是一个string类型，它是一个基本类型\nvar a = String(\"Davie\"); // String()是一个包装类，用于将参数转换成string类型\nvar a = new String(\"Davie\"); //采用new方式时创建了一个object类型\n```\n\n使用 typeof 验证上面的结论\n\n```javascript\nvar a = \"Davie\";\nconsole.log(typeof a); //string\nconsole.log(typeof String(a)); //string\nconsole.log(typeof new String(a)); //object\n```\n\n## JavaScript 的数据类型\n\nJavaScript 的数据类型之前已经讲过了，忘记的小伙伴出门左转，查看[**搞懂 JavaScript 的数据类型**](#)\n\n## 4. 各种类型隐式转换到布尔类型对照表\n\n| 数据类型  | 转换为 true 的值 | 转换为 false 的值 |\n| --------- | ---------------- | ----------------- |\n| Boolean   | true             | false             |\n| String    | 任何非空字符串   | \"\" 空字符串       |\n| Number    | 任何非零数字     | 0 和 NaN          |\n| Object    | 任何对象         | null              |\n| Undefined | 不适用           | undefined         |\n\n##  `!`转换规则\n\n`!`会将后面的数据先转成布尔值，然后取反。例如：\n\n```\nvar a;\nvar r = !!a;\nconsole.log(r) //false\n\n!!{} // true\n!!undefined // false\n!!nul // false\n!!NaN //fales\n```\n\n## `==`比较\n\n> 比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript 会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。  ---- [引用自 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)\n\n#### 1. 类型相同的情况\n\n- 如果比较的是两个对象，则比较两个对象的指针是否指向同一个对象，例如：\n\n```\nvar a = {}\nvar b = {}\na==b //false\n```\n\n很明显，`a`和`b`在堆内存中是两个对象。二另一种情况：\n\n```\nvar a = {}\nvar b = a;\na==b //true\n```\n\n这时，`a`和`b`就指向了同一个对象，所以相等。\n\n- 其它的基本类型，如果是相同类型，则直接进行严格比较就好，没什么好说的。\n\n#### 2. 类型不同的情况\n\n如果两边类型不同，则两边都**尝试转成 number 类型**。对于引用类型，先调用`valueOf()`,如果能转成数字，则进行比较。不能转成数字就调用`toString()`方法转成字符串。\n\n```javascript\nvar a = \"123\";\nconsole.log(a == false); //false,'123'转成数字是123,右侧转成数字是0,最终比较123==0\nconsole.log(a == 123); //true,右边是数字，把左 边转成数字123\n```\n\n如果有一边是 object 类型：\n\n```javascript\nvar a = new String(123);\nconsole.log(a == 123); //true,a.valueOf()结果就是数字123，最终比较的是123==123\n```\n\n再看一个：\n\n```javascript\nvar a = {} console.log(a == 1)\n//上面a==1在js解释引擎中的执行过程如下:\n// a.valueOf()获取到的不是基本类型，调用a.toString()得到'[object Object]''[object Object]'==1;\n// 两边类型不致，左侧转成数字NaN==1;\n// false,NaN跟任何类型比较都为false\n```\n\n#### 3. null、NaN、undefined\n\nnull、NaN、undefined 和 string、number、boolean、object 类型比较时，都不做隐式转换，比较的结果直接为 false。但是需要注意以下几个规则：\n\n```javascript\nconsole.log(NaN == NaN); //false\nconsole.log(undefined == null); //true\nconsole.log(null == null); //true\nconsole.log(null == undefined); //true\nundefined == undefined; //true\n```\n\n#### 4. 面试题解析\n\n搞清楚规则后，开头的面试题就很容易了：\n\n第一题：\n\n```javascript\n//问题1：\nconsole.log(new String(\"abc\") == true);\n// step1:右侧转成数字1,变成：new String('abc')==1\n// step2 new String('abc').valueOf()不是数字也不是字符串，再调用toString()'[object Object]' == 1\n// step3:字符串转数字NaN == 1\n// false,NaN和任何类型比较都为false\n```\n\n第二题：\n\n```javascript\n//问题2：\nconsole.log({} == true);\n//step1:右侧转成数字{} == 1\n// step2 {}.valueOf()不是数字也不是字符串，再调用toString()'[object Object]' ==1\n// step3:字符串转数字NaN == 1\n// false,NaN和任何类型比较都为false\n```\n\n第三题：\n\n```javascript\n//问题3:\nconsole.log([] == ![]);\n//step1:!优先级比==高，先转右边,[]是对象类型，转成布尔值为true,!true就是false[]==false\n// step2:右侧转成数字为0[]==0\n// step3:左侧是一个对象，valueOf()转出来不是字符也不是字符串，调用toString()，得到空字符串'' == 0\n// step4:字符串转成数字0 == 0 //true\n```\n\n#### 5. 总结\n\n- 类型相同\n  - 基本类型，直接比较值\n  - 引用类型比较指针\n- 类型不同，尝试转成 number 类型，\n  - 先调用`valueOf()`转成`number`\n  - 不行就再用`toString()`方法转成`string`\n- null、NaN、undefined 单独一套规则\n\n##  比较运算符 `>` `<`\n\n来，在来看一道题：\n\n```\nconsole.log('666' < '7')\n```\n\n正确答案是 `true`\n\n这是因为**字符串类型比较大小时，不进行类型转换，而是逐位比较 ascii 码，第 1 位不同则返回结果，否则继续比较第 2 位，直到某一位不同为止**。\n\n在比如使用数组的 sort 方法排序：\n\n```javascript\nvar a = [1, 10, 6, 100].sort();\n```\n\n结果是：\n\n```javascript\n[1, 10, 100, 6];\n```\n\n原因是 sort()方法默认的比较规则会先把每个元素转成字符串，然后比较字符串的 ascii 码来确定先后顺序。\n\n##  加号`+`\n\n`+`运算符即可以对两个数相加，也可以连接字符串，那如果是[1,2,3]+4 这种情况下又会发生什么呢？这就需要我们了解相应的规则，为了方便描述，我们把+号左侧的值叫做 A，右侧的叫做 B：\n第一步：如果 A 和 B 都是 number 类型，直接相加；\n第二步：接下来看 A 或 B 中是否有一个是否为 string 类型，如果有，则将另一个也转成字符串，然后连接；\n第三步：既不是 number,也不是 string,则按如下规则转换：\n\n1.  能转换成数字，返回之\n2.  否则调用 valueOf()，如果执行结果是基本类型，返回之；\n3.  否则调用 toString()，如果执行结果是基础类型，返回之；\n4.  无法得到原始值，抛异常。\n\n## 减号`-`\n\n除了加号外，减号也很神奇。\n\n使用减号在做非数字类型的运算时，也会发生隐式类型转换.来看下面几个例子：\n\n1. true 会转换成 1\n\n```javascript\n5 - true; // 4\n```\n\n2. ''空字符串、null 转成 0\n\n```\n5 - '' //55 - null //5\n```\n\n3. undefined 和非空字符串转成 NaN\n\n```\n5 - undefined // NaN5 - 'a' // NaN\n```\n\n4. 可以转成数字的字符串转成数字\n\n```\n5 - '1'  //4\n```\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"JavaScript数据类型判断","url":"/posts/JavaScriptDataType.html","content":"\n# JavaScript 数据类型判断\n\n## typeof\n\n使用 typeof 判断数据类型\n\n```javascript\nconsole.log(typeof 1); //number\n\nconsole.log(typeof NaN); //number\n\nconsole.log(typeof \"1\"); //string\n\nconsole.log(typeof true); //boolean\n\nlet s = Symbol();\nconsole.log(typeof s); //Symbol\n\nconsole.log(typeof undefined); //undefined\n\nfunction islu() {\n  console.log(\"this is a function!\");\n}\nconsole.log(typeof islu); //function\n\nlet obj = {\n  name: \"闲花手札\",\n};\nconsole.log(typeof obj); //object\n\nconsole.log(typeof null); //object\n\nlet array = [0, 1, 2, 3]; //数组\nconsole.log(typeof array); //object\n```\n\n> 1. 使用 typeof 可以检测大部分的基本类型。但无法检测出来 null，会认为是对象。\n> 2. NaN 也会认为是 number。\n> 3. 可以检测出函数，但是对象数组和对象无法区分。\n\n## instanceof\n\ninstanceof 可以用来判断对象是否是某个类的实例。instanceof 的实现原理出门左转查看**手撕 instanceof**\n\n简单说就是左边对象的原型(通过`.__proto__`访问)是否和右边对象的原型相等（通过`.prototype`访问），如果相等则返回 true。\n\n```javascript\nvar arr = [1, 2, 3];\nvar date = new Date();\nvar fn = function () {\n  alert(123);\n};\nconsole.log(arr instanceof Array);\nconsole.log(date instanceof Date);\nconsole.log(fn instanceof Function);\nconsole.log(Function instanceof Object);\nconsole.log(Object instanceof Function);\n```\n\n再来看另外一种情况:\n\n在 a.html 中定义了数组 a:\n\n```html\n// a.html\n<script>\n  var a = [1, 2, 3];\n</script>\n```\n\n然后通过 iframe 引入 main.html 页面：\n\n```html\n// main.html\n<iframe src=\"a.html\"></iframe>\n\n<script>\n  var frame = window.frames[0];\n  var a = frame.a;\n  console.log(a instanceof Array); // false\n  console.log(a.constructor === Array); //false\n  console.log(a instanceof frame.Array); // true\n</script>\n```\n\n在 main.html 页面通过 iframe 获取到 a 页面的数组检测，发现 a 不是 Array 的实例对象，这是什么原因呢？\n\n其实 iframe 之间不会共享原型链, 因为他们有独立的执行环境, 所以 frame a 中的数组 a 不会是本执行环境的实例对象.\n\n## constructor\n\n使用构造函数判断类型：\n\n```javascript\nvar bool = true;\nvar num = 123;\nvar str = \"Davie\";\nvar arr = [1, 2, 3];\nvar obj = { name: \"Davie\" };\nvar fun = function () {};\nvar sy = Symbol(\"Davie\");\n\nfunction Person() {}\nfunction Student() {\n  Person.call(this);\n}\nvar stu = new Student();\n\nconsole.log(bool.constructor === Boolean); // true\n\nconsole.log(num.constructor === Number); // true\n\nconsole.log(str.constructor === String); // true\n\nconsole.log(arr.constructor === Array); // true\n\nconsole.log(obj.constructor === Object); // true\n\nconsole.log(fun.constructor === Function); // true\n\nconsole.log(sy.constructor === Symbol); // true\n\nconsole.log(stu.constructor === Student); // true\n\nconsole.log(stu.constructor === Person); // false\n```\n\n- undefined 和 null 没有 contructor 属性,所以 constructor 不能判断 undefined 和 null\n- 使用 constructor 判断类型是不安全的，因为 contructor 的指向是可以改变的\n\n```javascript\narr.constructor = Object;\nconsole.log(arr.constructor === Object); // true\n```\n\n## 特性嗅探\n\n或者一些特有的方法，比如数组特有的 sort，slice 等：\n\n```javascript\nconsole.log(typeof arr.sort === \"function\");\n```\n\n但是这种方式也不是特别牢靠，因为很难保证其他对象里面没有这些方法。\n\n## 万能方法\n\n在任何值上调用 Object 原生的 toString() 方法，都会返回一个 [object NativeConstructorName] 格式的字符串。\n**需要注意的是，它不能检测非原生构造函数的构造函数名。**\n\n```javascript\nfunction foo() {}\nvar div = document.createElement(\"div\");\n\nObject.prototype.toString.call(1);\n(\"[object Number]\");\n\nObject.prototype.toString.call(NaN);\n(\"[object Number]\");\n\nObject.prototype.toString.call(\"1\");\n(\"[object String]\");\n\nObject.prototype.toString.call(true);\n(\"[object Boolean]\");\n\nObject.prototype.toString.call(undefined);\n(\"[object Undefined]\");\n\nObject.prototype.toString.call(null);\n(\"[object Null]\");\n\nObject.prototype.toString.call(Symbol());\n(\"[object Symbol]\");\n\nObject.prototype.toString.call(foo);\n(\"[object Function]\");\n\nObject.prototype.toString.call([1, 2, 3]);\n(\"[object Array]\");\n\nObject.prototype.toString.call({});\n(\"[object Object]\");\n\nObject.prototype.toString.call(/\\d+/);\n(\"[object RegExp]\");\n\nObject.prototype.toString.call(div);\n(\"[object HTMLDivElement]\");\n\nObject.prototype.toString.call(\n  (function () {\n    return arguments;\n  })()\n);\n(\"[object Arguments]\");\n\nObject.prototype.toString.call(new Error()); // => \"[object Error]\"\n\nObject.prototype.toString.call(new Date()); // => \"[object Date]\"\n```\n\n从上面的例子可以看到，Object.prototype.toString 方法能有效弥补 typeof 不能很好区分**数组**、**对象**和**函数**的短板。\n\n每个类在内部都有一个 [[Class]] 属性，这个属性中就指定了上述字符串中的构造函数名。\n\nObject.prototype.toString 的原理是当调用的时候, 就取值内部的 [[Class]] 属性值, 然后拼接成 '[object ' + [[Class]] + ']' 这样的字符串并返回. 然后我们使用 call 方法来获取任何值的数据类型。\n\n## 检测函数\n\n**Array.isArray()**\n\n用于确定传递的值是否是一个 Array。如果对象是 Array，则返回 true，否则为 false。\n\n```javascript\nArray.isArray([1, 2, 3]);\n```\n\n**判断是否是 DOM 元素**\n\n在实际项目里面, 有时或许我们需要判断是否是 DOM 元素对象, 那么在判断的时候利用的是 DOM 对象特有的 nodeType 属性:\n\n```javascript\nisElement: function(obj){  return !!(obj && obj.nodeType === 1);}\n```\n\n**判断是否是对象**\n\n```javascript\nisObject: function(obj){  var type = typeof obj;  return type === 'function' || typeof === 'object' && obj !== null;}\n```\n\n这里的对象是狭义的, 是通常所指的 key-value 型的集合, 或者是 function 函数并且不为 null.\n\n**判断是否是 arguments 对象**\n\n判断一个对象是不是 arguments 对象可以通过 Object.prototype.toString 来判断, 但是低版本的浏览器不支持, 他们返回的是 [object Object], 所以需要兼容:\n\n```javascript\nisArguments: function(obj){  return Object.prototype.toString.call(obj) === '[object Arguments]' || (obj != null && Object.hasOwnProperty.call(obj, 'callee'));}\n```\n\n兼容做法原理是通过对象的 hasOwnProperty 方法来判断对象是否拥有 callee 属性从而判断是不是 arguments 对象.\n\n**isNaN()和 Number.isNaN**\n\nisNaN 函数可以检测某个值是否是 NaN：\n\n```javascript\nisNaN(NaN); // true\n```\n\n但是：\n\n```javascript\nisNaN(undefined); // trueisNaN({}); // trueisNaN([]); // false\n```\n\n只要传入的参数不是数字，都会返回 true,但是数组会返回 false，所以任然无法很好进行区分。\n\nES6 为了修正这个 BUG，引入了 Number.isNaN()\n\n```javascript\nNumber.isNaN(NaN); // true\n\nNumber.isNaN(\"A String\"); // false\n\nNumber.isNaN(undefined); // false\n\nNumber.isNaN({}); // false\n\nNumber.isNaN(1); // false\n\nNumber.isNaN([]); // false\n```\n\n没有 ES6 的情况下，可以采用以下 polyfill\n\n```javascript\nif (!Number.isNaN) {\n  Number.isNaN = function (n) {\n    return typeof n === \"number\" && window.isNaN(n);\n  };\n}\n```\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"windows右键新建.md文件","url":"/posts/WindowsNewAddMD.html","content":"\n# windows 下右键新建.md 文件\n\n原本创建.md 文件需要首先打开 markdown 文本编辑器，如 Typora，或者新建.txt 文件然后修改后缀名，本文介绍了如何在 Windows 操作系统中添加右键创建.md 文件的方法\n\n## 效果\n\n![result](WindowsNewAddMD/result.png)\n\n## 步骤\n\n### 打开注册表\n\n1. `CMD+R`，打开运行对话框\n2. 输入`regedit`，打开注册表编辑器\n\n### 修改注册表\n\n1.  在`计算机>HKEY_CLASSES_ROOT`右键查找，输入`Typora`，勾选项，取消勾选值和数据\n    ![ModifyingRegistry](WindowsNewAddMD/ModifyingRegistry.png)\n2.  确认运行的程序名字，我的电脑如图所示，运行文件是`Typora.exe`\n    ![operation_typora](WindowsNewAddMD/operation_typora.png)\n\n    > 如果使用的是 markdownpad 或者其他编辑器，同理\n\n3.  在磁盘任意位置新建一个文件，后缀为`.reg`\n4.  打开编辑刚刚创建好的注册表文件，写入以下内容：\n\n```reg\nWindows Registry Editor Version 5.00\n[HKEY_CLASSES_ROOT\\.md]\n@=\"Typora.exe\"\n[HKEY_CLASSES_ROOT\\.md\\ShellNew]\n\"NullFile\"=\"\"\n[HKEY_CLASSES_ROOT\\Typora.exe]\n@=\"Markdown\"\n```\n\n> `@=\"Typora.exe\"` 代表的是指定.md 文件的运行程序\n>\n> `@=\"Markdown\"` 代表的是右键时默认的文件名字，这样写新建为`新建`Markdown.md`文件`\n>\n> 且右键菜单中显示`MarkDown`\n\n5.  编辑好之后,另存为,设置如图所示\n    ![reg_to_txt](WindowsNewAddMD/reg_to_txt.png)\n    \n    > 文件名可以随便设置，但是后缀必须是`.reg`文件,保存类型一定要是`文本文档(*.txt)`\n\n## 编辑新建图标(可选)\n\n1.  以`Typora`为例,在注册表`Typora.exe`下点击项`DefaultIcon`,右键修改\n2.  将属性修改为想要设置的 `Markdown`文件图标\n    ![choose_new_ico](WindowsNewAddMD/choose_new_ico.png)\n","tags":["Markdown","Windows"],"categories":["经验分享"]},{"title":"Matery添加暗色模式","url":"/posts/MateryAddDark.html","content":"\n## 制作深色模式按钮\n\n### 添加按钮\n\n在主题的`layout.ejs`文件中找到 body 标签的开始标签在后面加上这些 js 和 html 代码，这里我放的位置为：`/layout/_partial/back-top.ejs`\n\n```html\n<!-- 回到顶部按钮 -->\n<div id=\"backTop\" class=\"top-scroll\">\n    <a class=\"btn-floating btn-large waves-effect waves-light\" href=\"#!\">\n        <i class=\"fas fa-arrow-up\"></i>\n    </a>\n</div>\n```\n\n改为\n\n```html\n<!-- 回到顶部按钮 -->\n<div id=\"backTop\" class=\"top-scroll\">\n    <a class=\"btn-floating btn-large waves-effect waves-light\" href=\"#!\">\n        <i class=\"fas fa-arrow-up\"></i>\n    </a>\n</div>\n<a onclick=\"switchNightMode()\" id=\"sma\" title=\"模式切换\">\n    <i class=\"fa fa-moon-o\" id=\"nightMode\" aria-hidden=\"true\"></i>\n</a>\n```\n\n### 按钮的 css 样式\n\n```css\n/* 深色模式按钮设置 */\n#sma {\n  background: #000;\n  width: 38px;\n  height: 38px;\n  display: block;\n  position: fixed;\n  border-radius: 50%;\n  right: 15px;\n  bottom: 170px;\n  padding-top: 15px;\n  margin-bottom: 0;\n  z-index: 998;\n  cursor: pointer;\n}\n\n#sma .fa-moon-o {\n  position: absolute;\n  right: 8px;\n  bottom: 8px;\n  font-size: 1.48rem !important;\n}\n#sma .fa-lightbulb-o {\n  position: absolute;\n  right: 13px;\n  bottom: 8px;\n  font-size: 1.5rem !important;\n}\n\n.fa-moon-o:before {\n  content: \"\\f186\";\n}\n.fa-comments:before {\n  content: \"\\f086\";\n}\n```\n\n### 按钮的 js 代码\n\n放在独立的 js 文件里即可，这里我放在`/souce/js/matery.js`里面\n\n```javascript\n/* 深色模式按钮设置 */\nif (localStorage.getItem(\"dark\") === \"1\") {\n  document.body.classList.add(\"dark\");\n} else {\n  /*定时开启暗色模式<默认晚22点至早6点默认开启>*/\n  if (new Date().getHours() >= 22 || new Date().getHours() < 6) {\n    document.body.classList.add(\"dark\");\n    $(\"#nightMode\").removeClass(\"fa-moon-o\").addClass(\"fa-lightbulb\");\n  } else {\n    if (matchMedia(\"(prefers-color-scheme: dark)\").matches) {\n      document.body.classList.add(\"dark\");\n    }\n  }\n}\n\n/*提醒开启功能*/\nsetTimeout(function () {\n  if (\n    (new Date().getHours() >= 19 || new Date().getHours() < 7) &&\n    !$(\"body\").hasClass(\"DarkMode\")\n  ) {\n    let toastHTML =\n      '<span style=\"color:#97b8b2;border-radius: 10px;>' +\n      '<i class=\"fa fa-bell\" aria-hidden=\"true\"></i>晚上使用深色模式阅读更好哦。(ﾟ▽ﾟ)/</span>';\n    M.toast({ html: toastHTML });\n  }\n}, 2200);\n\n/* 深色模式设置*/\nfunction switchNightMode() {\n  var body = document.body;\n  if (body.classList.contains(\"dark\")) {\n    document.body.classList.remove(\"dark\");\n    localStorage.setItem(\"dark\", \"0\");\n    $(\"#nightMode\").removeClass(\"fa-lightbulb\").addClass(\"fa-moon-o\");\n    return;\n  } else {\n    document.body.classList.add(\"dark\");\n    localStorage.setItem(\"dark\", \"1\");\n    $(\"#nightMode\").removeClass(\"fa-moon-o\").addClass(\"fa-lightbulb\");\n    return;\n  }\n}\n```\n\n## 引入 CSS 暗色文件\n\n创建 css 文件并引入\n\n```css\n/*暗色模式按钮样式*/\n#sma {\n  box-shadow: #aaa 2px 5px 10px;\n  background: #000;\n  width: 38px;\n  height: 38px;\n  display: block;\n  position: fixed;\n  border-radius: 50%;\n  right: 15px;\n  bottom: 100px;\n  padding-top: 15px;\n  margin-bottom: 0;\n  z-index: 998;\n  cursor: pointer;\n}\n\n#sma .fa-moon-o {\n  position: absolute;\n  right: 8px;\n  bottom: 8px;\n  font-size: 1.48rem !important;\n}\n\n#sma .fa-lightbulb {\n  position: absolute;\n  right: 11px;\n  bottom: 8px;\n  font-size: 1.5rem !important;\n}\n\n.fa-moon-o:before {\n  content: \"\\f186\";\n}\n\n.fa-comments:before {\n  content: \"\\f086\";\n}\n/* 背景颜色变灰色 */\n.dark tbody,\nbody.dark #artDetail .post-info .post-date,\nbody.dark #info_user_pool .moments_chart,\nbody.dark .bg-cover .post-title,\nbody.dark .biaotis span,\nbody.dark .card .card-content p,\nbody.dark .card .card-image .card-title,\nbody.dark .card .toc-title,\nbody.dark .card-content .categories-title,\nbody.dark .card-content .de,\nbody.dark .category-content a,\nbody.dark .chip-container .tag-title,\nbody.dark .fa-lightbulb:before,\nbody.dark .fa-moon-o:before,\nbody.dark .fab,\nbody.dark .fas,\nbody.dark .friends-container .tag-title,\nbody.dark .frind-ship .title h1,\nbody.dark .moments-item-info .moments-item-time,\nbody.dark .moments_load_button,\nbody.dark .notice,\nbody.dark .panel-info,\nbody.dark .post-info .info-break-policy,\nbody.dark .publish-info .post-category,\nbody.dark .publish-info .publish-date,\nbody.dark .row .text,\nbody.dark .statis .name,\nbody.dark .supervise_details,\nbody.dark .title,\nbody.dark .v[data-class=\"v\"] .vcount,\nbody.dark .v[data-class=\"v\"] .vcount .vnum,\nbody.dark .valine-card .comment_headling,\nbody.dark a body.dark table,\nbody.dark article .article-content .summary,\nbody.dark article .article-tags .chip,\nbody.dark div.jqcloud a,\nbody.dark footer .copy-right,\nbody.dark footer a,\nbody.dark h1,\nbody.dark h2,\nbody.dark h3,\nbody.dark h4,\nbody.dark h5,\nbody.dark h6,\nbody.dark header .side-nav .menu-list a,\nbody.dark header .side-nav .mobile-head .logo-desc,\nbody.dark header .side-nav .mobile-head .logo-name,\nbody.dark li,\nbody.dark p,\nbody.dark pre code {\n  color: rgba(255, 255, 255, 0.85); /*.85为透明度，可依据需求修改*/\n}\n/* 背景颜色变黑色 */\nbody.dark,\nbody.dark #rewardModal .modal-content,\nbody.dark .archive-container,\nbody.dark .modal,\nbody.dark .v[data-class=\"v\"] .vcount,\nbody.dark header .side-nav,\nbody.dark header .side-nav .menu-list .m-nav-show {\n  background-color: #12121c;\n}\n/*首页文章滑动卡片文字*/\nbody.dark #thisTime,\nbody.dark .card-image-V .box-content .title {\n  color: #8a2be2;\n}\n/*音乐播放器*/\nbody.dark .aplayer {\n  background: #2f3742 !important;\n}\n/*图片滤镜*/\nbody.dark img,\nbody.dark strong {\n  filter: brightness(0.7);\n}\n/*统计图表暗色样式*/\nbody.dark #categories-chart,\nbody.dark #category-radar,\nbody.dark #post-calendar,\nbody.dark #posts-chart,\nbody.dark #tags-chart {\n  filter: invert(1);\n}\n\n/*toc目录滤镜*/\nbody.dark .skillbar .skill-bar-percent {\n  color: #000;\n}\n\n/*加载动画（吃豆豆）文字颜色*/\nbody.dark .loading-text {\n  color: #000;\n}\n/*一些细节背景*/\nbody.dark .block-with-text:after,\nbody.dark .card,\nbody.dark .collapsible-header,\nbody.dark .wxgzh,\nbody.dark table tr:nth-child(2n),\nbody.dark thead {\n  background-color: #282c34;\n}\n\n/*about页面细节*/\nbody.dark .profile .author .title {\n  color: #faebd7;\n}\nbody.dark .my-projects .info .info-title a {\n  color: tomato;\n}\n\n/*外挂标签*/\n.swbk .label {\n  color: currentColor;\n}\n```\n\n## 如何修改部分细节冲突\n\n此暗黑模式原理为在 `<body>` 标签添加 `class=\"dark\"`\n\n添加暗色模式时可依据 `body.dark 类名` 用 CSS 选择器来给含有`dark` 的 `<body>` 下的类添加属性\n\n```css\n/*给暗黑模式下的.test添加字体颜色变红样式*/\nbody.dark .test {\n  color: red;\n}\n```\n\n如若冲突可考虑 `!important` 来添加\"权重\"\n\n```css\nbody.dark .test {\n  color: red !important;\n}\n```\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"PowerShell运行hexo命令","url":"/posts/WindowsPowerShellOperationHexo.html","content":"\n# Windows PowerShell 运行 hexo 命令\n\n## 前言\n\n一个月前更新了 Windows11，在桌面右键可以直接开启 `Windows PowerShell` 便在安装 `git` 时没有选择在右键快捷打开的配置，便有了这篇水文\n\n在新系统上装了 hexo 环境，可打开系统默认的 `Windows PowerShell` 运行命令却无法识别，以为是系统环境变量没设置好。可在 `Git bash` 和 `CMD` 终端却可以执行，再仔细看 `Windows PowerShell` 中的提示，原来是提示的无法加载文件，因此在此系统上禁止运行脚本。\n\n## 错误示例\n\n安装好 `npm` 和 `hexo` 后，在 `Windows PowerShell` 终端运行 `npm version` 没问题，运行 `hexo version` 则提示如下：\n\n```powershell\nhexo : 无法加载文件 C:\\Users\\username\\AppData\\Roaming\\npm\\hexo.ps1`，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 `about_Execution_Policies`。\n所在位置 行:1 字符: 1\n```\n\n> 此时，在 `CMD` 中执行以上命令都没问题，所以不是系统环境变量的问题。\n\n## 解决方案\n\n用管理员权限打开 `Windows PowerShell`  ，运行以下命令：\n\n```powershell\nSet-ExecutionPolicy -ExecutionPolicy UNRESTRICTED\n```\n\n在提示中输入 `Y` 即可(安全警示，如果不输入同意还是无法解决问题)\n\n> 随后便可直接右键选择 `Windows PowerShell` 运行 hexo 命令了 ( : 记得要用 `cd` 跳转到你的文件夹目录哦~\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Maven课堂笔记","url":"/posts/Maven.html","content":"\n## Maven\n\n### 概述\n\n#### 简介\n\nApache Maven 是一个软件项目管理和依赖管理工具。基于项目对象模型 (POM：Project Object Model) 的概念，Maven 可以从一个中心信息块管理项目的构建、报告和文档。\n\n无论是小型的开源类库项目，还是大型的企业级应用;无论是传统的瀑布式开发，还是流行的敏捷开发，Maven 都能大显身手。\n\n> 官方网址\n\n```http\nhttps://maven.apache.org/\n```\n\n#### 核心功能【重点】\n\n> 1. 依赖管理（依赖管理指的就是使用 Maven 来管理项目中使用到的 jar 包，Maven 管理的方式就是“自动下载项目所需要的 jar 包，统一管理 jar 包之间的依赖关系)\n> 2. 项目构建（清理、编译、单元测试、打包、安装、部署、运行）\n> 3. 约定大于配置，解决不同的 ide 文件目录不一致的问题\n\n### Maven 环境配置\n\n#### 下载 Maven\n\n```http\nhttps://maven.apache.org/download.cgi\n```\n\n![apache-maven_download](Maven/apache-maven_download.png)\n\n#### Maven 库目录\n\n> 【注意】不要在中文路径下解压\n\n| 目录                                | 描述                                   |\n| ----------------------------------- | -------------------------------------- |\n| bin                                 | 包含 mvn 的一些可执行程序              |\n| boot                                | 包含 plexus-classworlds 类加载器的框架 |\n| config                              | 包含 settings.xml 在内的配置文件       |\n| lib                                 | Maven 运行时所需要的 Java 类库         |\n| LICENSE.txt、NOTICE.txt、README.txt | 简要介绍                               |\n\n#### 配置 Maven 环境变量\n\n1、此电脑[右键] --> 属性\n\n![computer_nature](Maven/computer_nature.png)\n\n2、选择高级系统设置\n\n![computer_AdvancedSystemSettings](Maven/computer_AdvancedSystemSettings.png)\n\n3、选择高级下面的环境变量\n\n![computer_environmentVariable](Maven/computer_environmentVariable.png)\n\n4、找到系统变量下的 Path\n\n![computer_Path](Maven/computer_Path.png)\n\n5、将 Maven 的 bin 目录添加到环境变量中，点击确定\n\n![computer_Bin](Maven/computer_Bin.png)\n\n6、一路确定即可\n\n#### 配置 Maven 仓库\n\nMaven 使用仓库管理各种 jar 包和插件。\n\nMaven 仓库分为：本地仓库（local）、远程仓库（remote）两大类\n\n##### 本地仓库\n\n> 本地电脑中的仓库。默认位置为：\n>\n> 【注意】一般需要修改此位置为非 C 盘\n\n```\n${user:home}/.m2/repository\n```\n\n##### 远程仓库\n\n远程仓库又包括：中央仓库 + 私服 + 其它公共远程仓库 （比如阿里、163 等）\n\n###### 中央仓库\n\n中央仓库是 maven 自带的远程仓库，默认地址：https://repo.maven.apache.org/maven2，由于默认中央仓库的服务器在国外，下载会比较慢，一般需要配置使用国内的公共远程仓库作为中央仓库镜像。注意配置了中央仓库镜像就不再走默认中央仓库。。\n\n###### 私服\n\n私服是架设在本机或者局域网中的一种特殊的远程仓库，通过私服可以方便的管理其它所有的外部远程仓库。\n\n- 节省自己的外网带宽\n- 加速 maven 构建\n- 部署第三方控件\n- 提高稳定性\n- 降低中央仓库的负荷\n\n##### 修改配置\n\n在 maven 的 conf 目录中找到 settings.xml 文件\n\n```xml\n<!--第一个位置在根节点settings下添加本地仓库位置-->\n<localRepository>F:/m2/repository</localRepository>\n\n<!--第二个位置，在mirrors节点下添加 中央仓库镜像-->\n<mirror>\n\t<id>alimaven</id>\n\t<name>aliyun maven</name>\n    <url>https://maven.aliyun.com/nexus/content/groups/public/</url>\n\t<mirrorOf>central</mirrorOf>\n</mirror>\n\n<!--第三个位置，在 profiles 节点下添加 jdk 版本全局配置，因为默认为1.5-->\n<profile>\n    <id>jdk-1.8</id>\n    <activation>\n    \t<activeByDefault>true</activeByDefault>\n    \t<jdk>1.8</jdk>\n    </activation>\n    <properties>\n   \t\t<maven.compiler.source>1.8</maven.compiler.source>\n    \t<maven.compiler.target>1.8</maven.compiler.target>\n    \t<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>\n    </properties>\n</profile>\n```\n\n检索顺序：先检索本地仓库 --> 再检索远程公共仓库 --> 最后检索中央仓库\n\n![maven_pomPush](Maven/maven_pomPush.png)\n\n### Maven 入门\n\n#### Maven 程序目录结构\n\n> 约定大于配置：能使用约定好的方式，就不要配置。\n\n##### 手动创建目录结构：\n\n```\nmaven_project_name\n\t--src\n\t\t--main\n\t\t\t--java\n\t\t\t\t--com\n\t\t\t\t\t--fc\n\t\t\t\t\t\tHello.java\n\t\t\t--resources\n\t\t\t--webapp\n\t\t\t\t--WEB-INF\n\t\t\t\t\t--web.xml\n\t\t--test\n\t--pom.xml\n```\n\n目录说明\n\n| 参数               | 描述                   |\n| ------------------ | ---------------------- |\n| maven_project_name | maven 项目名           |\n| src                | java 源文件目录        |\n| main               | 项目主体目录           |\n| java               | 源代码目录             |\n| resources          | 资源目录               |\n| webapp             | web 项目目录           |\n| test               | 项目测试目录           |\n| pom.xml            | maven 项目核心配置文件 |\n\npom.xml 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"https://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"https://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <!--组织id：公司名-->\n    <groupId>com.fc</groupId>\n    <!--项目名或者模块名-->\n    <artifactId>testmaven</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <!--打包形式 jar包-->\n    <packaging>jar</packaging>\n    <!--依赖-->\n    <dependencies>\n        <!--junit单元测试-->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n\n</project>\n```\n\n##### 使用命令创建（了解）\n\n```\nmvn archetype:generate -DgroupId=com.qf.maven -DartifactId=maven02 -DinteractiveMode=false -DarchetypeCatalog=internal\n```\n\n#### Maven 常见命令\n\nMaven 的另一个核心功能是项目构建。\n\n构建包括：清理、编译、测试、打包、安装、部署、运行等。这些过程都可以使用 Maven 命令来完成。\n\n每个 maven 命令都可以通过对应的插件来完成。\n\n##### clean\n\n```cmd\n// 清理（删除）编译的文件\nmvn clean\n```\n\n> 使用插件\n\n```\nmaven-clean-plugin:2.5:clean\n```\n\n##### compile\n\n```cmd\n// 编译主目录的文件\nmvn compile\n```\n\n> 使用插件\n\n```\nmaven-resources-plugin:2.6:resources\nmaven-compiler-plugin:3.1:compile\n```\n\n##### test\n\n```cmd\n// 编译并运行test目录的代码\nmvn test\n```\n\n> 使用插件\n\n```\nmaven-resources-plugin:2.6:resources\nmaven-compiler-plugin:3.1:compile\nmaven-resources-plugin:2.6:testResources\nmaven-compiler-plugin:3.1:testCompile\nmaven-surefire-plugin:2.12.4:test\n```\n\n##### package\n\n```cmd\n// 打包项目,jar包或war包\nmvn package\n```\n\n> 使用插件\n\n```\nmaven-resources-plugin:2.6:resources\nmaven-compiler-plugin:3.1:compile\nmaven-resources-plugin:2.6:testResources\nmaven-compiler-plugin:3.1:testCompile\nmaven-surefire-plugin:2.12.4:test\nmaven-jar-plugin:2.4:jar\n```\n\n##### install\n\n```cmd\n// 安装到仓库\nmvn install\n```\n\n> 使用插件\n\n```\nmaven-resources-plugin:2.6:resources\nmaven-compiler-plugin:3.1:compile\nmaven-resources-plugin:2.6:testResources\nmaven-compiler-plugin:3.1:testCompile\nmaven-surefire-plugin:2.12.4:test\nmaven-jar-plugin:2.4:jar\nmaven-install-plugin:2.4:install\n```\n\n##### 其他命令\n\n```cmd\n// 部署，部署到私服\nmvn deploy\n\n// 运行\nmvn tomcat:run\n```\n\n#### Maven 构建生命周期\n\n```\n1. Clean：项目构建前的清理操作\n2. Default（Build）：核心生命周期核心过程：编译，测试，运行，打包等等\n3. Site：项目站点文档创建。\n```\n\n#### Maven POM 文件\n\n> POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元。pom.xml 是 Maven 的核心配置文件，包含了项目的基本信息，用于描述项目如何构建，声明项目的 jar 包依赖等等。\n>\n> 每一个项目都有一个 POM 文件。POM 文件即 pom.xml，应该放在项目的根目录下。一个项目如果分为多个子项目，一般来讲，父项目有一个 POM 文件，每一个子项目都有一个 POM 文件。在这种结构下，既可以一步构建整个项目，也可以各个子项目分开构建。\n>\n> 执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n>\n> POM 中可以指定以下配置：\n>\n> - 项目依赖\n> - 插件\n> - 执行目标\n> - 项目构建 profile\n> - 项目版本\n> - 项目开发者列表\n> - 相关邮件列表信息\n\n基本的 pom.xml 配置文件\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"https://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"https://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <!--组织id：公司名-->\n    <groupId>com.fc</groupId>\n    <!--项目名或者模块名-->\n    <artifactId>testmaven</artifactId>\n    <!--版本号-->\n    <version>1.0-SNAPSHOT</version>\n    <!--打包形式 jar包-->\n    <packaging>jar</packaging>\n\n</project>\n```\n\n> 【注意】所有 POM 文件都需要 project 元素和三个必需的标签：groupId，artifactId，version。这个必须元素叫做坐标（GAV）\n\n#### Maven 引入外部依赖\n\n> Maven 仓库\n\n```http\nhttps://mvnrepository.com/\n```\n\n引入多个依赖只需在 dependencies 标签下声明对应的 dependency 标签即可\n\n```xml\n<!--依赖-->\n<dependencies>\n    <!--junit单元测试-->\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n> 【注意】Scope 依赖范围：\n>\n> - compile（编译范围） compile 是默认的范围，会被打包。\n> - provided（已提供范围） provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用。它们不是传递性的，也不会被打包。\n> - runtime（运行时范围） runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。\n> - test（测试范围）只有在测试编译和测试运行阶段可用。\n> - system（系统范围）必须显式的提供一个对于本地系统中 JAR 文件的路径。注意该范围是不推荐使用。\n\n### 使用开发工具创建 Maven 项目\n\n#### Eclipse 配置 Maven（了解）\n\n1.  安装插件\n    Eclipse 使用 Maven 的前提要安装 m2e 插件，目前 Eclipse 已集成，不需要安装。\n2.  配置 Maven\n    1、进入首选项\n    ![preferences](Maven/preferences.png)\n    2、添加 Maven 仓库\n    ![add_maven](Maven/add_maven.png)\n    3、配置 Maven\n    ![set_maven](Maven/set_maven.png)\n    4、配置 xml 文件\n    ![set_xml](Maven/set_xml.png)\n3.  Eclipse 创建 Maven 工程\n    ![create_maven](Maven/create_maven.png)\n    ![create_set_maven](Maven/create_set_maven.png)\n\n#### Idea 配置 Maven\n\n1.  安装插件\n    Idea 自带 Maven 插件，不需要安装\n2.  配置 Maven\n    ![setting_maven](Maven/setting_maven.png)\n    ![setting_maven_repo](Maven/setting_maven_repo.png)\n    ![down_doc](Maven/down_doc.png)\n3.  Idea 创建 Maven 工程\n    1、创建项目\n    ![create_project](Maven/create_project.png)\n    2、选择 Maven\n    ![choose_maven](Maven/choose_maven.png)\n    3、声明项目名\n    ![setting_project_name](Maven/setting_project_name.png)\n    4、选择项目的存放路径\n    ![setting_path](Maven/setting_path.png)\n    \n    > 【注意】这里不要使用骨架！\n\n### 在 Maven 项目中使用 Web 组件\n\n1、选中 main\n\n![choose_main](Maven/choose_main.png)\n\n2、点击打开文件下的项目架构\n\n![project_structure](Maven/project_structure.png)\n\n3、选择模板，添加 Web 组件\n\n![add_web](Maven/add_web.png)\n\n4、修改部署路径\n\n![update_path](Maven/update_path.png)\n\n5、注意此路径为 web.xml 的存放路径\n\n![notice_web_path](Maven/notice_web_path.png)\n\n6、将 web.xml 的路径放在项目下的 src 下的 main 下的 webapp 下的 WEB-INF 下即可\n\n![update_web_path](Maven/update_web_path.png)\n\n7、点击编辑 Web 资源路径\n\n![edit_web_path](Maven/edit_web_path.png)\n\n8、选择目录\n\n![choose_modules](Maven/choose_modules.png)\n\n9、选择 main 下面的 webapp 目录\n\n![choose_main_modules](Maven/choose_main_modules.png)\n\n10、点击 OK\n\n![choose_ok](Maven/choose_ok.png)\n\n11、打开 pom.xml 文件并添加打包方式为 war\n\n![add_package_war](Maven/add_package_war.png)\n\n```xml\n<packaging>war</packaging>\n```\n\n12、添加 Servlet-api 的 jar 包依赖\n\n![add_servlet-api_jar](Maven/add_servlet-api_jar.png)\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.1.0</version>\n        <!--声明此jar包的作用域为编译期-->\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\n```\n\n> 【注意】必须声明作用域，否则会报错！\n\n13、添加 Tomcat 插件\n\n![add_tomcat](Maven/add_tomcat.png)\n\n```xml\n<build>\n    <!--添加插件-->\n    <plugins>\n        <!--添加Tomcat插件-->\n        <plugin>\n            <groupId>org.apache.tomcat.maven</groupId>\n            <artifactId>tomcat7-maven-plugin</artifactId>\n            <version>2.2</version>\n            <!--Tomcat相关配置-->\n            <configuration>\n                <port>8080</port>\n                <!--编码集-->\n                <uriEncoding>UTF-8</uriEncoding>\n                <!--访问路径-->\n                <path>/testMaven</path>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n```\n\n> 【注意】此方法使用 Maven 自带 Tomcat 插件，也可以使用本地 Tomcat\n\n14、启动 Tomcat 服务器\n\n![start_tomcat](Maven/start_tomcat.png)\n\n> 【注意】不要反复启动 Tomcat 服务器\n\n### Maven Web 项目结构\n\n![maven_web_moudles](Maven/maven_web_moudles.png)\n\n### Maven 操作\n\n![maven_do](Maven/maven_do.png)\n\n### pom.xml 配置文件【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"https://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"https://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.fc</groupId>\n    <artifactId>maven_project</artifactId>\n    <version>1.0-SNAPSHOT</version>\n    <!--因为是web项目，所以打包方式声明为war-->\n    <packaging>war</packaging>\n\n    <!--添加jar包依赖-->\n    <dependencies>\n        <!--Servlet-api-->\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>3.1.0</version>\n            <!--声明此jar包的作用域为编译期-->\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <!--添加插件-->\n        <plugins>\n            <!--添加Tomcat插件-->\n            <plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.2</version>\n                <!--Tomcat相关配置-->\n                <configuration>\n                    <!--端口-->\n                    <port>8080</port>\n                    <!--编码集-->\n                    <uriEncoding>UTF-8</uriEncoding>\n                    <!--访问路径-->\n                    <path>/testMaven</path>\n                </configuration>\n            </plugin>\n        </plugins>\n\n        <resources>\n            <!--需要设置打包的文件 特别是非java文件-->\n            <resource>\n                <directory>src/main/java</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n            <resource>\n                <directory>src/main/resources</directory>\n                <includes>\n                    <include>**/*.xml</include>\n                    <include>**/*.properties</include>\n                </includes>\n            </resource>\n        </resources>\n    </build>\n</project>\n```\n\n> 【注意】使用时直接复制粘贴，修改 groupId、artifactId、path 等参数即可\n\n### Maven 相关命令【了解】\n\n| 命令                | 描述                                                           |\n| ------------------- | -------------------------------------------------------------- |\n| mvn version         | 显示当前版本信息                                               |\n| mvn compile         | 编译源代码                                                     |\n| mvn test-compile    | 编译测试代码                                                   |\n| mvn test            | 运行测试                                                       |\n| mvn site            | 生成 site                                                      |\n| mvn eclipse:eclipse | 生成 eclipse 项目                                              |\n| mvn idea:idea       | 生成 idea 项目                                                 |\n| mvn clean           | 清除产生的项目                                                 |\n| mvn package         | 打包                                                           |\n| mvn jar:jar         | 只打 jar 包                                                    |\n| mvn source:jar      | 源码打包                                                       |\n| mvn tomcat7:run     | 在 tomcat 容器中运行 web 应用                                  |\n| mvn jetty:run       | 调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 |\n","tags":["Maven"],"categories":["学习笔记"]},{"title":"蓝桥杯-七星填数","url":"/posts/SevenStarsFillNumber.html","content":"\n## 题目\n\n如图所示。\n在七角星的 14 个节点上填入 1~14 的数字，不重复，不遗漏.要求每条直线上的四个数字之和必须相等。\n图中已经给出了 3 个数字。\n请计算其它位置要填充的数字，答案唯一。\n填好后，请提交绿色节点的 4 个数字（从左到右，用空格分开)\n比如: 12 5 4 8\n当然，这不是正确的答案\n\n只提交 4 个用空格分开的数字，不要填写任何多余的内容。\n\n> 答案：`10 3 9 8`\n\n![eg](WindowsPowerShellOperationHexo/eg.png)\n\n## 思路\n\n如图：\n\n![thinking](WindowsPowerShellOperationHexo/thinking.png)\n\n> 新建数组用于存放未知数字，红色为下表编号\n>\n> 通过全排列将 1-14 未使用的依次放入数组中\n>\n> 判断是否满足七边之和相等\n\n## 代码\n\n```java\n\tpublic static void main(String[] args) {\n\t\t// a[0]==6 &&a[8]==14&& a[9]==11\n\t\tint[] num = { 1, 2, 3, 4, 5, 7, 8, 9, 10, 12, 13 };\n\t\tdfs(num, 0, num.length - 1);\n\t}\n\t//全排列\n\tstatic void dfs(int[] num, int p, int q) {\n        //满足排列和七边之和相等\n\t\tif (p == q && flag(num)) {\n\t\t\tSystem.out.print(num[0] + \" \" + num[1] + \" \" + num[2] + \" \" + num[3]);\n\t\t}\n\n\t\tfor (int i = p; i <= q; i++) {\n\t\t\tswap(num, p, i);\n\t\t\tdfs(num, p + 1, q);\n\t\t\tswap(num, p, i);\n\t\t}\n\t}\n\t// 两数交换 a[0]=0,a[1]=1======>>a[0]=1,a[1]=0\n\tstatic void swap(int[] num, int p, int i) {\n\t\tint temp = num[p];\n\t\tnum[p] = num[i];\n\t\tnum[i] = temp;\n\t}\n\n\t// 判断是否满足条件（七边之和相等）\n\tstatic boolean flag(int[] a) {\n\t\tint sum = sum(a[0], a[1], a[2], a[3]);\n\t\tint sum1 = sum(a[0], a[4], a[6], a[9]);\n\t\tint sum2 = sum(a[9], a[8], a[7], 11);\n\t\tint sum3 = sum(6, a[2], a[5], 11);\n\t\tint sum4 = sum(6, a[1], a[4], 14);\n\t\tint sum5 = sum(14, a[6], a[8], a[10]);\n\t\tint sum6 = sum(a[10], a[7], a[5], a[3]);\n\n\t\treturn sum == sum1 && sum1 == sum2 && sum2 == sum3 && sum3 == sum4 && sum4 == sum5 && sum5 == sum6;\n\t}\n\t// 返回四数之和\n\tstatic int sum(int a, int b, int c, int d) {\n\t\treturn a + b + c + d;\n\t}\n```\n","tags":["Coding"],"categories":["学习笔记"]},{"title":"MySQL报错1130","url":"/posts/MySQLError1130.html","content":"\n## 错误截图\n\n![mysql_1130CodeError](MySQLError1130/mysql_1130CodeError.png)\n\n## 错误原因\n\n> 错误：ERROR 1130: Host ‘192.168.XX.XXX’ is not allowed to connect to thisMySQL serve\n>\n> 错误 1130：主机 192.168.XX.XXX”不允许连接到 thismysql 服务\n>\n> 原因：被连接的数据不允许使用 192.168.XX.XXX 访问，只允许是用 localhost;\n\n## 解决办法\n\n在 localhost 的那台电脑，登入 mysql 后，更改”mysql” 数据库里的 “user” 表里的 “host”项，从”localhost”改称”%”\n\n命令详情\n\n```mysql\nmysql -u root -p\n\nuse mysql;\n\nselect 'host' from user where user='root';\n\nupdate user set host = '%' where user ='root';\n\nflush privileges;\n\nselect 'host'   from user where user='root';\n```\n","tags":["MySQL"],"categories":["经验分享"]},{"title":"Hexo添加气泡上升特效","url":"/posts/AddBubbleRiseEffect.html","content":"\n## 添加 JavaScript\n\n在需要的地方添加以下 JS\n\n```javascript\n//运行主函数\ncircleMagic();\n//主函数内容\nfunction circleMagic(options) {\n  let width;\n  let height;\n  let canvas;\n  let ctx;\n  let animateHeader = true;\n  const circles = [];\n\n  const settings = options || {\n    color: \"rgba(255,255,255,.5)\",\n    radius: 10,\n    density: 0.3,\n    clearOffset: 0.2,\n  };\n\n  //  Main\n\n  const container = document.getElementById(\"smarts\");\n  initContainer();\n  addListeners();\n\n  function initContainer() {\n    width = container.offsetWidth;\n    height = container.offsetHeight - 120;\n\n    //  create canvas element\n\n    initCanvas();\n    canvas = document.getElementById(\"homeTopCanvas\");\n    canvas.width = width;\n    canvas.height = height;\n    canvas.style.position = \"absolute\";\n    canvas.style.left = \"0\";\n    canvas.style.bottom = \"0\";\n    ctx = canvas.getContext(\"2d\");\n\n    //  create circles\n    for (let x = 0; x < width * settings.density; x++) {\n      const c = new Circle();\n      circles.push(c);\n    }\n    animate();\n  }\n\n  // Init canvas element\n  function initCanvas() {\n    const canvasElement = document.createElement(\"canvas\");\n    canvasElement.id = \"homeTopCanvas\";\n    canvasElement.style.pointerEvents = \"none\";\n    container.appendChild(canvasElement);\n    canvasElement.parentElement.style.overflow = \"hidden\";\n  }\n\n  // Event handling\n  function addListeners() {\n    window.addEventListener(\"scroll\", scrollCheck, false);\n    window.addEventListener(\"resize\", resize, false);\n  }\n\n  function scrollCheck() {\n    if (document.body.scrollTop > height) {\n      animateHeader = false;\n    } else {\n      animateHeader = true;\n    }\n  }\n\n  function resize() {\n    width = container.clientWidth;\n    height = container.clientHeight;\n    container.height = height + \"px\";\n    canvas.width = width;\n    canvas.height = height;\n  }\n\n  function animate() {\n    if (animateHeader) {\n      ctx.clearRect(0, 0, width, height);\n      for (const i in circles) {\n        circles[i].draw();\n      }\n    }\n    requestAnimationFrame(animate);\n  }\n\n  function randomColor() {\n    const r = Math.floor(Math.random() * 255);\n    const g = Math.floor(Math.random() * 255);\n    const b = Math.floor(Math.random() * 255);\n    const alpha = Math.random().toPrecision(2);\n    return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + alpha + \")\";\n  }\n\n  //  Canvas manipulation\n\n  function Circle() {\n    const that = this;\n\n    // constructor\n    (function () {\n      that.pos = {};\n      init();\n    })();\n\n    function init() {\n      that.pos.x = Math.random() * width;\n      that.pos.y = height + Math.random() * 100;\n      that.alpha = 0.1 + Math.random() * settings.clearOffset;\n      that.scale = 0.1 + Math.random() * 0.3;\n      that.speed = Math.random();\n      if (settings.color === \"random\") {\n        that.color = randomColor();\n      } else {\n        that.color = settings.color;\n      }\n    }\n\n    this.draw = function () {\n      if (that.alpha <= 0) {\n        init();\n      }\n      that.pos.y -= that.speed;\n      that.alpha -= 0.0005;\n      ctx.beginPath();\n      ctx.arc(\n        that.pos.x,\n        that.pos.y,\n        that.scale * settings.radius,\n        0,\n        2 * Math.PI,\n        false\n      );\n      ctx.fillStyle = that.color;\n      ctx.fill();\n      ctx.closePath();\n    };\n  }\n}\n```\n\n## 添加特效容器\n\n在需要的 box 中设置 `id=\"smarts\"`\n\n\n## 效果演示代码\n\n新建文本后缀从`txt`改为`html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"\n    />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Document</title>\n  </head>\n  <body style=\"background: #000;width: 100%;height: 100%\">\n    <div style=\"height:500px\" id=\"smarts\"></div>\n  </body>\n  <script>\n    circleMagic();\n    //主函数内容\n    function circleMagic(options) {\n      let width;\n      let height;\n      let canvas;\n      let ctx;\n      let animateHeader = true;\n      const circles = [];\n\n      const settings = options || {\n        color: \"rgba(255,255,255,.5)\",\n        radius: 10,\n        density: 0.3,\n        clearOffset: 0.2,\n      };\n\n      //  Main\n\n      const container = document.getElementById(\"smarts\");\n      initContainer();\n      addListeners();\n\n      function initContainer() {\n        width = container.offsetWidth;\n        height = container.offsetHeight - 120;\n\n        //  create canvas element\n\n        initCanvas();\n        canvas = document.getElementById(\"homeTopCanvas\");\n        canvas.width = width;\n        canvas.height = height;\n        canvas.style.position = \"absolute\";\n        canvas.style.left = \"0\";\n        canvas.style.bottom = \"0\";\n        ctx = canvas.getContext(\"2d\");\n\n        //  create circles\n        for (let x = 0; x < width * settings.density; x++) {\n          const c = new Circle();\n          circles.push(c);\n        }\n        animate();\n      }\n\n      // Init canvas element\n      function initCanvas() {\n        const canvasElement = document.createElement(\"canvas\");\n        canvasElement.id = \"homeTopCanvas\";\n        canvasElement.style.pointerEvents = \"none\";\n        container.appendChild(canvasElement);\n        canvasElement.parentElement.style.overflow = \"hidden\";\n      }\n\n      // Event handling\n      function addListeners() {\n        window.addEventListener(\"scroll\", scrollCheck, false);\n        window.addEventListener(\"resize\", resize, false);\n      }\n\n      function scrollCheck() {\n        if (document.body.scrollTop > height) {\n          animateHeader = false;\n        } else {\n          animateHeader = true;\n        }\n      }\n\n      function resize() {\n        width = container.clientWidth;\n        height = container.clientHeight;\n        container.height = height + \"px\";\n        canvas.width = width;\n        canvas.height = height;\n      }\n\n      function animate() {\n        if (animateHeader) {\n          ctx.clearRect(0, 0, width, height);\n          for (const i in circles) {\n            circles[i].draw();\n          }\n        }\n        requestAnimationFrame(animate);\n      }\n\n      function randomColor() {\n        const r = Math.floor(Math.random() * 255);\n        const g = Math.floor(Math.random() * 255);\n        const b = Math.floor(Math.random() * 255);\n        const alpha = Math.random().toPrecision(2);\n        return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + alpha + \")\";\n      }\n\n      //  Canvas manipulation\n\n      function Circle() {\n        const that = this;\n\n        // constructor\n        (function () {\n          that.pos = {};\n          init();\n        })();\n\n        function init() {\n          that.pos.x = Math.random() * width;\n          that.pos.y = height + Math.random() * 100;\n          that.alpha = 0.1 + Math.random() * settings.clearOffset;\n          that.scale = 0.1 + Math.random() * 0.3;\n          that.speed = Math.random();\n          if (settings.color === \"random\") {\n            that.color = randomColor();\n          } else {\n            that.color = settings.color;\n          }\n        }\n\n        this.draw = function () {\n          if (that.alpha <= 0) {\n            init();\n          }\n          that.pos.y -= that.speed;\n          that.alpha -= 0.0005;\n          ctx.beginPath();\n          ctx.arc(\n            that.pos.x,\n            that.pos.y,\n            that.scale * settings.radius,\n            0,\n            2 * Math.PI,\n            false\n          );\n          ctx.fillStyle = that.color;\n          ctx.fill();\n          ctx.closePath();\n        };\n      }\n    }\n  </script>\n</html>\n```\n","tags":["JavaScript"],"categories":["经验分享"]},{"title":"Hexo页面加载动画(吃豆豆)","url":"/posts/LoadingEatDD.html","content":"\n# Loading 吃豆豆动画\n\n## 新建 loading.ejs 文件\n\n在`_partial` 文件夹下新建`loading.ejs`\n\n添加以下代码\n\n```ejs\n<style type=\"text/css\">\n    #loading-container{\n    position: fixed;\n    top: 0;\n    left: 0;\n    min-height: 100vh;\n    width: 100vw;\n    z-index: 9999;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    background: #FFF;\n    text-align: center;\n    /* loader页面消失采用渐隐的方式*/\n    -webkit-transition: opacity 1s ease;\n    -moz-transition: opacity 1s ease;\n    -o-transition: opacity 1s ease;\n    transition: opacity 1s ease;\n}\n.loading-image{\n    width: 120px;\n    height: 50px;\n    transform: translate(-50%);\n}\n\n.loading-image div:nth-child(2) {\n    -webkit-animation: pacman-balls 1s linear 0s infinite;\n    animation: pacman-balls 1s linear 0s infinite\n}\n\n.loading-image div:nth-child(3) {\n    -webkit-animation: pacman-balls 1s linear .33s infinite;\n    animation: pacman-balls 1s linear .33s infinite\n}\n\n.loading-image div:nth-child(4) {\n    -webkit-animation: pacman-balls 1s linear .66s infinite;\n    animation: pacman-balls 1s linear .66s infinite\n}\n\n.loading-image div:nth-child(5) {\n    -webkit-animation: pacman-balls 1s linear .99s infinite;\n    animation: pacman-balls 1s linear .99s infinite\n}\n\n.loading-image div:first-of-type {\n    width: 0;\n    height: 0;\n    border: 25px solid #49b1f5;\n    border-right-color: transparent;\n    border-radius: 25px;\n    -webkit-animation: rotate_pacman_half_up .5s 0s infinite;\n    animation: rotate_pacman_half_up .5s 0s infinite;\n}\n.loading-image div:nth-child(2) {\n    width: 0;\n    height: 0;\n    border: 25px solid #49b1f5;\n    border-right-color: transparent;\n    border-radius: 25px;\n    -webkit-animation: rotate_pacman_half_down .5s 0s infinite;\n    animation: rotate_pacman_half_down .5s 0s infinite;\n    margin-top: -50px;\n}\n@-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}\n\n@keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}\n\n@-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}\n\n@keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}\n\n@-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}\n\n@keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}\n\n\n.loading-image div:nth-child(3),\n.loading-image div:nth-child(4),\n.loading-image div:nth-child(5),\n.loading-image div:nth-child(6){\n    background-color: #49b1f5;\n    width: 15px;\n    height: 15px;\n    border-radius: 100%;\n    margin: 2px;\n    width: 10px;\n    height: 10px;\n    position: absolute;\n    transform: translateY(-6.25px);\n    top: 25px;\n    left: 100px;\n}\n.loading-text{\n    margin-bottom: 20vh;\n    text-align: center;\n    color: #2c3e50;\n    font-size: 2rem;\n    box-sizing: border-box;\n    padding: 0 10px;\n    text-shadow: 0 2px 10px rgba(0,0,0,0.2);\n}\n@media only screen and (max-width: 500px) {\n    .loading-text{\n        font-size: 1.5rem;\n    }\n}\n.fadeout {\n    opacity: 0;\n    filter: alpha(opacity=0);\n}\n/* logo出现动画 */\n@-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}\n@keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}\n</style>\n<div id=\"loading-container\">\n    <p class=\"loading-text\">嘘 ~ 正在从服务器偷取页面 . . . </p>\n    <div class=\"loading-image\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n    </div>\n</div>\n<script>\n    (function () {\n        const loaded = function () {\n            setTimeout(function () {\n                const loader = document.getElementById(\"loading-container\");\n                loader.className = \"fadeout\";\n                setTimeout(function () {\n                    loader.style.display = \"none\";\n                }, 500);\n            }, <%- theme.loading.time %>);\n        };\n        loaded();\n    })();\n</script>\n```\n\n## 引用 ejs 文件\n\n在 `layout.ejs`中引用`loading.ejs`\n\n```ejs\n<% if (theme.loading.enable) { %>\n    <!--  加载动画，强制加载0.5s  -->\n    <%- partial('_partial/loading') %>\n<% } %>\n```\n\n## 添加配置文件\n\n在主题配置文件（`_config.yml`）下添加以下配置\n\n```yaml\n# 加载动画\nloading:\n  enable: true\n  time: 500 # 强制开启loading动画的时间 1000=1s,默认为0.5s\n```\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Docker安装Redis","url":"/posts/DockerInstallRedis.html","content":"\n## Docker 安装 Redis\n\nDocker 镜像市场 [传送门](https://hub.docker.com/_/redis)\n\n### 安装 Redis 镜像\n\n```shell\n# sudo 以超级管理员权限运行命令\n# docker pull 镜像名:镜像版本\n# docker pull 镜像名 即不加:版本号为默认安装最新版本镜像\n$ sudo docker pull redis\n```\n\n### 查询已安装的镜像\n\n使用命令 `sudo docker images` 查询已安装的镜像\n\n### 创建实例并启动\n\n运行命令 `mkdir -p /mydata/redis/conf`\n\n再运行 `touch /mydata/redis/conf/redis.conf`\n\n运行命令实现挂载\n\n```shell\n$ sudo docker run -p 6379:6379 --name redis \\\n-v /mydata/redis/data:/data/log \\\n-v /mydata/redis/conf:/etc/redis/redis.conf \\\n-d redis redis-server /etc/redis/redis.conf\n```\n\n### 设置 Docker 中 Redis 开机自启动\n\n管理员权限运行命令 (su root)\n\n```shell\ndocker update redis --restart=always\n```\n\n### 使用 Redis 客户端\n\n运行`docker ps -a` 查询运行中的容器中是否有`redis`正在运行\n\n![docker ps -a](DockerInstallRedis/dockerps-a.png)\n\n使用命令`docker exec -it redis redis-cli` 进行客户端连接\n\n### 使用工具 RedisDesktopManager 远程连接 Redis\n\n工具下载地址 [传送门](https://github.com/uglide/RedisDesktopManager/releases/tag/0.9.3)\n\n微云下载连接 [传送门](https://share.weiyun.com/i9rfHd7U)\n\n安装后在 linux 中输入 `ip addr` 查询 id 地址进行登录即可\n","tags":["Docker","Redis"],"categories":["学习笔记"]},{"title":"Docker安装MySQL服务","url":"/posts/DockerInstallMySQL.html","content":"\n## Docker 安装 MySQL\n\n### 安装 MySQL 镜像\n\n```shell\n# sudo 以超级管理员权限运行命令\n# docker pull 镜像名:镜像版本\n# docker pull 镜像名 即不加:版本号为默认安装最新版本镜像\n$ sudo docker pull mysql:5.7\n```\n\n### 查询已安装的镜像\n\n使用命令 `sudo docker images` 查询已安装的镜像\n\n### 创建实例并启动\n\n运行命令实现挂载\n\n```shell\n$ docker run -p 3306:3306 --name mysql \\\n-v /mydata/mysql/log:/var/log/mysql \\\n-v /mydata/mysql/data:/var/lib/mysql \\\n-v /mydata/mysql/conf:/etc/mysql \\\n-e MYSQL_ROOT_PASSWORD=root \\\n-d mysql:5.7\n####################################\n# 若未成功可能为权限问题导致，运行 su root 提升至管理员权限\n# 参数说明\n# -p 3306:3306:    将容器的3306端口映射到主机的3306端口\n# -v /mydata/mysql/log:/var/log/mysql    将日志文件夹挂在到主机\n# -v /mydata/mysql/data:/var/lib/mysql    将配置文件夹挂在到主机\n# -v /mydata/mysql/conf:/etc/mysql    将配置文件夹挂载到主机\n# -e MYSQL_ROOT_PASSWORD=root    初始化root用户的密码\n# -d mysql：5.7    以后台方式运行\n###################################\n```\n\n安装后使用命令 `docker ps` 查询正在运行的服务\n\n### 修改 MySQL 配置\n\n将拉丁编码修改为 utf8 编码\n\n在 cmd 中输入命令 `vi /mydata/mysql/conf/my.cnf`\n\n在 `my.cnf` 中添加\n\n```shell\n[client]\ndefault-character-set=utf8\n\n[mysql]\ndefault-character-set=utf8\n\n[mysqld]\ninit_connect='SET collation_connection = utf8_unicode_ci'\ninit_connect='SET NAMES utf8'\ncharacter-set-server=utf8\ncollation-server=utf8_unicode_ci\nskip-character-set-client-handshake\nskip-name-resolve\n```\n\n运行命令`docker restart mysql` 重启 mysql 服务\n\n### 设置 Docker 中 MySQL 开机自启动\n\n管理员权限运行命令\n\n```shell\ndocker update mysql --restart=always\n```\n","tags":["Docker","MySQL"],"categories":["学习笔记"]},{"title":"Linux安装Docker服务","url":"/posts/LinuxInstallDocker.html","content":"\n# Linux 系统 Docker 安装及软件安装\n\n## Docker 简介\n\nDocker 是一个开源的应用容器引擎，基于 [Go 语言](https://www.runoob.com/go/go-tutorial.html) 并遵从 Apache2.0 协议开源。\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\nDocker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。\n\n## Docker 安装\n\n官方链接  [传送门](https://docs.docker.com/engine/install/centos/)\n\n###  卸载旧版本\n\n```shell\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-engine\n```\n\n由于我第一次安装，运行后显示如下图\n\n![docker-rm-rf](LinuxInstallDocker/docker-rm-rf.png)\n\n### 安装 Docker\n\n1.  安装必要的依赖包设置存储库\n\n```shell\n# 安装必要依赖包\n$ sudo yum install -y yum-utils\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n2.  启动 Docker\n\n#### 安装 Docker 引擎\n\n```shell\n$ sudo yum install docker-ce docker-ce-cli containerd.io\n```\n\n```shell\n$ sudo systemctl start docker\n```\n\n## Docker 简单命令\n\n### 查询 Docker 安装是否成功\n\n```shell\n# 使用命令查询Docker是否安装成功(查询Docker安装版本)\n$ docker -v\n```\n\n![docker-v](LinuxInstallDocker/docker-v.png)\n\n### 查看 Docker 下载的镜像\n\n```shell\n$ sudo docker images\n```\n\n![docker-image](LinuxInstallDocker/docker-image.png)\n\n### 设置 Docker 开机自启动\n\n```shell\n$ sudo systemctl enable docker\n```\n\n![docker-systemctl](LinuxInstallDocker/docker-systemctl.png)\n\n### Docker 镜像加速\n\n阿里云镜像源 [传送门](https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors)\n\n登陆后，左侧菜单选中镜像加速器就可以看到你的专属地址了\n\n```shell\n$ sudo mkdir -p /etc/docker\n\n$ sudo tee /etc/docker/daemon.json <<-'EOF'\n{\n  \"registry-mirrors\": [\"专属加速地址\"]\n}\nEOF\n\n$ sudo systemctl daemon-reload\n\n$ sudo systemctl restart docker\n```\n","tags":["Docker","Linux"],"categories":["学习笔记"]},{"title":"Linux安装Mysql","url":"/posts/LinuxInstallMysql.html","content":"\n## **安装 MySQL**\n\n```shell\nwget https://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm\n\nrpm -ivh mysql-community-release-el7-5.noarch.rpm\n\nyum update\n\nyum install mysql-server\n```\n\n若未找到 wget\n\n![NotFindwget](LinuxInstallMysql/NotFindwget.png)\n\n则需要先安装 wget：\n\n```\nyum -y install wget\n```\n\n![installWget](LinuxInstallMysql/installWget.png)\n\n### 权限设置\n\n```shell\nchown mysql:mysql -R /var/lib/mysql\n```\n\n### 初始化 MySQL\n\n```shell\nmysqld --initialize\n```\n\n### 启动 MySQL：\n\n```shell\nsystemctl start mysqld\n```\n\n### 查看 MySQL 运行状态：\n\n```shell\nsystemctl status mysqld\n```\n\n### 使用 MySQL ClientMysql 客户端 Mysql 客户端 执行简单的 SQL 命令\n\n```shell\nmysql\n```\n\n### 创建 root 用户密码并登录\n\n```shell\n# 设置密码\nset password for 'root'@'localhost'=password('root');\n# 推出Mysql\nexit\n# 登录MySQL\nmysql -u root -p\n```\n\n远程链接了一下 MySQL，出现了以下错误1130，查了一下，是因为 MySQL 没有允许远程登陆，所以要授权 MySQL 远程登陆。\n\n![mysql_1130error](LinuxInstallMysql/mysql_1130error.png)\n\n从任何主机上使用 root 用户，密码：yourpassword（你的 root 密码）连接到 mysql 服务器：\n\n```mysql\n# 完成登录操作\nmysql -u root -p root \n# 修改访问权限mysql>\nGRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\n# 操作完后切记执行以下命令刷新权限 \nFLUSH PRIVILEGES;\n```\n\n远程连接如出现2002错误尾部为(10060)时可通过防火墙开放3306端口\n```shell\n/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT\n```\n\n这时再通过 navicat 远程链接 MySQL，链接测试。\n","tags":["MySQL","Linux"],"categories":["学习笔记"]},{"title":"Linux一行代码安装JDK","url":"/posts/LinuxInstallJDK.html","content":"\n直接输入下面这个命令，然后等就完事儿\n\n`yum install -y java-1.8.0-openjdk.x86_64`\n\n测试是否安装成功：`java -version`\n","tags":["Linux","JDK"],"categories":["学习笔记"]},{"title":"Java面试题","url":"/posts/JavaInterviewQuestion.html","content":"\n# Java 面试题\n\n## 面向对象的特征有哪些方面\n\n### 抽象\n\n抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。\n\n> 抽象包括两个方面\n>\n> 1. 过程抽象\n> 2. 数据抽象\n\n### 继承\n\n继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类成为原始类的派生类（子类），而原始类成为新类的积累（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊需要。\n\n### 封装\n\n封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其它对象。\n\n### 多态\n\n多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态行和包含多态性。多态语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。\n\n## String 是最基本的数据类型吗？\n\n基本数据类型包括一下 8 种\n\n> byte、int、char、long、float、double、boolean、short\n\njava.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间我们应该用 StringBuffer 类\n\n## String 和 StringBuffer 的区别\n\nJAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用 StringBuffer。\n\n典型地，你可以使用 StringBuffer 来动态构造字符数据\n\n### String、StringBuffer 与 StringBuilder 比较\n\n> 三者运行速度不同\n\n#### String 运行速度\n\n遍历一百万次\n\n```java\nString a = \"\";\nlong startTime = System.currentTimeMillis();\nfor(int i=0; i<100*100*10;i++){\n    a+=\"aa\";\n}\nlong endTime = System.currentTimeMillis();\nSystem.out.println(\"耗时：\"+String.valueOf(endTime - startTime));\n```\n\n运行结果为 `耗时:7614`\n\n#### StringBuffer 运行速度\n\n遍历一亿次\n\n```java\nStringBuffer a = new StringBuffer();\nString aa = \"aa\";\nlong startTime = System.currentTimeMillis();\nfor(int i=0;i<100*100*100*100;i++){\n    //字符串拼接\n    a.append(aa);\n}\nlong endTime = System.currentTimeMillis();\nSystem.out.println(\"耗时：\"+String.valueOf(endTime - startTime));\n```\n\n运行结果为 `耗时：3128`\n\n#### StringBuilder 运行速度\n\n遍历一亿次\n\n```java\nStringBuilder a = new StringBuilder();\nString aa = \"aa\";\nlong startTime = System.currentTimeMillis();\nfor(int i=0;i<100*100*100*100;i++){\n    a.append(aa);\n}\nlong endTime = System.currentTimeMillis();\nSystem.out.println(\"耗时：\"+String.valueOf(endTime - startTime));\n```\n\n运行结果为 `耗时：1240`\n\n#### 比较结果\n\n速度比较：String < StringBuffer < StringBuilder 且 String 的处理速度要比 StringBuffer、StringBuilder 要慢得多\n\n> 分析为什么 String 的处理速度要比 StringBuffer、StringBuilder 慢得多？\n\n1.  String 是不可变对象\n2.  StringBuffer 和 StringBuilder 是可变对象\n    > - String 本身就是一个对象，因为 String 不可变对象，所以，每次遍历对字符串做拼接操作，都会重新创建一个对象，循环 100 万次就是创建 100 万个对象，非常的消耗内存空间，而且创建对象本身就是一个耗时操作，创建 100 万次对象就相当的耗时了。\n    > - StringBuffer 和 StringBuilder 只需要创建一个 StringBuffer 或 StringBuilder 对象，然后用 append 拼接字符串，就算拼接一亿次，仍然只有一个对象。\n\n> 是不是可以抛弃使用 String，转而使用 StringBuffer 和 StringBuilder 呢？\n\nNo!!!\n\n1.  String 遍历代码：开始定义一个 String 常量（创建一个 String 对象），再开始遍历\n2.  StringBuffer 遍历代码：开始定义一个 String 常量（创建一个 String 对象）和一个 StringBuffer 对象，再开始遍历\n3.  StringBuiler 遍历代码：开始定义一个 String 常量（创建一个 String 对象）和一个 StringBuiler 对象，再开始遍历\n    > `StringBuffer`和`StringBuiler`比`String`多了一个创建对象流程，所以，如果数据量比较小的情况建议使用`String`。\n\n> 说说 StringBuffer 和 StringBuilder 的区别？\n\n1. StringBuffer 是线程安全的\n2. StringBuilder 是非线程安全的， 这也是速度比 StringBuffer 快的原因\n\n> 适用场景？\n\n1. 如果要操作少量的数据用 String\n2. 单线程操作字符串缓冲区 下操作大量数据 StringBuilder\n3. 多线程操作字符串缓冲区 下操作大量数据 StringBuffer\n\n## int 和 Integer 有什么区别\n\nJava 提供两种不同的类型：引用类型和原始类型（内置类型）。int 是 Java 的原始数据类型，Integer 是 Java 为 int 提供的封装类。Java 为每个原始类型提供了封装类\n\n| byte    | Byte    |\n| ------- | ------- |\n| short   | Short   |\n| float   | Float   |\n| double  | Double  |\n| boolean | Boolean |\n| char    | Char    |\n| int     | Integer |\n| long    | Long    |\n\n> 引用类型与原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。\n\n## 运行时异常与一般异常有何异同\n\n异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机通常操作中可能遇到的异常，是一种常见运行错误。Java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未捕获的运行时异常。\n\n## &和&&的区别\n\n&和&&都可作为逻辑运算符”与“使用，但是&&是“短路与”，运算时先判断符号前面的表达式的值，如果能够确定整个表达式的值，则不进行符号后面的表达式的运算。\n\n> &亦可做为运算符使用。\n\n## 说出 ArrayList，Vector，LinkedList 的存储性能和特性\n\nArrayList 和 Vector 都是使用数据方式存储数据，此数组元素大于实际存储的数据以便以添加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。\n\n## Collection 和 Collections 的区别\n\nCollection 是集合类的上级接口，继承它的接口主要有 Set 和 List。\n\nConllections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。\n\n## HashMap 和 Hashtable 的区别\n\n1. HashMap 是 Hashtable 的轻量级实现（非线程安全的实现），它们都完成了 Map 接口，主要区别在于 HashMap 允许空（null）键值（key），由于非线程安全，效率上可能高于 Hashtable。\n2. HashMap 允许将 null 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。\n3. HashMap 把 Hashtable 的 contains 方法去掉了，改成 containsValue 和 containsKey。因为 contains 方法容易让人引起误解。\n4. Hashtable 继承自 Dictionary 类，而 HashMap 是 Java1.2 引进的 Map interface 的一个实现。\n5. 最大的不同是，Hashtable 的方法是 Synchronize 的，而 HashMap 不是，在多个线程访问 Hashtable 时，不需要为它的方法实现同步，而 HashMap 就必须为之提供外同步。\n6. Hashtable 和 HashMap 采用的 hash/rehash 算法都大概一样，所以性能不会有很大的差异。\n","tags":["JAVA"],"categories":["值得一看"]},{"title":"Markdown基础语法","url":"/posts/Markdown.html","content":"\n# Markdown 基础语法\n\n## Markdown 简介\n\nMarkdown 是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n### **优点：**\n\n1、因为是纯文本，所以只要支持 Markdown 的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。\n\n2、操作简单。比如:WYSIWYG 编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而 Markdown 只需要在标题内容前加#即可\n3、支持 HTML 语法\n\n### **缺点：**\n\n1、需要记一些语法（当然，是很简单）。\n2、有些平台不支持 Markdown 编辑模式。\n3、若想写 HTML 语法需要用到'\n比如:`<h1>这是一个标题</h1>`的代码为\n\n```\n`<h1>这是一个标题</h1>`\n```\n\n###### Hexo 是使用 Markdown 编辑的。\n\n## 一、标题\n\n在想要设置为标题的文字前面加#来表示\n\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n\n###### 注：标准语法一般在#后跟个空格再写文字。\n\n示例：\n\n```\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n```\n\n效果：\n\n# 这是一级标题\n\n## 这是二级标题\n\n### 这是三级标题\n\n#### 这是四级标题\n\n##### 这是五级标题\n\n###### 这是六级标题\n\n## 二、字体\n\n### 加粗\n\n要加粗的文字左右分别用两个\\*号包起来\n\n也可`<b>加粗内容</b>`\n\n### 斜体\n\n要倾斜的文字左右分别用一个\\*号包起来\n也可`<i>倾斜内容</i>`\n\n### 斜体加粗\n\n要倾斜和加粗的文字左右分别用三个\\*号包起来\n也可`<b><i>加粗倾斜内容</i></b>`\n\n### 删除线\n\n要加删除线的文字左右分别用两个~~号包起来(删除线用 HTML 语法比较麻烦建议使用 Markdown 语法)\n\n示例：\n\n```\n**这是加粗**\n*这是倾斜*\n***这是斜体加粗***\n~~这是加删除线~~\n```\n\n效果：\n\n**这是加粗的文字**\n\n_这是倾斜的文字_\n\n**_这是斜体加粗的文字_**\n\n~~这是删除线~~\n\n## 三、引用\n\n在引用的文字前加>即可。引用也可以嵌套，如加两个>>三个>>>\n\nn 个...(貌似理论可以一直加下去)\n\n示例：\n\n```\n>这是引用的内容\n>>这是引用的内容\n>>>>>>>>>>这是引用的内容\n```\n\n效果：\n\n> 这是引用的内容\n\n> 这是引用的内容\n\n>\n\n>\n\n>\n\n>\n\n>\n\n>\n\n>\n\n> 这是引用的内容\n\n## 四、分割线\n\n三个或者三个以上的 - 或者 \\* 都可以。\n\n示例：\n\n```\n---\n----\n***\n*****\n```\n\n效果：\n\n---\n\n---\n\n###\n\n## 五、图片\n\n语法：\n\n```\n![图片alt](图片地址 ''图片title'')\n\n图片alt就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加\n```\n\n使用 HTML 语法`<img src=\"图片地址\" alt=\"\" title=\"\"><>`\n\n## 六、超链接\n\n语法：\n\n```\n[超链接名](超链接地址 \"超链接title\")\ntitle可加可不加\n```\n\n使用 HTML 语法`<a href=\"超链接地址\" title=\"\">超链接名</a>`\n示例：\n\n```\n[Lu's Blog](https://islu.cn\"Lu's Blog\")\n```\n\n效果：\n\n[Lu's Blog]([https://islu.cn](https://islu.cn)\"Lu's Blog\")\n\n## 七、列表\n\n**无序列表**\n\n语法：\n无序列表用 - + \\* 任何一种都可以\n\n```\n- 列表内容\n+ 列表内容\n* 列表内容\n\n注意：- + * 跟内容之间都要有一个空格\n```\n\n使用 HTML 语法\n\n```\n<ul>\n<li>列表内容<li>\n<li>列表内容</li>\n</ul>\n```\n\n效果：\n\n- 列表内容\n\n- 列表内容\n\n- 列表内容\n\n**有序列表**\n\n语法：\n数字加点\n\n```\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n注意：序号跟内容之间要有空格\n```\n\n使用 HTML 语法\n\n```\n<ol>\n<li>列表内容<li>\n<li>列表内容</li>\n</ol>\n```\n\n效果：\n\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n**列表嵌套**\n上一级和下一级之间敲三个空格即可(一下 Tap 键也可)\n\n- 一级无序列表内容\n  - 二级无序列表内容\n\n## 八、表格\n\n语法：\n\n```\n表头|表头|表头\n---|:--:|---:\n内容|内容|内容\n内容|内容|内容\n\n第二行分割表头和内容。\n- 有一个就行，为了对齐，多加了几个\n文字默认居左\n-两边加：表示文字居中\n-右边加：表示文字居右\n注：原生的语法两边都要用 | 包起来。此处省略\n```\n\nHTML 语法过于麻烦 建议使用 Markdown\n示例：\n姓名|技能|排行\n--|:--:|--:\n刘备|蹦迪|大哥\n关羽|骑马|二哥\n张飞|打拳|三弟\n效果：\n\n| 姓名 | 技能 | 排行 |\n| ---- | ---- | ---- |\n| 刘备 | 蹦迪 | 大哥 |\n| 关羽 | 骑马 | 二哥 |\n| 张飞 | 打拳 | 三弟 |\n\n## 九、代码\n\n语法：\n\n单行代码：代码之间分别用一个反引号包起来\n\n```\n`代码内容`\n```\n\n代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n\n```\n\n```\n\n代\n码\n块\n内\n容\n\n```\n\n```\n\n###### 注多行代码也可回车+tap\n\n**单行代码**\n示例：\n\n```\n`这是单行代码`\n```\n\n效果\n`这是单行代码`\n\n**多行代码**\n\n示例：\n\n```\n\n```\n\n这\n是\n多\n行\n代\n码\n\n```\n\n```\n\n效果\n\n```\n这\n是\n多\n行\n代\n码\n```\n\n## 十、流程图\n\n```\nflow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n```\n\n\n\n###### 建议使用画图工具([百度脑图](https://naotu.baidu.com/))画完后上传图片比较简单\n\n\n！[流程图](https://cdn.jsdelivr.net/gh/isome/ialoe-article@master/markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E5%9B%BE.png%22%E6%B5%81%E7%A8%8B%E5%9B%BE%22)\n\n\n\n## 写作工具\n\n\n\n### ①MarkdownPad\n\n\nMarkdownPad被很多人称赞为windows下最好用的Markdown编辑器之一，不过仅支持windows。它有免费版和收费版（MarkdownPad Pro），一般情况下免费版就够用了，想用pro版的可以自行网上下载，强大的国人crack无处不在的~ ~。\n\nMarkdownPad支持键盘快捷键和工具栏操作，即可添加标记也可移除，支持即时HTML预览、支持自定义配色方案、字体、大小和布局、支持音乐视频，可以导出HTML和PDF。\n\nMarkdownPad是独立的软件。\n\n更多介绍及下载：[https://markdownpad.com/](https://markdownpad.com/)\n\n\n\n### ②Typora(亲测)\n\n\nTypora也是非常用名，非常好用的markdown编辑器，它的设计理念很不一样，是真正的即时预览型编辑器，不同于左右两个窗口的编辑器。Typora的设计理念就是极致简洁，它将「写字」和「预览」这两件事情合并了。\n\n如果要修改已经写好的markdown标记可以点击切换到“源代码模式”。\n\nTypora 同样支持 Windows、OS X 和 Linux多个操作系统，支持数学编辑，可与 Word 直接格式转换，可以进行多种文档格式转换。Typora 流畅度和反应速度很快，特别适合那些手速快的人。\n\nTypora是独立的软件。\n\n更多介绍及下载：[https://www.typora.io/](https://www.typora.io/)\n\n\n\n### ③Hbuilder X\n\n\n先hexo s启动本地服务器预览\n可以通过Hbuilder X内置浏览器观察文章内容\n实现边写变预览便于修改\n\n\n\n### ④更多\n\n\nmarkdown编辑器产品非常多，以上只是本人接触过的一些，相信还有很多很好的markdown存在,橘生淮南则为橘，橘生淮北则为枳，找到适合自己的才是最好的。\n\n\n\n###### 注：如果看完还是有不明白或者要补充的地方可以留言或私聊在窗口右下角私聊我\n```\n","tags":["Markdown"],"categories":["学习笔记"]},{"title":"Matery主题友链实现随机排列","url":"/posts/MateryLinks.html","content":"\n# 友链随机排列\n\n## 未添加友链朋友圈\n\n### 友链信息抓取\n\n将`/source/_data/friends.json` 复制至`/source/friends`目录下\n\n> 以后友链信息在/friends/friends.json 中更新\n\n### 更改 friends.ejs\n\n```ejs\n<%- partial('_partial/bg-cover') %>\n<style>\n.card .card-content p {\n    height: 44.8px;\n    line-height: 22.4px\n}\n\n#friends-link {\n    height: auto !important\n}\n\n.friends-container {\n    margin-top: -100px;\n    margin-bottom: 30px;\n}\n\n.friend-div {\n    height: 240px;\n}\n\n.friends-container .tag-title {\n    margin-bottom: 10px;\n    color: #3C4858;\n    font-size: 1.75rem;\n    font-weight: 400;\n}\n\n.frind-ship img {\n    border-radius: 50%;\n}\n\n/* 一下是按钮样式 */\n\n.frind-ship {\n    padding: 10px 20px;\n}\n\n.frind-ship .title {\n    display: flex;\n    align-items: center;\n}\n\n.frind-ship .title div {\n    color: #fff;\n    padding-left: 10px;\n}\n\n.frind-ship .title img {\n    width: 100px;\n    height: 100px;\n    flex-shrink: 0;\n}\n\n.frind-ship .title h1 {\n    padding-bottom: 5px;\n    border-bottom: 2px solid #fff;\n    position: relative;\n    top: -15px;\n    left: 3px;\n}\n\n.friend-button {\n    display: flex;\n    justify-content: center;\n    margin-bottom: -27px;\n}\n\n.friend-button a {\n    border-radius: 40px;\n}\n\n.friend-all .tag-post {\n    margin-bottom: 30px;\n}\n\n.button-caution {\n    background-color: #FF4351;\n    border-color: #FF4351;\n    color: #FFF;\n}\n\n.button {\n    font-weight: 300;\n    font-size: 16px;\n    font-family: \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif;\n    text-decoration: none;\n    text-align: center;\n    line-height: 40px;\n    height: 40px;\n    padding: 0 40px;\n    margin: 0;\n    display: inline-block;\n    appearance: none;\n    cursor: pointer;\n    border: none;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    -webkit-transition-property: all;\n    transition-property: all;\n    -webkit-transition-duration: .3s;\n    transition-duration: .3s;\n}\n\n.title {\n    margin-bottom: 0rem !important;\n}\n\n.card {\n    margin: 3rem 0 1rem 0 !important;\n}\n\n.button-glow.button-caution {\n    -webkit-animation-name: glowing-caution;\n    animation-name: glowing-caution;\n}\n\n@-webkit-keyframes glowing-caution {\n    from {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n\n    50% {\n        -webkit-box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n        box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n    }\n\n    to {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n}\n\n@keyframes glowing-caution {\n    from {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n\n    50% {\n        -webkit-box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n        box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n    }\n\n    to {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n}\n\n.button-caution:hover {\n    background-color: #ff7680;\n    border-color: #ff7680;\n    color: #FFF;\n    text-decoration: none;\n}\n\n.frind-card1 {\n    background-image: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);\n}\n\n.frind-card2 {\n    background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n}\n\n.frind-card3 {\n    background-image: linear-gradient(to right, #b8cbb8 0%, #b8cbb8 0%, #b465da 0%, #cf6cc9 33%, #ee609c 66%, #ee609c 100%);\n}\n\n.frind-card4 {\n    background-image: linear-gradient(to right, #6a11cb 0%, #2575fc 100%);\n}\n\n.frind-card5 {\n    background-image: linear-gradient(to top, #c471f5 0%, #fa71cd 100%);\n}\n\n.frind-card6 {\n    background-image: linear-gradient(to top, #48c6ef 0%, #6f86d6 100%);\n}\n\n.frind-card7 {\n    background-image: linear-gradient(to top, #0ba360 0%, #3cba92 100%);\n}\n\n.frind-card8 {\n    background-image: linear-gradient(to top, #0c3483 0%, #a2b6df 100%, #6b8cce 100%, #a2b6df 100%);\n}\n\n.frind-card9 {\n    background-image: linear-gradient(to right, #ff758c 0%, #ff7eb3 100%);\n}\n\n.frind-card10 {\n    background-image: linear-gradient(to top, #f77062 0%, #fe5196 100%);\n}\n\narticle .card {\n    overflow: visible !important;\n}\n</style>\n\n<main class=\"content\">\n    <div class=\"container friends-container\">\n        <div class=\"card\">\n            <div class=\"card-content\">\n                <div class=\"tag-title center-align\">\n                    <i class=\"fas fa-address-book\"></i>&nbsp;&nbsp;<%= __('friends') %>\n                </div>\n                <article id=\"friends-link\" style=\"position: relative; height: 0px;\">\n                    <div class=\"row tags-posts friend-all\"></div>\n                </article>\n            </div>\n        </div>\n\n        <% if (page.content && page.content.length > 0) { %>\n            <div class=\"card\">\n                <div class=\"card-content\">\n                    <%- page.content %>\n                </div>\n            </div>\n        <% } %>\n\n        <div class=\"card\">\n\n            <% if (theme.gitalk && theme.gitalk.enable) { %>\n            <%- partial('_partial/gitalk') %>\n            <% } %>\n\n            <% if (theme.gitment.enable) { %>\n            <%- partial('_partial/gitment') %>\n            <% } %>\n\n            <% if (theme.disqus.enable) { %>\n            <%- partial('_partial/disqus') %>\n            <% } %>\n\n            <% if (theme.livere && theme.livere.enable) { %>\n            <%- partial('_partial/livere') %>\n            <% } %>\n\n            <% if (theme.valine && theme.valine.enable) { %>\n            <%- partial('_partial/valine') %>\n            <% } %>\n\n            <% if (theme.twikoo && theme.twikoo.enable) { %>\n            <%- partial('_partial/twikoo') %>\n            <% } %>\n\n        </div>\n    </div>\n</main>\n\n<script>\n    function randArr(arr){\n        arr = arr || [];\n        arr.sort(function(){return Math.random()-0.5;});\n        return arr;\n    }\n\n    function initTemplate(List){\n        List = List || [];\n        var total = List.length\n        console.log('friends size ' + total);\n        List.forEach((friend,index) => {\n\n            var tmp = `<div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\">\n                                                    <div class=\"card frind-card${(index % 10 ) +1}  \">\n                                                        <div class=\"frind-ship\">\n                                                            <div class=\"title\">\n                                                                <img src=\"${friend.avatar}\" alt=\"img\">\n                                                                <div>\n                                                                    <h1 class=\"friend-name\">\n                                                                        ${friend.name}\n                                                                    </h1>\n                                                                    <p style=\"position: relative;top: -35px;\">\n                                                                        ${friend.introduction}\n                                                                    </p>\n                                                                </div>\n                                                            </div>\n                                                            <div class=\"friend-button\">\n                                                                <a href=\"${friend.url} \" target=\"_blank\" class=\"button button-glow button-rounded button-caution\">\n                                                                    ${friend.title}\n                                                                </a>\n                                                            </div>\n                                                        </div>\n                                                    </div>\n                                                </div>`;\n            $(\".friend-all\").prepend(tmp);\n        });\n    };\n\n    $(function() {\n        getDate();\n        function getDate() {\n            var temp = '';\n            $.ajax({\n                type: \"get\",//请求方式\n                url: \"/friends/friends.json\",//请求的url\n                dataType: \"json\",//后台数据返回类\n                success: function(res) {//响应成功执行的\n                    var friendss = res;\n                    var friends = randArr(friendss);\n\n                    initTemplate(friends);\n\n                }\n            });\n        }\n\n        $('#friends-link').masonry({\n            itemSelector: '.friend-div'\n        });\n    });\n</script>\n```\n\n## 已添加友链朋友圈\n\n### 更改友链 url\n\n将主题目录下的`_config.yml` 中的友链`url` 从`/friends` 改为 `/links`\n\n### 新建页面\n\n在`/source` 目录下新建文件夹`links`\n\n在`/links` 目录下新建`index.md`\n\n内容如下\n\n```markdown\n---\ntitle: 友情帐\ndate: 2021-03-05 11:02:58\ntype: \"links\"\nlayout: \"links\"\n---\n```\n\n### 友链信息抓取\n\n将`/source/_data/friends.json` 复制至`/source/links`目录下\n\n> 以后友链信息在/friends/friends.json 中更新\n>\n> 朋友圈友链抓取信息在/\\_data/friends.json 中更新\n>\n> 朋友圈友链信息抓取页面还是 friends，只是将 friends 页面进行隐藏，对外展示 links 页面\n\n### 新建 links.ejs\n\n```ejs\n<style>\n.card .card-content p {\n    height: 44.8px;\n    line-height: 22.4px\n}\n\n#friends-link {\n    height: auto !important\n}\n\n.friends-container {\n    margin-top: -100px;\n    margin-bottom: 30px;\n}\n\n.friend-div {\n    height: 240px;\n}\n\n.friends-container .tag-title {\n    margin-bottom: 10px;\n    color: #3C4858;\n    font-size: 1.75rem;\n    font-weight: 400;\n}\n\n.frind-ship img {\n    border-radius: 50%;\n}\n\n/* 一下是按钮样式 */\n\n.frind-ship {\n    padding: 10px 20px;\n}\n\n.frind-ship .title {\n    display: flex;\n    align-items: center;\n}\n\n.frind-ship .title div {\n    color: #fff;\n    padding-left: 10px;\n}\n\n.frind-ship .title img {\n    width: 100px;\n    height: 100px;\n    flex-shrink: 0;\n}\n\n.frind-ship .title h1 {\n    padding-bottom: 5px;\n    border-bottom: 2px solid #fff;\n    position: relative;\n    top: -15px;\n    left: 3px;\n}\n\n.friend-button {\n    display: flex;\n    justify-content: center;\n    margin-bottom: -27px;\n}\n\n.friend-button a {\n    border-radius: 40px;\n}\n\n.friend-all .tag-post {\n    margin-bottom: 30px;\n}\n\n.button-caution {\n    background-color: #FF4351;\n    border-color: #FF4351;\n    color: #FFF;\n}\n\n.button {\n    font-weight: 300;\n    font-size: 16px;\n    font-family: \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif;\n    text-decoration: none;\n    text-align: center;\n    line-height: 40px;\n    height: 40px;\n    padding: 0 40px;\n    margin: 0;\n    display: inline-block;\n    appearance: none;\n    cursor: pointer;\n    border: none;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    -webkit-transition-property: all;\n    transition-property: all;\n    -webkit-transition-duration: .3s;\n    transition-duration: .3s;\n}\n\n.title {\n    margin-bottom: 0rem !important;\n}\n\n.card {\n    margin: 3rem 0 1rem 0 !important;\n}\n\n.button-glow.button-caution {\n    -webkit-animation-name: glowing-caution;\n    animation-name: glowing-caution;\n}\n\n@-webkit-keyframes glowing-caution {\n    from {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n\n    50% {\n        -webkit-box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n        box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n    }\n\n    to {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n}\n\n@keyframes glowing-caution {\n    from {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n\n    50% {\n        -webkit-box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n        box-shadow: 0 0 20px rgba(255, 67, 81, 0.8);\n    }\n\n    to {\n        -webkit-box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n        box-shadow: 0 0 0 rgba(255, 67, 81, 0.3);\n    }\n}\n\n.button-caution:hover {\n    background-color: #ff7680;\n    border-color: #ff7680;\n    color: #FFF;\n    text-decoration: none;\n}\n\n.frind-card1 {\n    background-image: linear-gradient(to right, #4facfe 0%, #00f2fe 100%);\n}\n\n.frind-card2 {\n    background-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n}\n\n.frind-card3 {\n    background-image: linear-gradient(to right, #b8cbb8 0%, #b8cbb8 0%, #b465da 0%, #cf6cc9 33%, #ee609c 66%, #ee609c 100%);\n}\n\n.frind-card4 {\n    background-image: linear-gradient(to right, #6a11cb 0%, #2575fc 100%);\n}\n\n.frind-card5 {\n    background-image: linear-gradient(to top, #c471f5 0%, #fa71cd 100%);\n}\n\n.frind-card6 {\n    background-image: linear-gradient(to top, #48c6ef 0%, #6f86d6 100%);\n}\n\n.frind-card7 {\n    background-image: linear-gradient(to top, #0ba360 0%, #3cba92 100%);\n}\n\n.frind-card8 {\n    background-image: linear-gradient(to top, #0c3483 0%, #a2b6df 100%, #6b8cce 100%, #a2b6df 100%);\n}\n\n.frind-card9 {\n    background-image: linear-gradient(to right, #ff758c 0%, #ff7eb3 100%);\n}\n\n.frind-card10 {\n    background-image: linear-gradient(to top, #f77062 0%, #fe5196 100%);\n}\n\narticle .card {\n    overflow: visible !important;\n}\n</style>\n<%- partial('_partial/bg-cover') %>\n    <main class=\"content\" style=\"min-height: 131px;\">\n        <div class=\"container friends-container\">\n            <div class=\"card\">\n                <div class=\"card-content\">\n                    <div id=\"moments_container\"></div>\n                </div>\n            </div>\n            <div class=\"card\">\n                <div class=\"card-content\">\n                    <div class=\"tag-title center-align\">\n                        <i class=\"fas fa-address-book\"></i>&nbsp;&nbsp;<%= __('friends') %>\n                    </div>\n                    <article id=\"friends-link\" style=\"position: relative; height: 0px;\">\n                        <div class=\"row tags-posts friend-all\"></div>\n                    </article>\n                </div>\n            </div>\n        </div>\n    </main>\n\n    <script>\n        function randArr(arr){\n            arr = arr || [];\n            arr.sort(function(){return Math.random()-0.5;});\n            return arr;\n        }\n\n        function initTemplate(List){\n            List = List || [];\n            var total = List.length\n            console.log('friends size ' + total);\n            List.forEach((friend,index) => {\n\n                var tmp = `<div class=\"col s12 m6 l4 friend-div\" data-aos=\"zoom-in-up\">\n                                                    <div class=\"card frind-card${(index % 10 ) +1}  \">\n                                                        <div class=\"frind-ship\">\n                                                            <div class=\"title\">\n                                                                <img src=\"${friend.avatar}\" alt=\"img\">\n                                                                <div>\n                                                                    <h1 class=\"friend-name\">\n                                                                        ${friend.name}\n                                                                    </h1>\n                                                                    <p style=\"position: relative;top: -35px;\">\n                                                                        ${friend.introduction}\n                                                                    </p>\n                                                                </div>\n                                                            </div>\n                                                            <div class=\"friend-button\">\n                                                                <a href=\"${friend.url} \" target=\"_blank\" class=\"button button-glow button-rounded button-caution\">\n                                                                    ${friend.title}\n                                                                </a>\n                                                            </div>\n                                                        </div>\n                                                    </div>\n                                                </div>`;\n                $(\".friend-all\").prepend(tmp);\n            });\n        };\n\n        $(function() {\n            getDate();\n            function getDate() {\n                var temp = '';\n                $.ajax({\n                    type: \"get\",//请求方式\n                    url: \"/links/friends.json\",//请求的url\n                    dataType: \"json\",//后台数据返回类\n                    success: function(res) {//响应成功执行的\n                        var friendss = res;\n                        var friends = randArr(friendss);\n                        initTemplate(friends);\n\n                    }\n                });\n            }\n\n            $('#friends-link').masonry({\n                itemSelector: '.friend-div'\n            });\n        });\n    </script>\n<script src=\"<%- theme.jsDelivr.url %><%- url_for('/js/moments.js') %>\"></script>\n```\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Git的自我认知","url":"/posts/Git.html","content":"\n### 概述\n\n> Git 是一个开源的**分布式**版本控制系统，用于敏捷高效地处理从很小到非常大的项目版本管理。支持克隆/下载。\n>\n> Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\n>\n> Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n\n### 安装\n\n[下载 git OSX 版](https://git-scm.com/download/mac)\n\n[下载 git Windows 版](https://msysgit.github.io/)\n\n[下载 git Linux 版](https://git-scm.com/download/linux)\n\n安装验证\n\n```bash\ngit -version\n```\n\n### 原理\n\n> 你的本地仓库由 git 维护的三棵“树”组成。\n>\n> 第一个是你的 `工作目录`，它持有实际文件；\n>\n> 第二个是 `暂存区（Index）`，它像个缓存区域，临时保存你的改动；\n>\n> 最后是 `HEAD`，它指向你最后一次提交的结果。\n\n> 工作区：沙箱环境 git 不会管理 随便更改操作\n\n> 暂存区：记录文件的操作\n\n> 版本库：最终的代码实现提交到这里 .git 目录就是版本库\n\n![git_trees](Git/git_trees.png)\n\n### 配置\n\nGit 操作配置的命令：\n\n```bash\ngit  config\n```\n\n1.  –system ：系统中对所有用户都普遍适用的配置。使用 git config --system 命令会修改/etc/gitconfig 文件。\n2.  –global ：用户目录下的配置文件只适用于该用户。使用 git config --global 读写的是~/.gitconfig\n3.  文件不写参数，表示堆当前项目的 git 目录进行配置，使用 git config 可以直接针对当前项目配置，即工作目录下的.git/config 文件\n\n优先级别以就近原则为准。\n\n```\n.git/config` > `~/.gitconfig` > `/etc/gitconfig\n```\n\n#### 初始化配置\n\n安装完成后初始化配置用户名和邮件地址：\n\n```bash\ngit config --_global user.name \"ialoe\"\ngit config --_global user.email \"ialoe@qq.com\"\n```\n\n查看已有配置：\n\n```bash\ngit  config --list\n```\n\n#### 文件大小写问题\n\n**现象：**文件或文件夹大小写导致找不到文件\n\ngit 默认是大小写不敏感的。 如果你大写的文件上次，有可能自己就变小写了。然后访问有可能找不到文件。\n\n查询自己的配置：\n\n```bash\ngit config --get core.ignorecase\n```\n\n配置开启大小写敏感：\n\n(1)全局开启大小写敏感\n\n```bash\ngit config --_global core.ignorecase false\n```\n\n(2)单个项目开启大小写敏感\n\n```bash\ngit config core.ignorecase false\n```\n\n### 仓库\n\n#### 创建仓库\n\n创建新文件夹，打开，然后执行\n`git init`\n以创建新的 Git 仓库。\n\n#### 目录结构\n\n初始化之后，有一个`.git`隐藏文件，里面的目录结构大概如下：\n\n| 文件夹、文件 | 作用                                         |\n| ------------ | -------------------------------------------- |\n| hooks/       | 目录包含服务端或客户端钩子脚本               |\n| info/        | 包含一个全局性排除文件                       |\n| logs/        | 保存日志信息                                 |\n| objects/     | 目录存储所有数据内容，`重要`                 |\n| refs/        | 目录存储指向数据提交对象的指针，分支，`重要` |\n| config       | 文件包含项目特有的配置选项，`重要`           |\n| description  | 用来显示对仓库的描述信息                     |\n| HEAD         | 文件指示目前被检出的分支，`重要`             |\n| index        | 文件保存暂缓区信息，`重要`                   |\n\n#### 检出仓库\n\n执行如下命令以创建一个本地仓库的克隆版本：\n`git clone /path/to/repository`\n\n```bash\n# 将E盘下的Repository克隆到D盘\ngit clone E:/SourceRepository D:/DestinationRepository\n```\n\n如果是远端服务器上的仓库，你的命令会是这个样子：\n`git clone username@host:/path/to/repository`\n\n##### 已配置账户\n\n`git clone git@host:/path/to/repository`\n\n```bash\n# 以我的GitHub的BlogCode仓库为例\ngit clone git@github.com:ialoe/BlogCode.git\n```\n\n##### 未配置账户\n\n`git clone 用户名@github.com:ialoe/BlogCode.git`\n\n然后按回车键执行 `git clone` 命令， Git 会提示你输入密码。\n\n```bash\n# 以我的GitHub的BlogCode仓库为例\ngit  clone   ialoe @ https://github.com/ialoe/BlogCode.git\n```\n\n##### 指定分支\n\n我们可以通过-b 来指定要克隆的分支名\n\n`git clone -b <name> git@host:/path/to/repository`\n\n#### 添加提交\n\n你可以提出更改（把它们添加到暂存区），使用如下命令：\n`git add <filename>` 或者 `git add *`\n\n这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：\n`git commit -m \"代码提交信息\"`\n现在，你的改动已经提交到了 **HEAD**，但是还没到你的远端仓库。\n\n#### 推送改动\n\n你的改动现在已经在本地仓库的 **HEAD** 中了。执行如下命令以将这些改动提交到远端仓库：\n`git push origin master` or `git push`\n可以把 _master_ 换成你想要推送的任何分支。\n\n如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：\n`git remote add origin <server>`\n如此你就能够将你的改动推送到所添加的服务器上去了。\n\n若需强制推送 `git push -f` 《不建议》\n\n### Git 基础命令\n\n#### git init\n\n**初始化工作空间**\n\n初始化工作目录命令格式：\n\n```bash\ngit init\n```\n\n生成 `.git` 目录，所有 git 需要的数据和资源都存在在这个目录。\n\n#### git add\n\n跟踪已修改文件到暂存区：\n\n跟踪一个已修改文件到暂存区的命令格式：\n\n```bash\ngit add ./\n```\n\ngit add 命令将修改的文件生成 git 对象，加入暂存区。\n\n过程：将将修改的文件生成成 git 对象，放入版本库，再将 Git 对象加入到暂存区，只是没有生成树对象。在这个过程中，生成 Git 对象是增量式的。\n\n相当于执行了 N 次（N 个文件）：\n\n```\ngit hash-object -w\ngit update-index\n```\n\n#### git status\n\n跟踪文件状态：\n\n```bash\ngit status [指定的文件]\n```\n\nstatus ：\n\n- `untracked`：未跟踪，红色\n- `tracked` ：已跟踪。\n  - `unmodified`：未修改，已提交，一般不列出显示。\n- `modified`：已修改，红色\n  - `staged` ： 已暂存，绿色\n\n跟踪新文件：\n\n`git add` 命令执行之后使用 `git status`查看，出现`changes to be committed` 表示已经暂存。\n\n暂存已修改文件：\n\n已经暂存的文件进行再次修改，使用 `git status`查看，此时会出现\n\n`changes to be committed` 表示该文件之前暂存区有一份，表示已暂存；同时也会出现\n\n`changes not staged for commit` 表示改文件又有了新的修改。此时已修改文件的状态为`modified`；修改之后的 git 对象还没有生成。如果`git add` 重新暂存，在暂存区则会进行覆盖操作，并重新生成 git 对象的 hash。\n\n#### git diff\n\n查看已暂存和未暂存的更新：\n\n`git status` 仅仅列出修改过的文件。\n\n- 判断当前做的哪些更新还没有做暂存：\n\n```bash\ngit diff\n```\n\n- 判断哪些更新已经暂存准备好了下次提交\n\n```bash\ngit diff --cached\n\n# 1.6 以上\ngit diff --staged\n```\n\n示例：查看哪些暂存还没提交的数据，这是之前操作的数据。\n\n```bash\ngit diff --cached\ndiff --git a/bak/xctest.txt b/bak/xctest.txt\nnew file mode 100644\nindex 0000000..83baae6\n--- /dev/null\n+++ b/bak/xctest.txt\n@@ -0,0 +1 @@\n+version 1\ndiff --git a/new.txt b/new.txt\nnew file mode 100644\nindex 0000000..eae6142\n--- /dev/null\n+++ b/new.txt\n@@ -0,0 +1 @@\n+new v1\ndiff --git a/xctest.txt b/xctest.txt\nnew file mode 100644\nindex 0000000..0b6ca5d\n--- /dev/null\n+++ b/xctest.txt\n@@ -0,0 +1,2 @@\n+version 1\n+xiaocai v2\n```\n\n#### git commit\n\n提交文件：\n\n```bash\ngit commit\n```\n\n没有参数会进入一个注释文件可以写大段注释。\n\n```bash\n git commit -m \" messgae info\"\n```\n\n`-m` 一般写短小文字较少的注释。注释建议，带上关键信息，如完成进度，fix bug\n\n2 条命令都是提交项目版本到本地库，生成树对象和提交对象。\n\n相当于执行：\n\n```bash\ngit write-tree\ngit commit-tree\n```\n\n跳过使用暂存区域：\n\n```bash\ngit commit -a -m \"xiaocai test\"\n```\n\n通过`-a` 参数，git 可以自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过`git add`步骤。\n\n注意：使用 -a 的前提是文件状态要已经被跟踪。\n\n#### git rm\n\n移除文件：\n\n从 Git 中移除文件，就必须要从已跟踪文件清单中注册删除，其实就是从暂存区注册删除，然后提交。可以使用以下命令完成：\n\n```bash\ngit rm\n```\n\n该命令将把文件从暂存区注册删除，并且同时从工作目录删除对应的文件，这样文件就不会出现在未跟踪文件清单中。\n\n需要注意的是，删除之后进行`git add` 和 `git commit`操作，对应的 Git 对象永远不会删除，暂存区删除之后，版本库里进行的是新增操作，新增的是一个没有内容的 git 对象和一个树对象。如果要找回，可以找到对应的提交对象 hash，回退即可。\n\n如果我们先手工删除了文件，可以执行`git rm` 即可，相当于执行了`git add ./` 和 `git commit` 也可以手工执行\n\n```bash\ngit add ./\ngit commit`\n```\n\n其实就是删除工作目录中对应的文件，再将修改添加到暂存区。`git rm`\n\n#### git mv\n\n文件改名：\n\ngit 文件修改文件名称命令\n\n```bash\n# 重命名操作\ngit mv oldfile.suffix1  newfile.suffix2\n```\n\n使用，新建一个文件然后提交：\n\n```bash\n# 新建xiaocai.txt\necho \"xiaocai de wen jian\" > xiaocai.txt\n\n#git add\ngit commit -a -m \"new a file test\"\n\n# 再执行重命名操作\ngit mv xiaocai.txt  xc.txt\n```\n\n`git rm` 在旧的版本中类似相当于执行了三条命令：\n\n```bash\nmv xiaocai.txt  xc.txt\ngit rm  xiaocai.txt\ngit add  xiaocai.txt\n```\n\n我的 git 版本比较新，新的版本 status 显示的是 renamed，暂时没注意过程，后续清楚了再补上。`**TODO**`\n\n查看状态，此时是 renamed 状态，属于修改操作，\n\n```bash\ngit status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n        renamed:    xiaocai.txt -> xc.txt\n```\n\n`**git mv file1 file2**` 其实就是将工作目录中的文件进行重命名，再将修改添加到暂存区。\n\n#### git log\n\n查看历史记录：\n\n在提交很多更新之后，想回顾查看提交历史，或者回退历史版本时，使用该命令。\n\n```bash\ngit log\n```\n\n没有参数会按提交时间列出所有更新，最近在上面，倒序排列。\n\n示例：\n\n```bash\n$ git log\ncommit c32a601099e6ca73b910829856bc4b1ba88c014e (HEAD -> master)\nAuthor: small-rose <small-rose@qq.com>\nDate:   Mon Nov 16 19:57:12 2020 +0800\n\n    rename xiaocai.txt to xc.txt\n\ncommit d57678e00b1dea5ce92817f5ca495c2dc852496c\nAuthor: small-rose <small-rose@qq.com>\nDate:   Mon Nov 16 19:54:07 2020 +0800\n\n    new a file test\n\ncommit 4e84326e84545905f106975a4ce32eb520b4bc98\nAuthor: small-rose <small-rose@qq.com>\nDate:   Mon Nov 16 19:46:44 2020 +0800\n\n    first commit\n```\n\n按下箭头翻页， 按 `q` 退出。如果要回退，利用提交对象的 hash 即可。\n\n不方便看还可以进行格式化显示：\n\n```bash\ngit log --pretty=oneline\ngit log --oneline\n```\n\n效果：\n\n```bash\n$ git log --pretty=oneline\nc32a601099e6ca73b910829856bc4b1ba88c014e (HEAD -> master) rename xiaocai.txt to xc.txt\nd57678e00b1dea5ce92817f5ca495c2dc852496c new a file test\n4e84326e84545905f106975a4ce32eb520b4bc98 first commit\n\n\n$ git log --oneline\nc32a601 (HEAD -> master) rename xiaocai.txt to xc.txt\nd57678e new a file test\n4e84326 first commit\n```\n\n### 分支\n\n> Git 分支模型高效轻量。Git 亮点技能。\n>\n> 分支就是一个提交对象前面的指针，每次提交完成，指针就在提交对象的前面指向最新提交\n>\n> 分支是用来将特性开发绝缘开来的。\n>\n> 在你创建仓库的时候，`master` 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n\n> GitHub 已将默认分支 master 更改为 main\n\n![git_branches](Git/git_branches.png)\n\n#### 创建分支\n\n基础命令\n\n```bash\ngit branch\n```\n\n没有参数时，显示分支列表。\n\n后面带参数时，表示创建分支命令：\n\n```bash\ngit branch  dev\n```\n\n执行之后，查看日志\n\n```bash\ngit log --oneline\n```\n\n新建新的分支并切换到该分支上（一步到位式）\n\n```bash\ngit checkout -b  dev_test\n# 执行结果\nSwitched to a new branch 'dev_test'\n```\n\n#### 查看分支\n\n```bash\n$ git log --oneline --decorate --graph --all\n```\n\n#### 切换分支\n\n```bash\ngit checkout dev\n```\n\n切换成功后 Git 的路径会有变化\n\n执行之后，查看日志\n\n```bash\ngit log --oneline\n```\n\n在新的`dev` 分支进行操作开发\n\n在文件夹处右键==》Git Bash Here\n\n```bash\ngit add ./\n\ngit commit -m \"add dev code \"\n```\n\n执行后查看日志\n\n```bash\ngit log --oneline\n\n37c967e (HEAD -> dev) add dev code\n```\n\n> 注意事项\n>\n> 1. 每次切换分支前，当前分支一定是干净的（所有文件都是已提交状态）。所以在切换分支前使用 git status 命令验证状态。\n> 2. 问题发生于在切换分支时，如果当前分支上有未暂存的修改（一般是第一次）或者有未提交的暂存（一般是第一次），分支可以切换成功，但是会对其他分支造成污染。\n\n#### 删除分支\n\n删除之前一定要先切换分支\n\n```bash\ngit checkout master\n```\n\n切换成功后，显示 master 分支\n\n```bash\ngit log --oneline\n```\n\n删除分支命令：\n\n```bash\ngit branch -d name\n```\n\n#### 其他分支相关\n\n##### 查看每个分支最后一次提交\n\n```bash\ngit branch -v\n```\n\n##### 新建一个分支并且使分支指向对应的提交对象\n\n```bash\ngit branch  name commitHash\n```\n\n> 示例\n>\n> 现在创建一个分支想回第一次提交的时候看看代码怎么写的\n>\n> 此时新的 first 分支语句出现了，可以切换过去看看：\n\n```bash\n# 当前是master分支\ngit log --oneline\nc32a601 (HEAD -> master) rename blog.txt to xc.txt\nd57678e new a file test\n4e84326 first commit\n```\n\n```bash\ngit branch  first 4e84326\n# 新的分支出现了\ngit log --oneline\nc32a601 (HEAD -> master) rename xiaocai.txt to xc.txt\nd57678e new a file test\n4e84326 (first) first commit\n```\n\n```bash\n# 切换分支\ngit checkout first\nSwitched to branch 'first'\n\n# 现在进入了 first分支\ngit log --oneline\n4e84326 (HEAD -> first) first commit\n```\n\n##### 查看哪些分支已经合并到当前分支\n\n```bash\ngit branch  -merged\n```\n\n在这个列表中分支名字前面没有`*`号的分支通常可以使用`git branch -d` 删除掉。\n\n##### 查看所有包含未合并工作的分支\n\n```bash\ngit branch --no-merged\n```\n\n尝试使用`git branch -d` 删除在这个列表中的分支时会失败。\n\n如果真的确定要删除分支，可以使用`git branch -D` 进行强制删除。\n\n**分支的本质是一个提交对象，HEAD 是一个指针，它默认指向 master，切换分支时，其实就是让 HEAD 指向不同的分支。每次有新的提交时，HEAD 都会带着当前指向的分支一起往前移动。**\n\n#### 撤销重置\n\n**撤销命令**\n\n```bash\ngit commit -amend\n```\n\n该命令将暂存区的文件提起，如果上次提交以来你还未做任何修改，在你提交后马上执行此命令，那么快照会保持不变，而你所修改的只是提交信息。\n\n如果提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n```bash\ngit commit -m 'some desc'\ngit add forgeotten_file\ngit commit -amend\n```\n\n最终只会有一个提交，第二次提交将代替第一次提交的结果。\n\n**重置命令**\n\n```\ngit reset HEAD  文件名\n```\n\n#### 配置别名\n\nGit 没有自动推断命令功能，有些命令比较长，不想每次输入完整的命令，可以通过`git config`文件来轻松为每个命令设置一个别名。\n\n```\ngit config --global alias.co  checkout\ngit config --global alias.br  branch\ngit config --global alias.cm  commit\ngit config --global alias.st  status\n```\n\n如果需要执行`git commit` 只需要输入 `git cm` 即可。\n\n对于复杂命令，比如查看完整的分支图的命令：\n\n```bash\ngit log --oneline --decorate --graph --all\n```\n\n执行结果：\n\n```bash\ngit log --oneline --decorate --graph --all\n* 37c967e (dev) add dev code\n* c32a601 (master) rename blog.txt to i.txt\n* d57678e new a file test\n* 4e84326 (HEAD -> first) first commit\n```\n\n将该命令配置别名时需要带上双引号：\n\n```bash\ngit config --_global alias.blog  \"log --oneline --decorate --graph --all\"\n```\n\n### Git 管理仓库(以 Github 为例)\n\n#### 创建新的仓库然后提交\n\n```bash\necho \"# 仓库名\" >> README.md\ngit init\ngit add README.md\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/用户名/仓库名.git\ngit push -u origin main\n```\n\n#### 提交一个已经存在的仓库\n\n```bash\ngit remote add origin https://github.com/用户名/仓库名.git\ngit branch -M main\ngit push -u origin main\n```\n\n#### Git 的免密使用\n\n##### 客户端生成密钥\n\n```bash\nssh-keygen -t rsa -C \"这里换上你的邮箱\"\n```\n\n然后会出现询问，大概意思如下：\n\n```\n1. 确认秘钥的保存路径（如果不需要改路径则直接回车）；\n2. 如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；\n3. 创建密码（如果不需要密码则直接回车）；\n4. 确认密码；\n```\n\n要免密登录请输密码的时候回车即可。根据提示找到密钥所在文件：\n\n```\nid_rsa  #私钥\nid_rsa.pub  #公钥\n```\n\n> Github 配置 SSH 公钥登录 git 账户，Setting，SSH and GPG keys, New ssh key 把 id_rsa.pub 的内容粘贴到 key 的文本域，点击 Add SSH key 完成。后续的客户端 git 操作就不要密码了。\n>\n> 然后回到 Git 的命令行界面，测试一下是否与 Github 连接成功。输入下面的命令行：\n>\n> 点击回车，然后会出现一个询问内容，输入 `yes`，回车，会出现一段内容，`Hi ! You've successfully authenticated, but GitHub doesnot provide shell access.`。 说明连接成功。此处这个 `` 应该是你 Github 的用户名。\n\n```shell\nssh -T git@github.com\n```\n\n##### 服务器配置 SSH 免密\n\n注意：这里的 Git 服务器可以是云服务器或者自己的私服务器。本次操作环境是`Centos 7`。\n\n###### 1. 客户端生成密钥\n\n> 注意：同上，如果已经配置过`Github`的 ssh 免密上面已经有了可以不用重复生成，可以直接跳到第二步。\n\n###### 2. 服务端导入客户端公钥\n\n在/home/git 下已经创建.ssh 目录，然后创建 authorized_keys 文件，并将客户端生成的公钥导入进去。\n\n```bash\ncd /home/git/\nmkdir .ssh\nchmod 755 .ssh\ntouch .ssh/authorized_keys\nchmod 644 .ssh/authorized_keys\n```\n\n将 `id_rsa.pub` 文件的内容写入`authorized_keys`\n\n###### 3. 服务端`SSH`开启`RSA`认证\n\n如果没有安装 SSH 服务，请先安装 SSH 服务。\n\n```bash\nvim /etc/ssh/sshd_config\n```\n\n其中三个地方的设置要确认如下：\n\n```bash\nRSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys\n```\n\ngit 用户不允许登录 shell\n\n```bash\nvim /etc/passwd\n```\n\n将\n\n```bash\ngit:x:502:502::/home/git:/bin/bash\n```\n\n改为\n\n```bash\ngit:x:502:502::/home/git:/usr/local/git/bin/git-shell\n```\n","tags":["Git"],"categories":["学习笔记"]},{"title":"vagrant快速创建Linux","url":"/posts/VagrantCreateLinux.html","content":"\n# 利用 Vagrant 快速搭建 linux 虚拟机\n\n## 下载并安装 VM VirtualBox\n\n官方下载地址 [传送门](https://www.virtualbox.org/wiki/Downloads)\n\n微云下载 [传送门](https://share.weiyun.com/oNxWsvB1)\n\n安装过程同普通软件安装一样，选择安装路径即可\n\n## 下载并安装 Vagrant\n\n官方下载地址 [传送门](https://www.vagrantup.com/downloads) （翻墙者推荐使用）\n\n微云下载 [传送门](https://share.weiyun.com/bsY62EZ3) （推荐使用）\n\n安装过程同普通软件安装一样，选择安装路径即可\n\n## 使用 Vagrant\n\n### 检验 Vagrant 是否安装成功\n\n打开命令行输入命令`vagrant`\n\n```shell\nvagrant # 出现大段命令提示即为成功\n```\n\n### 初始化操作系统以 centos/7 为例以 centos/7 为例\n\n更多操作系统镜像仓库\n\n在此以 centos/7 为例\n\n命令行中输入命令 `vagrant init 镜像名`\n\n```shell\n# centos/7为cmd命令行相对路径下的box\nvagrant init centos/7 #初始化centos/7镜像操作系统\n\n# 若下载过慢可使用中科大镜像\nvagrant init centos7 https://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7.box\n```\n\n初始化成功后会在 cmd 运行目录中出现文件 `Vagrantfile`\n\n### 启动虚拟机\n\ncmd 中输入命令 `vagrant up` 启动虚拟机\n\n运行至 `Rsyncing folder: /cygdrive/c/Users/L => /vagrant` 这行命令时使用 `Ctrl+C` 结束运行\n\n### 运行并使用虚拟机\n\n若**VirtualBox** 打开并运行虚拟机即可使用 `vagrant ssh` 命令进行操作\n\n## 开机后快速启动并使用虚拟机\n\n**VirtualBox** 未打开可在 cmd 中使用命令 `vagrant up` 启动虚拟机后再使用命令 `vagrant ssh` 登陆后对虚拟机进行操作\n","tags":["Linux","Vagrant"],"categories":["学习笔记"]},{"title":"JDBC-防SQL注入","url":"/posts/JDBCDefenseSQLInjection.html","content":"\n# JDBC-防 SQL 注入\n\n## SQL 注入\n\n> SQL 注入是指 web 应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在 web 应用程序中事先定义好的查询语句的结尾上添加额外的 SQL   语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息，甚至篡改数据库\n\n### 正确账户密码案例代码\n\n```java\n    // 使用正确的用户名和密码登录成功\n    @Test\n    public void testLogin() {\n        String sql = \"select * from account where username = '张三' and password = '123456';\";\n\n        ResultSet resultSet = JdbcUtils.executeQuery(sql);\n\n        try {\n            if (resultSet.next()) {\n                System.out.println(\"登录成功\");\n            } else {\n                System.out.println(\"登录失败\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(resultSet);\n        }\n    }\n```\n\n### 错误账户密码案例代码\n\n```java\n// 通过SQL注入使用异常的密码登录成功\n    @Test\n    public void testSqlInject() {\n        String sql = \"select * from account where username = '张三' and (password = 'iglrne' or 1 = 1);\";\n\n        ResultSet resultSet = JdbcUtils.executeQuery(sql);\n\n        try {\n            if (resultSet.next()) {\n                System.out.println(\"登录成功\");\n            } else {\n                System.out.println(\"登录失败\");\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            JdbcUtils.close(resultSet);\n        }\n    }\n```\n\n### 重点总结\n\n> 【注意】Statement 存在 SQL 注入问题，而 PreparedStatement 可以有效的避免 SQL 注入！\n>\n> 以后只能使用 PreparedStatement ，因为操作性更强，并且安全性更高\n\n## 通过 PreparedStatement 操作 SQL 语句\n\nPreparedStatement 实例包含已编译的 SQL 语句。这就是使语句“准备好”。包含于 PreparedStatement 对象中的 SQL 语句可具有一个或多个  IN 参数。IN 参数的值在 SQL 语句创建时未被指定。相反的，该语句为每个 IN 参数保留一个问号（“？”）作为[占位符](https://baike.baidu.com/item/%E5%8D%A0%E4%BD%8D%E7%AC%A6)。每个问号的值必须在该语句执行之前，通过适当的 setXXX 方法来提供。\n\n由于 PreparedStatement 对象已[预编译](https://baike.baidu.com/item/%E9%A2%84%E7%BC%96%E8%AF%91)过，所以其执行速度要快于 Statement 对象。因此，多次执行的 SQL 语句经常创建为 PreparedStatement 对象，以提高效率。\n\n作为 Statement 的子类，PreparedStatement 继承了 Statement 的所有功能。另外它还添加了一整套方法，用于设置发送给数据库以取代 IN 参数[占位符](https://baike.baidu.com/item/%E5%8D%A0%E4%BD%8D%E7%AC%A6)的值。同时，三种方法 execute、 executeQuery 和 executeUpdate 已被更改以使之不再需要参数。这些方法的 Statement 形式（接受 SQL 语句参数的形式）不应该用于 PreparedStatement 对象。\n\n> 【注意】应该始终以 PreparedStatement 代替 Statement，也就是说，在任何时候都不要使用 Statement。\n\n### PreparedStatement 查询操作\n\n```java\n@Test\n    public void testPreparedStatement() {\n        // 获取数据库连接\n        Connection connection = JdbcUtils.getConnection();\n\n        // 提取资源\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n\n        // 准备SQL语句，? 是占位符\n        String sql = \"select * from account where username = ? and password = ?;\";\n\n        try {\n            // 获取预处理搬运工对象，并对SQL语句进行预处理\n            preparedStatement = connection.prepareStatement(sql);\n\n            // 设置参数\n            preparedStatement.setObject(1, \"张三\");\n            preparedStatement.setObject(2, \"123456\");\n\n            // 执行SQL语句\n            resultSet = preparedStatement.executeQuery();\n\n            // 判断是否还有数据\n            if (resultSet.next()) {\n                System.out.println(\"登录成功\");\n            } else {\n                System.out.println(\"登录失败\");\n            }\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            JdbcUtils.close(resultSet, preparedStatement, connection);\n        }\n    }\n```\n\n### PreparedStatement 增加操作\n\n```java\n @Test\n    public void testInsert() {\n        // 准备SQL语句\n        String sql = \"insert into student(name, age, gender, info) values(?, ?, ?, ?)\";\n\n        // 获取连接\n        Connection connection = JdbcUtils.getConnection();\n\n        PreparedStatement preparedStatement = null;\n\n        try {\n            // 获取预处理对象\n            preparedStatement = connection.prepareStatement(sql);\n\n            // 设置参数\n            preparedStatement.setObject(1, \"赵四\");\n            preparedStatement.setObject(2, 17);\n            preparedStatement.setObject(3, \"男\");\n            preparedStatement.setObject(4, \"你愁啥\");\n\n            // 执行SQL语句\n            int affectedRows = preparedStatement.executeUpdate();\n\n            System.out.println(\"受影响的行数：\" + affectedRows);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            JdbcUtils.close(preparedStatement, connection);\n        }\n    }\n```\n\n### PreparedStatement 修改操作\n\n```java\n @Test\n    public void testUpdate() {\n        // 准备SQL语句\n        String sql = \"update student set age = ? where id = ?\";\n\n        // 获取连接\n        Connection connection = JdbcUtils.getConnection();\n\n        PreparedStatement preparedStatement = null;\n\n        try {\n            // 获取预处理对象\n            preparedStatement = connection.prepareStatement(sql);\n\n            // 设置参数\n            preparedStatement.setObject(1, 61);\n            preparedStatement.setObject(2, 6);\n\n            // 执行SQL语句\n            int affectedRows = preparedStatement.executeUpdate();\n\n            System.out.println(\"受影响的行数：\" + affectedRows);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            JdbcUtils.close(preparedStatement, connection);\n        }\n    }\n```\n\n### PreparedStatement 删除操作\n\n```java\n@Test\n    public void testDelete() {\n        // 准备SQL语句\n        String sql = \"delete from student where id = ?\";\n\n        // 获取连接\n        Connection connection = JdbcUtils.getConnection();\n\n        PreparedStatement preparedStatement = null;\n\n        try {\n            // 获取预处理对象\n            preparedStatement = connection.prepareStatement(sql);\n\n            // 设置参数\n            preparedStatement.setObject(1, 3);\n\n            // 执行SQL语句\n            int affectedRows = preparedStatement.executeUpdate();\n\n            System.out.println(\"受影响的行数：\" + affectedRows);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            JdbcUtils.close(preparedStatement, connection);\n        }\n    }\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"JDBC","url":"/posts/JDBC.html","content":"\n# JDBC\n\n## 通过 JDBC 连接 MySQL 数据库\n\n#### 前提条件\n\n```\n1、jar包：连接驱动包 【mysql-connector-java-5.1.47.jar】\n\n2、url：确定连接的数据库所在网络地址和对应操作哪一个数据库，由协议名+子协议名+数据源名构成，即\n        jdbc:mysql://主机地址:端口号/数据库名\n\n        【例】jdbc:mysql://localhost:3306/islu\n\n3、user：用户名 【root】\n\n4、password：密码 【root】\n```\n\n#### 步骤\n\n```\n1、加载驱动\n2、准备必要的连接参数\n3、获取数据库连接\n4、关闭资源！！！\n```\n\n#### 案例代码【测试连接】\n\n```java\npackage JDBC;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo1 {\n    /**\n     * 1、加载驱动\n     * 2、准备必要的连接参数\n     * 3、获取数据库连接\n     * 4、关闭资源！！！\n     */\n    public static void main(String[] args) {\n\n        Connection connection = null;\n        //加载驱动\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //准备必要的连接参数\n            //声明连接数据库所需要的参数，包括但不限于IP地址、端口号、连接到哪个数据库以及相关参数、用户名、密码\n            String url = \"jdbc:mysql://localhost:3306/islu?useSSL=true&characterEncoding=utf8\";\n            String user = \"root\";\n            String password = \"root\";\n            connection = DriverManager.getConnection(url, user, password);\n            System.out.println(connection);\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n```\n\n> 【注意】连接数据库可以配置一些相关的参数，数据库名与参数之间用 [?](file:///C:/Users/islu/Desktop/ialoe.github.io-master/posts/46.html) 进行分隔，参数之间通过 [&](file:///C:/Users/islu/Desktop/ialoe.github.io-master/posts/46.html) 分隔，常用参数及格式如下\n\n| 参数                         | 描述                                                                                                       |\n| ---------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| characterEncoding=utf8       | 设置字符集为 UTF8                                                                                          |\n| serverTimezone=Asia/Shanghai | 设置时区[（JDBC8.0 以上必备）](file:///C:/Users/islu/Desktop/ialoe.github.io-master/posts/46.html)         |\n| useSSL=true                  | 使用 SSL[（JDBC8.0 以上要改为 false）](file:///C:/Users/islu/Desktop/ialoe.github.io-master/posts/46.html) |\n\n```java\njdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai\n```\n\n## 数据库驱动加载过程\n\n```java\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver {\n    /*\n     * Register ourselves with the DriverManager\n     * 在.class文件加载到内存时运行，并且有且只执行一次\n     * 代码初始化过程！！！\n     */\n    static {\n        try {\n            // DriverManager驱动管理器注册了当前com.mysql.jdbc.Driver\n            // 相对于当前Java程序拥有了连接MySQL数据库的必要的驱动条件\n            java.sql.DriverManager.registerDriver(new Driver());\n        } catch (SQLException E) {\n            throw new RuntimeException(\"Can't register driver!\");\n        }\n    }\n\n    /**\n     * Construct a new driver and register it with DriverManager\n     *\n     * @throws SQLException\n     *             if a database error occurs.\n     */\n    public Driver() throws SQLException {\n        // Required for Class.forName().newInstance()\n    }\n}\n```\n\n> 【注意】后续会用到静态代码块去完成一些初始化的操作\n\n### JDBC 核心 API\n\n```java\n// 驱动管理类\nclass java.sql.DriverManager\n\n/*\n * 这里是根据数据库连接URL，对应的user用户名和password密码，获取数据库连接对象\n */\nstatic java.sql.Connection getConnection(String url, String user, String password);\n\n// 数据库连接接口\ninterface java.sql.Connection\n\n/*\n * 获取数据库SQL语句搬运工对象，从Java程序搬运SQL语句到数据库中，同时Statement也是一个资源对象。\n */\njava.sql.Statement createStatement();\n\n/*\n * 获取数据库SQL语句【预处理】搬运工对象，Java程序的SQL语句，在创建PreparedStatement对象时，将SQL语句交给数据库预处理操作，可以解决一定的【SQL语句注入问题】，同时提高一定的效率，PreparedStatement也是一个资源对象\n */\njava.sql.PreparedStatement prepareStatement(String sql);\n\n// 数据库SQL语句搬运工对象接口\ninterface java.sql.Statement\n\n/*\n * 执行数据库修改数据，insert,update,delete...，返回值类型是int类型，是当前SQL语句搬运到数据库执行之后，数据库运行对于当前操作受到影响的行数\n * 2 rows affected in 5 ms\n */\nint executeUpdate(String sql);\n\n/*\n * 执行数据库查询语句，select操作，执行的结果是一个java.sql.ResultSet，结果集对象，当前操作返回值never null\n */\njava.sql.ResultSet executeQuery(String sql);\n\n// 数据库SQL语句【预处理】搬运工对象接口\npublic interface java.sql.PreparedStatement extends java.sql.Statement\n\n/*\n * 执行数据库修改操作，insert，update，delete...处理的SQL语句是在创建PreparedStatement对象过程预处理的SQL语句，并且返回值是int类型，为当前操作对于数据表中收到影响的行数\n */\nint executeUpdate();\n\n/*\n * 执行数据库查询语句，select操作，的SQL语句是在创建PreparedStatement对象过程预处理的SQL语句，执行的结果是一个java.sql.ResultSet，结果集对象，当前操作返回值never null\n */\njava.sql.ResultSet executeQuery();\n\n/*\n * PreparedStatement预处理的SQL语句是可以带有参数的，这里是对于SQL语句参数进行赋值操作，这里有指定的操作下标，和对应的数据，数据类型繁多\n */\nsetXXX(int index, XXX value)\n\n// 数据库结果集接口\ninterface java.sql.ResultSet\n\n/*\n * 根据查询结果中，字段所处的位置下标获取对应数据，XXX是指定类型(int、String用的最多)\n */\nXXX getXXX(int columnIndex);\n\n/*\n * 根据查询结果中，字段所处的字段名获取对应数据，XXX是指定类型(int、String用的最多)\n * 例int getInt(String columnLabel)\n */\nXXX getXXX(String columnLabel);\n\n/*\n * 判断当前查询结果集中是否还有数据可以继续遍历，如果没有。或则当前结果集中是无数据情况 Empty Set，直接返回fasle\n */\nboolean next();\n```\n\n### Statement 操作 SQL 语句\n\n#### 增删改操作步骤【重点】\n\n```\n1、加载驱动\n2、准备连接数据库所需要的参数\n3、获取数据库连接\n4、获取Statement搬运工对象\n5、准备SQL语句\n6、执行SQL语句获取受影响的行数\n```\n\n#### Statement 插入 SQL 数据操作\n\n```java\npackage JDBC;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class Demo2 {\n    /**\n     * 1、加载驱动\n     * 2、准备连接数据库所需要的参数\n     * 3、获取数据库连接\n     * 4、获取Statement搬运工对象\n     * 5、准备SQL语句\n     * 6、执行SQL语句获取受影响的行数\n     */\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n        //加载驱动\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //准备连接所需参数\n            String url = \"jdbc:mysql://localhost:3306/islu?useSSL=true&characterEncoding=utf8\";\n            String user = \"root\";\n            String password = \"root\";\n            //获取数据库连接\n            connection = DriverManager.getConnection(url, user, password);\n            // 获取Statement对象\n            statement = connection.createStatement();\n            //准备SQL语句\n            String sql = \"insert into user(uname,upassword) values('islu','islu.cn');\";\n            //执行SQL语句\n            int affectedRows = statement.executeUpdate(sql);\n            System.out.println(\"受影响的行数\" + affectedRows);\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (statement != null) {\n                    statement.close();\n                }\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### Statement 修改 SQL 数据操作\n\n```java\npackage JDBC;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class Demo3 {\n    /**\n     * 1、加载驱动\n     * 2、准备连接数据库所需要的参数\n     * 3、获取数据库连接\n     * 4、获取Statement搬运工对象\n     * 5、准备SQL语句\n     * 6、执行SQL语句获取受影响的行数\n     */\n    public static void main(String[] args) {\n        Connection connection=null;\n        Statement statement=null;\n        //加载驱动\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            //获取连接数据库所需要的参数\n            String url=\"jdbc:mysql://localhost:3306/islu?useSSL=true&characterEncoding=utf8\";\n            String user=\"root\";\n            String password=\"root\";\n            //获取数据库连接\n            connection = DriverManager.getConnection(url, user, password);\n            //获取Statement搬运工对象\n            statement = connection.createStatement();\n            //准备SQL语句\n            String sql=\"update user set uname = '彭于晏' where uid = 1;\";\n            //执行SQL语句\n            int affectedRows = statement.executeUpdate(sql);\n            System.out.println(affectedRows);\n        } catch (ClassNotFoundException| SQLException e) {\n            e.printStackTrace();\n        }finally {\n            try {\n                if (connection!=null){\n                connection.close();\n                }\n                if (statement!=null){\n                    statement.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### Statement 删除 SQL 数据操作\n\n```java\npublic class Demo4 {\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n\n        try {\n            // 加载驱动\n            Class.forName(\"com.mysql.jdbc.Driver\");\n\n            // 声明连接数据库所需要的参数，包括但不限于IP地址、端口号、连接到哪个数据库、用户名、密码\n            String url = \"jdbc:mysql://localhost:3306/FC2020?useSSL=true&characterEncoding=utf8\";\n            String user = \"root\";\n            String password = \"root\";\n\n            // 通过参数获取数据库连接\n            connection = DriverManager.getConnection(url, user, password);\n\n            // 获取Statement对象\n            statement = connection.createStatement();\n\n            // 准备SQL语句\n            String sql = \"delete from student where id = 1;\";\n\n            // 执行SQL语句获取受影响的行数\n            int affectedRows = statement.executeUpdate(sql);\n\n            System.out.println(\"受影响的行数：\" + affectedRows);\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            try {\n                if (statement != null) {\n                    statement.close();\n                }\n\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n#### 查询操作步骤【重点】\n\n```\n1、加载驱动\n2、准备连接数据库所需要的参数\n3、获取数据库连接\n4、获取Statement搬运工对象\n5、准备SQL语句\n6、执行SQL语句获取结果集对象\n7、判断结果集对象中是否有数据\n8、如果结果集对象中存在数据，获取每个数据库字段对应类型的数据\n```\n\n#### Statement 查询 SQL 数据操作\n\n准备实体类\n\n```java\npackage bean;\n\npublic class User {\n    private int uid;\n    private String uname;\n    private String upassword;\n\n    public User() {\n    }\n\n    public User(int uid, String uname, String upassword) {\n        this.uid = uid;\n        this.uname = uname;\n        this.upassword = upassword;\n    }\n\n    public int getUid() {\n        return uid;\n    }\n\n    public void setUid(int uid) {\n        this.uid = uid;\n    }\n\n    public String getUname() {\n        return uname;\n    }\n\n    public void setUname(String uname) {\n        this.uname = uname;\n    }\n\n    public String getUpassword() {\n        return upassword;\n    }\n\n    public void setUpassword(String upassword) {\n        this.upassword = upassword;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"uid=\" + uid +\n                \", uname='\" + uname + '\\'' +\n                \", upassword='\" + upassword + '\\'' +\n                '}';\n    }\n}\n```\n\n> 【注意】根据阿里巴巴开发手册，实体类成员变量要用包装类！！！\n\n##### 查询单行\n\n```java\npackage JDBC;\n\nimport bean.User;\n\nimport java.sql.*;\n\npublic class Demo5 {\n    public static void main(String[] args) {\n\n        // 声明资源\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n\n        try {\n            // 加载驱动\n            Class.forName(\"com.mysql.jdbc.Driver\");\n\n            // 准备参数\n            String url = \"jdbc:mysql://localhost:3306/islu?useSSL=true&characterEncoding=UTF8\";\n            String user = \"root\";\n            String password = \"root\";\n\n            // 获取连接\n            connection = DriverManager.getConnection(url, user, password);\n\n            // 获取搬运工对象\n            statement = connection.createStatement();\n\n            // 准备SQL语句\n            String sql = \"select * from user where uid = 1;\";\n\n            // 执行SQL语句并获取结果集\n            resultSet = statement.executeQuery(sql);\n\n            User userinfo = null;\n\n            // 判断结果集中是否还有下一行数据\n            while (resultSet.next()) {\n                // 从结果集中获取对应类型的数据\n                int uid = resultSet.getInt(1);\n                String uname = resultSet.getString(2);\n                String upassword = resultSet.getString(3);\n\n                // 通过获取到的数据创建实体类对象\n                userinfo = new User(uid, uname, upassword);\n            }\n\n            // 展示\n            System.out.println(userinfo);\n\n        } catch (SQLException | ClassNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n\n                if (statement != null) {\n                    statement.close();\n                }\n\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n##### 查询多行\n\n```java\npackage JDBC;\n\nimport bean.User;\n\nimport java.sql.*;\nimport java.util.ArrayList;\n\npublic class Demo6 {\n    public static void main(String[] args) {\n\n        // 声明资源\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n\n        try {\n            // 加载驱动\n            Class.forName(\"com.mysql.jdbc.Driver\");\n\n            // 准备参数\n            String url = \"jdbc:mysql://localhost:3306/islu?useSSL=true&characterEncoding=UTF8\";\n            String user = \"root\";\n            String password = \"luhuijun\";\n\n            // 获取连接\n            connection = DriverManager.getConnection(url, user, password);\n\n            // 获取搬运工对象\n            statement = connection.createStatement();\n\n            // 准备SQL语句\n            String sql = \"select * from user;\";\n\n            // 执行SQL语句并获取结果集\n            resultSet = statement.executeQuery(sql);\n\n            User userinfo = null;\n            ArrayList<User> list=new ArrayList<>();\n            // 判断结果集中是否还有下一行数据\n            while (resultSet.next()) {\n                // 从结果集中获取对应类型的数据\n                int uid = resultSet.getInt(1);\n                String uname = resultSet.getString(2);\n                String upassword = resultSet.getString(3);\n\n                // 通过获取到的数据创建实体类对象\n                userinfo = new User(uid, uname, upassword);\n                //添加到list集合中\n                list.add(userinfo);\n            }\n\n            // 展示\n            System.out.println(list);\n\n        } catch (SQLException | ClassNotFoundException e) {\n            e.printStackTrace();\n        } finally {\n            // 关闭资源\n            try {\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n\n                if (statement != null) {\n                    statement.close();\n                }\n\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### 常见数据库连接\n\n```shell\n-------------------------------oracle------------------\n驱动：oracle.jdbc.driver.OracleDriver\nURL：jdbc:oracle:thin:@machine_name:port:dbname\n注：machine_name：数据库所在的机器的名称；\n      port：端口号，默认是1521\n\n-------------------------------mysql-------------------\n驱动：com.mysql.jdbc.Driver\nURL：jdbc:mysql://machine_name:port/dbname\n注：machine_name：数据库所在的机器的名称；\n      port：端口号，默认3306\n\n------------------------------SQL Server---------------\n驱动：com.microsoft.jdbc.sqlserver.SQLServerDriver\nURL：jdbc:microsoft:sqlserver://<:port>;DatabaseName=\n注：machine_name：数据库所在的机器的名称；\n      port：端口号，默认是1433\n\n------------------------------DB2----------------------\n驱动：com.ibm.db2.jdbc.app.DB2Driver\nURL：jdbc:db2://<:port>/dbname\n注：machine_name：数据库所在的机器的名称；\n      port：端口号，默认是5000\n-------------------------------------------------------\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java集合","url":"/posts/JavaList.html","content":"\n## List\n\n### 概述\n\n有序的 Collection ，可以根据索引操作元素，数据可重复\n\n> ArrayList\n>\n> 可变长数组\n>\n> LinkedList\n>\n> 双向链表\n>\n> Vector\n>\n> 线程安全的可变长数组\n\n### 增加方法\n\n```java\nboolean add(E e);\n    List接口继承Collection接口 add方法，使用操作和Collection一致，并且这里采用的添加方式是【尾插法】\n\nboolean add(int index, E e);\n    List接口【特有方法】，在指定位置，添加指定元素\n\nboolean addAll(Collection<? extends E> c);\n    List接口继承Collection接口 addAll方法，使用操作和Collection一致，并且这里采用的添加方式是【尾插法】\n\nboolean addAll(int index, Collection<? extends E> c);\n    List接口【特有方法】，在指定下标位置，添加另一个集合中所有内容\npublic class Test {\n    public static void main(String[] args) {\n        List<String> arrayList = new ArrayList<String>();\n\n        arrayList.add(\"Hello\");\n        arrayList.add(\"World\");\n        arrayList.add(\"Android\");\n\n        arrayList.add(0, \"Java\");\n        System.out.println(arrayList);\n\n        List<String> al = new ArrayList<String>();\n\n        al.add(\"ArrayList是线程不安全的可变长数组\");\n        al.add(\"LinkedList是双向链表：增删快，查询慢\");\n\n        al.addAll(arrayList);\n\n        System.out.println(al);\n\n        arrayList.addAll(0, al);\n\n        System.out.println(arrayList);\n    }\n}\n```\n\n### 删除方法\n\n```java\nE remove(int index);\n    List接口【特有方法】，获取指定下标位置的元素并删除\n\nboolean remove(Object obj);\n    List接口继承Collection接口方法。删除集合中的指定元素\n\nboolean removeAll(Collection<?> c);\n    List接口继承Collection接口方法。删除当前集合中和参数集合重复元素\n\nboolean retainAll(Collection<?> c);\n    List接口继承Collection接口方法。保留当前集合中和参数集合重复元素\n\nclear();\n    List接口继承Collection接口方法。清空整个集合中的所有元素\npublic class TestRemove {\n    public static void main(String[] args) {\n        List<Integer> al = new ArrayList<Integer>();\n\n        al.add(1);\n        al.add(2);\n        al.add(3);\n        al.add(4);\n\n        System.out.println(\"删除指定下标位置为0的元素： \" + al.remove(0));\n\n        System.out.println(\"al : \" + al);\n\n        List<Integer> al1 = new ArrayList<Integer>();\n\n        al1.add(4);\n        al1.add(5);\n        al1.add(6);\n\n        System.out.println(\"al.removeAll(al1) : \" + al.removeAll(al1));\n        System.out.println(\"al : \" + al);\n\n        List<Integer> al2 = new ArrayList<Integer>();\n\n        al2.add(5);\n        al2.add(7);\n        al2.add(6);\n\n        System.out.println(\"al1.reatinAll(al2) : \" + al1.retainAll(al2));\n\n        System.out.println(\"al1 ： \" + al1);\n\n        al2.clear();\n\n        System.out.println(\"al2.clear() ： \" + al2);\n    }\n}\n```\n\n### 修改方法\n\n```java\nE set(int index, E e);\n    List接口【特有方法】，使用指定元素替代指定下标的元素，返回值是被替换的元素\npublic class TestModify {\n    public static void main(String[] args) {\n        List<Character> al = new ArrayList<Character>();\n\n        al.add('A');\n        al.add('B');\n        al.add('C');\n\n        al.set(0, 'M');\n\n        System.out.println(al); // [M, B, C]\n    }\n}\n```\n\n#### 查询方法\n\n```java\nint size();\n    List接口继承Collection接口方法。获取集合中有效元素个数\n\nboolean isEmpty();\n    List接口继承Collection接口方法。判断当前集合是否为空\n\nboolean contains(Object obj);\n    List接口继承Collection接口方法。判断指定元素是否包含在当前集合中\n\nboolean containsAll(Collection<?> c);\n    List接口继承Collection接口方法。判断参数集合是不是当前集合在子集合\n\nObject[] toArray();\n    List接口继承Collection接口方法。获取当前集合中所有元素Object数组\n\nE get(int index);\n    List接口【特有方法】。获取指定下标对应的元素\n\nList<E> subList(int fromIndex, int toIndex);\n    List接口【特有方法】。获取当前集合指定子集合，从fromIndex开始，到toIndex结束。fromIndex <= 范围 < toIndex [)\n\nint indexOf(Object obj);\n    List接口【特有方法】。获取指定元素在集合中第一次出现位置\n\nint lastIndexOf(Object o);\n    List接口【特有方法】。获取指定元素在集合中最后一次出现的位置\npublic class TestGet {\n    public static void main(String[] args) {\n        List<String> al = new ArrayList<String>();\n        al.add(\"Hello\");\n        al.add(\"World\");\n        al.add(\"Java\");\n        al.add(\"Android\");\n        al.add(\"Hello\");\n\n        List<String> al2 = new ArrayList<>();\n        al2.add(\"Java\");\n        al2.add(\"Hello\");\n\n        System.out.println(al.size()); // 4\n        System.out.println(al.isEmpty()); // false\n        System.out.println(al.contains(\"Java\")); // true\n        System.out.println(al.containsAll(al2)); // true\n\n        Object[] array = al.toArray();\n        for (Object str : array) {\n            System.out.println(str);\n        }\n\n        System.out.println(al.indexOf(\"World\")); // 1\n        System.out.println(al.lastIndexOf(\"Hello\")); // 4\n\n        System.out.println(al.get(0)); // Hello\n\n        System.out.println(al.subList(1, 3)); // [World, Java]\n    }\n}\n```\n\n### LinkedList\n\n#### 概述\n\n> 底层数据结构是一个双向链表，查询慢，增删快\n\n#### 方法\n\nLinkedList 使用的方法都是从 List 接口实现而来的方法，需要了解的是 LinkedList 特有方法：\n\n```java\nvoid addFirst(E e);\n    在当前链表开始位置加元素\n\nvoid addLast(E e);\n    在当前链表末尾添加元素\n\nE getFirst();\n    获取第一个Node节点元素数据\n\nE getLast();\n    获取末尾Node节点元素数据\n\nE removeFirst();\n    删除头节点\n\nE removeLast();\n    删除末尾节点\npublic class Test {\n    public static void main(String[] args) {\n        LinkedList<String> linkedList = new LinkedList<String>();\n\n        linkedList.add(\"Buffer\");\n        linkedList.add(\"Balance\");\n        linkedList.add(\"Wizard\");\n        linkedList.add(\"Blanche\");\n        linkedList.add(\"Eve\");\n\n        linkedList.addFirst(\"Hello\");\n        linkedList.addLast(\"World\");\n\n        System.out.println(linkedList.getFirst());    // Buffer\n        System.out.println(linkedList.getLast());    // Eve\n\n        System.out.println(linkedList);    // [Hello, Buffer, Balance, Wizard, Blanche, Eve, World]\n\n        System.out.println(\"移除头元素\" + linkedList.removeFirst());    // 移除头元素Hello\n        System.out.println(\"移除尾元素\" + linkedList.removeLast());    // 移除尾元素World\n\n        System.out.println(linkedList);    // [Buffer, Balance, Wizard, Blanche, Eve]\n    }\n}\n```\n\n### ArrayList\n\n#### 概述\n\n```java\nList 接口的大小可变数组的实现。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。（此类大致上等同于 Vector 类，除了此类是不同步的。）\n```\n\n#### 特有方法\n\n```java\nvoid ensureCapacity(int minCapacity);\n    如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。\n\ntrimToSize();\n    将此 ArrayList 实例的容量调整为列表的当前大小。节省空间\n```\n\n#### 效率\n\n> 增删慢，查询快\n\n```\n增删慢\n    增加慢\n        1、数组当前容量无法满足添加操作，需要进行grow扩容方法执行，在扩容方法中，存在数组创建，数组数据拷贝。非常浪费时间，而且浪费内存。\n        2、数组在添加数据的过程中，存在在指定位置添加元素，从指定位置开始，之后的元素整体向后移动。\n\n    删除慢\n        1、删除数据之后，从删除位置开始，之后的元素整体向前移动，移动过程非常浪费时间\n        2、删除操作会导致数据空间的浪费，内存的浪费\n\n    查询快\n        ArrayList 底层是一个数组结构，在查询操作的过程中，是按照数组+下标的方式来操作对应的元素，数组+下标方式可以直接获取对应的空间首地址，CPU访问效率极高。\n```\n\n## Collection 接口\n\n> Collection   层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection   允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何*直接* 实现：它提供更具体的子接口（如 `Set` 和 `List`）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。\n\n### 增加方法\n\n```java\nboolean add(E e);\n    添加当前集合约束的指定数据类型到当前集合中\n\nboolean addAll(Collection<? extends E> c);\n    添加另一个集合到当前集合中，要求添加集合中保存的元素必须是当前集合中保存元素本身或者其子类对象 【泛型的上限】\n    class Dog extends Animal\n    class Cat extends Animal\n    class Tiger extends Animal\n```\n\n案例代码\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Collection<String> collection1 = new ArrayList<String>();\n        Collection<String> collection2 = new ArrayList<String>();\n\n        collection1.add(\"Java\");\n        collection1.add(\"Hello\");\n\n        collection2.add(\"Java\");\n        collection2.add(\"Hello\");\n        collection2.add(\"World\");\n\n        System.out.println(collection1);    // [Java, Hello]\n\n        collection1.addAll(collection2);\n        System.out.println(collection1);    // [Java, Hello, Java, Hello, World]\n    }\n}\n```\n\n### 删除方法\n\n```java\nboolean remove(Object obj);\n    删除集合中的指定元素，删除成功返回true,未找到指定元素，无法删除返回\n    false，并且在多个元素的情况下，删除找到的第一个元素。\n\nboolean removeAll(Collection<?> c);\n    在当前集合中删除两个集合的交集\n\nboolean retainAll(Collection<?> c);\n    在当前集合中保留两个集合的交集\n\nvoid clear();\n    清空整个集合中的所有元素\n```\n\n案例代码\n\n```java\npublic class TestRemove {\n    public static void main(String[] args) {\n        Collection<String> collection1 = new ArrayList<String>();\n        Collection<String> collection2 = new ArrayList<String>();\n\n        collection1.add(\"Java\");\n        collection1.add(\"Hello\");\n\n        collection2.add(\"Java\");\n        collection2.add(\"Hello\");\n        collection2.add(\"World\");\n\n        collection1.remove(\"Hello\");\n        System.out.println(collection1);    // [Java]\n\n        collection2.removeAll(collection1);\n        System.out.println(collection2);    // [Hello, World]\n\n        collection1.add(\"Hello\");\n\n        collection1.containsAll(collection2);\n        System.out.println(collection1);    // [Java, Hello]\n    }\n}\n```\n\n### 查询方法\n\n```java\nint size();\n    有效元素个数\n\nboolean isEmpty();\n    判断当前集合是否为空，是否存在有效元素\n\nboolean contains(Object obj);\n    判断指定元素是否在当前集合中存在\n\nboolean containsAll(Collection<?> c);\n    判断传入的参数集合是不是当前集合的子集合\n\nObject[] toArray();\n    返回集合中所有保存元素的Object类型数组\n```\n\n案例代码\n\n```java\npublic class TestGet {\n    public static void main(String[] args) {\n        Collection<String> collection1 = new ArrayList<String>();\n        Collection<String> collection2 = new ArrayList<String>();\n\n        collection1.add(\"Java\");\n        collection1.add(\"Hello\");\n\n        collection2.add(\"Java\");\n        collection2.add(\"Hello\");\n        collection2.add(\"World\");\n\n        System.out.println(collection1.size());    // 2\n\n        System.out.println(collection1.isEmpty());    // fasle\n\n        System.out.println(collection1.contains(\"Java\"));    //true\n\n        System.out.println(collection2.containsAll(collection1));    // true\n\n        Object[] array = collection1.toArray();\n        for (int i = 0; i < array.length; i++) {\n            System.out.println(array[i]);\n        }\n    }\n}\n```\n\n### 迭代器\n\n是用来获取集合中元素的另一种方式（遍历），依赖于集合存在\n\n#### 获取迭代器的方法\n\n```java\nIterator<E> iterator();\n    获取迭代器对象，泛型对应的具体数据类型和集合中约束的泛型具体数据类型一致。\n```\n\n#### 其他方法\n\n```java\nboolean hasNext();\n    判断当前集合中是否可以继续得到元素，(是否可以继续遍历)\n\nE next();\n    1. 获取迭代器当前指向的元素\n    2. 将迭代器指向下一个元素\n\nvoid remove();\n    删除通过next方法获取到元素\n        【注意】\n        1、remove方法只能删除next方法获取到元素\n        2、remove方法只能在next方法之后执行，且不能跨过一个next执行\n        3、没有next不能使用remove\n```\n\n案例代码\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Collection<String> c = new ArrayList<String>();\n\n        c.add(\"雪花纯生\");\n        c.add(\"修道院啤酒\");\n        c.add(\"1664\");\n        c.add(\"泰山精酿\");\n        c.add(\"时光精酿\");\n\n        /*\n         * 根据当前集合，获取对应的迭代器对象\n         *\n         * 得到的迭代器对象会依据，当前集合中的所有元素进行一个规划操作。\n         * 迭代器对于整个集合中的元素都是存在预期。\n         */\n        Iterator<String> iterator = c.iterator();\n\n        /*\n         * 迭代器遍历，利用迭代器的特征进行遍历操作\n         */\n        while (iterator.hasNext()) {\n            // 获取每一个迭代器指向元素，并且展示\n            String string = iterator.next();\n            System.out.println(string);\n\n            /*\n             * 通过集合对象本身删除1664，对于迭代器而言，一脸懵逼，原本的规划\n             * 没有了！！！并且集合没有告知迭代器数据发生了改变，迭代器继续按照\n             * 原本的规划路径操作，保存！！！\n             *\n             * 对于集合在内存中占用的空间而言\n             *     1. 集合对应的引用数据类型变量可以操作对应空间\n             *     2. 迭代器可以操作对应的空间\n             *\n             * 对于集合和迭代器而言，【集合在内存中占用的空间】共享资源，在操作\n             * 共享资源过程中，我们要多多考虑共享资源的冲突问题。\n             * 后面课程中会讲到【多线程】\n             */\n            c.remove(\"1664\");\n        }\n\n        /*\n         Exception in thread \"main\" java.util.ConcurrentModificationException\n                at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)\n                at java.util.ArrayList$Itr.next(ArrayList.java:859)\n                at com.qfedu.b_iterator.Demo3.main(Demo3.java:30)\n         */\n    }\n}\n```\n\n## Map\n\n> Map 接口允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。映射顺序 定义为迭代器在映射的 collection 视图上返回其元素的顺序。某些映射实现可明确保证其顺序，如 TreeMap 类；另一些映射实现则不保证顺序，如 HashMap 类。\n>\n> 【重点】将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。\n\n```java\npublic interface Map<K,V>\n```\n\n```java\ninterface Map<K, V>\n--| class HashMap<K, V>\n    重点！！！底层是哈希表\n--| class TreeMap<K, V>\n    底层是红黑树\n```\n\n### 增加方法\n\n```java\nV put(K key, V value);\n    添加符合Map要求的键值对存入到双边队列中\n\nvoid putAll(Map<? extends K, ? extends V> map)\n    添加另一个Map到当前Map中，要求K是当前Map本身对应的K，或者其子类，V是当前Map本身对应的V，或者其子类\n```\n\n### 删除方法\n\n```java\nV remove(Object key);\n    删除对应Key键值对\n```\n\n### 修改方法\n\n```java\nV put(K key, V value);\n    使用value修改已存在的key对应的值\n```\n\n### 查询方法\n\n```java\nint size();\n    Map双边队列个数\nboolean isEmpty();\n    判断当前Map双边队列中是否为空\nboolean containsKey(Object key);\n    判断指定Key是否存在\nboolean containsValue(Object value);\n    判断指定Value是否存在\nSet<K> keySet();\n    返回Map双边队列中所有Key对应的Set集合\nCollection<V> values();\n    返回Map双边队列中所有value对应Collection集合\n```\n\n### Map 中的 Entry\n\n> Map 双边队列中把 Key 和 Value 进行一个封装操作，完全按照一个数据类型来处理。是 Map 中的一个成员接口，用于获取对应的键和值（参考 Collection 中的迭代器）\n\n```java\ninterface Map.Entry<K,V>\n```\n\n案例代码\n\n```java\nSet<Map.Entry<K, V>> entrySet();\n    返回值类型是Entry键值对形式数据的Set集合\n\nSet<Map.Entry<K, V>>\n    Map.Entry<K, V> Map接口的内部接口Entry，使用的泛型 K,V对应Map创建过程中约束的K,V\n    因为返回值是Set集合，集合带有泛型 Set<Map接口中的内部接口Entry>\n\nEntry 对应的方法\n    K getKey();\n        返回与此项对应的键\n    V getValue();\n        返回与此项对应的值。\n    V setValue(V value);\n        用指定的值替换与此项对应的值，返回与此项对应的旧值\npublic class TestEntry {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<String, Integer>();\n\n        map.put(\"Buffer\", 23);\n        map.put(\"Balance\", 23);\n        map.put(\"Amy\", 32);\n\n        Set<Entry<String, Integer>> entrySet = map.entrySet();\n\n        for (Entry<String, Integer> entry : entrySet) {\n            System.out.println(entry.getKey() + \" setVaule: \" + entry.setValue(16));\n            System.out.println(entry.getKey() + \" : \" + entry.getValue());\n        }\n    }\n}\n```\n\n### HashMap\n\n> 基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序\n\n```java\npublic class HashMap<K,V>\n```\n\n案例代码\n\n```java\npublic class TestHashMap {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new HashMap<String, Integer>();\n\n        map.put(\"Buffer\", 23);\n        map.put(\"Balance\", 23);\n        map.put(\"Amy\", 32);\n\n        System.out.println(map);\n\n        HashMap<String, Integer> hashMap = new HashMap<>();\n        hashMap.put(\"Candy\", 33);\n        hashMap.put(\"David\", 29);\n\n        hashMap.putAll(map);\n        System.out.println(hashMap);\n\n        hashMap.remove(\"Balance\");\n        System.out.println(hashMap);\n\n        hashMap.put(\"Buffer\", 16);\n        System.out.println(hashMap);\n\n        System.out.println(\"map.size() :\" + map.size());\n\n        System.out.println(\"map.isEmpty() : \" + map.isEmpty());\n\n        System.out.println(\"have Buffer : \" + map.containsKey(\"Buffer\"));\n\n        System.out.println(\"have Buffer's age : \" + hashMap.containsValue(16));\n\n        Set<String> keySet = map.keySet();\n        System.out.println(keySet);\n\n        Collection<Integer> values = map.values();\n        System.out.println(values);\n    }\n}\n```\n\n> 【注意】HashMap 添加自定义数据类型元素时需要重写其 equals 和 hashCode 方法\n\n学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    private char sex;\n\n    // Constructor setter getter toString equals hashCode\n}\n```\n\n测试类\n\n```java\npublic class TestMap2 {\n    public static void main(String[] args) {\n        Map<Student, Integer> hashMap = new HashMap<Student, Integer>();\n\n        hashMap.put(new Student(\"Buffer\", 23, '男'), 1);\n        hashMap.put(new Student(\"Balance\", 23, '男'), 2);\n        hashMap.put(new Student(\"Buffer\", 22, '男'), 3);\n        hashMap.put(new Student(\"Buffer\", 23, '女'), 4);\n        hashMap.put(new Student(\"Buffer\", 23, '男'), 5);\n\n        Set<Entry<Student, Integer>> entrySet = hashMap.entrySet();\n\n        for (Entry<Student, Integer> entry : entrySet) {\n            System.out.println(entry);\n        }\n    }\n}\n```\n\n结果\n\n```java\nStudent [name=Balance, age=23, sex=男]=2\nStudent [name=Buffer, age=23, sex=女]=4\nStudent [name=Buffer, age=22, sex=男]=3\nStudent [name=Buffer, age=23, sex=男]=5\n```\n\n### TreeMap\n\n> 基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。\n\n学生类\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n    private char sex;\n\n    // Constructor and setter、getter\n}\n```\n\nComparator 接口实现类\n\n```java\npublic class MyCompare implements Comparator<Student> {\n\n    /**\n     * 返回两个学生的年龄差\n     */\n    @Override\n    public int compare(Student o1, Student o2) {\n        return o1.getAge() - o2.getAge();\n    }\n\n}\n```\n\n测试类\n\n```java\npublic class TestTreeMap {\n    public static void main(String[] args) {\n        TreeMap<Student, Integer> treeMap = new TreeMap<Student, Integer>(new MyCompare());\n\n        treeMap.put(new Student(\"Buffer\",23,'男'), 1);\n        treeMap.put(new Student(\"Buffer\",22,'男'), 1);\n        treeMap.put(new Student(\"Buffer\",21,'男'), 1);\n\n        System.out.println(treeMap);\n        System.out.println(treeMap.size());\n    }\n}\n```\n\n## Set\n\n### 概述\n\n> 一个不包含重复元素的 Collection。存储元素的顺序无序。（注意区分添加顺序和存储顺序）\n\n### HashSet\n\n#### 概述\n\n> 底层数据结构是哈希表，依赖 equals 方法和 hashCode 方法实现不可重复\n\n学生类：需要重写 equals\n\n和 hashCode\n\n```java\npublic class Student {\n    private String name;\n    private int age;\n\n    // Construator setter/getter toString\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + age;\n        result = prime * result + ((name == null) ? 0 : name.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        Student other = (Student) obj;\n        if (age != other.age)\n            return false;\n        if (name == null) {\n            if (other.name != null)\n                return false;\n        } else if (!name.equals(other.name))\n            return false;\n        return true;\n    }\n}\n```\n\n测试类\n\n```java\npublic class Test {\n    public static void main(String[] args) {\n        Set<Student> hashSet = new HashSet<Student>();\n\n        hashSet.add(new Student(\"Buffer\", 23));\n        hashSet.add(new Student(\"Smoot\", 22));\n        hashSet.add(new Student(\"Wizard\", 23));\n        hashSet.add(new Student(\"Buffer\", 23));\n        hashSet.add(new Student(\"Buffer\", 20));\n        hashSet.add(new Student(\"Balance\", 21));\n\n        for (Student student : hashSet) {\n            System.out.println(student);\n        }\n    }\n}\n```\n\n结果\n\n```java\nStudent [name=Smoot, age=22]\nStudent [name=Wizard, age=23]\nStudent [name=Balance, age=21]\nStudent [name=Buffer, age=23]\nStudent [name=Buffer, age=20]\n```\n\n> hashSet 底层哈希表结构存储元素时，会首先得到当前元素的哈希值，需要执行调用对应的 hashCode 方法，hash 方法中存在一个【移位运算】，一种特殊运算方式，用于根据当前对象的 hashCode 结果，计算该元素在底层哈希表中的存储位置。\n>\n> 【重点】如果元素 hashCode 值结果一致，那么它们保存对应的位置应该是一致的，会存入同一个空间，但是会进行 equals 比较，对象相同，【无法添加，对象不同，可以添加，但是需要避免】\n\n### TreeSet\n\n#### 概述\n\n> 基于 TreeMap 的 NavigableSet 实现，底层数据结构是平衡二叉树。使用元素的自然顺序对元素进行排序（Comparable），或者根据创建 set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。\n\nPerson 类\n\n```java\npackage code.treeset;\n\npublic class Person {\n    private String name;\n    private int age;\n\n    // Constructor setter/getter toString\n}\n```\n\nComparator 接口实现类\n\n```java\npublic class MyCompare implements Comparator<Person> {\n\n    // 通过年龄判断是否为同一个 Person\n    @Override\n    public int compare(Person o1, Person o2) {\n        return o1.getAge() - o2.getAge();\n    }\n}\n```\n\n测试类\n\n```java\npublic class TestPerson {\n    public static void main(String[] args) {\n        // 创建 TreeSet 集合时传入一个 Comparator 接口的实现类\n        TreeSet<Person> treeSet = new TreeSet<Person>(new MyCompare());\n\n        treeSet.add(new Person(\"Smoot\", 22));\n        treeSet.add(new Person(\"Buffer\", 23));\n        treeSet.add(new Person(\"Wizard\", 23));\n        treeSet.add(new Person(\"Balance\", 21));\n\n        System.out.println(treeSet);    // [Person [name=Balance, age=21], Person [name=Smoot, age=22], Person [name=Buffer, age=23]]\n    }\n}\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java接口","url":"/posts/JavaInterface.html","content":"\n## 接口\n\n### 概念\n\n接口是一系列方法的声明，是一些方法特征的集合，**一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）**。\n\n### 格式\n\ninterface ：用来声明接口的关键字\n\n```java\n声明格式：\n    interface 接口名 {\n        静态常量;\n        抽象方法;\n    }\n\n实现格式：\n    class 类名 implements 接口名 {\n\n    }\n```\n\n### 特点\n\n```java\n1、接口中的成员变量只能是静态常量，定义时必须初始化。默认修饰符：public static final\n2、接口中没有构造方法，因为接口不能实例化对象\n3、接口中的成员方法只能是抽象方法，没有方法体。默认修饰符：public abstract\n4、接口的实现类必须重写接口中方法，或者是一个抽象类(可以重写也可以不重写接口中的方法)\n```\n\n### 接口的声明和实现\n\n```java\ninterface play{\n    // 常量，缺省修饰符：public static final\n    int time = 10;\n\n    // 抽象方法，缺省修饰符：public abstract\n    void geme();\n}\n\npublic class TestInterface3 implements play{\n\n    // 重写接口中的方法\n    @Override\n    public void geme() {\n        System.out.println(\"玩游戏\");\n    }\n\n}\n```\n\n【注意】接口的实现类必须重写接口中的方法\n\n### 抽象类实现接口\n\n```java\ninterface servlet {\n    void init();\n\n    void service();\n}\n\nabstract class BaseServlet implements servlet {\n    // 重写init()方法\n    @Override\n    public void init() {\n        System.out.println(\"初始化\");\n    }\n}\n\nclass MyServlet extends BaseServlet {\n\n    @Override\n    public void service() {\n        System.out.println(\"服务方法\");\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        new MyServlet().init();\n        new MyServlet().service();\n    }\n}\n```\n\n【注意】抽象类实现接口，可以选择性重写也可以不重写接口中的方法\n\n### 类的接口多实现\n\n```java\ninterface Play {\n    void geme();\n}\n\ninterface Eat {\n    void noodles();\n}\n\npublic class TestInterface3 implements Play, Eat {\n\n    // 重写Play类中的方法\n    @Override\n    public void geme() {\n        System.out.println(\"玩游戏\");\n    }\n\n    // 重写Eat类中的方法\n    @Override\n    public void noodles() {\n        System.out.println(\"吃面条\");\n    }\n\n}\n```\n\n【注意】接口的实现类必须重写所有接口中的方法\n\n### 接口的继承\n\n```java\ninterface Eat {\n    void noodles();\n}\n\ninterface Play {\n    void happy();\n}\n\n// 单继承\ninterface Person extends Play {\n\n}\n\n// 多继承\ninterface Animal extends Play, Eat {\n\n}\n\n// 实体类实现Animal接口，重写所有方法\nclass Biology implements Animal {\n\n    @Override\n    public void happy() {\n        System.out.println(\"玩得开心\");\n    }\n\n    @Override\n    public void noodles() {\n        System.out.println(\"面条好吃\");\n    }\n\n}\n\npublic class Test {\n    public static void main(String[] args) {\n        Biology biology = new Biology();\n        biology.happy();    // 玩得开心\n        biology.noodles();    // 面条好吃\n    }\n}\n```\n\n【注意】接口之间可以单继承，也可以多继承\n\n### jdk1.8 新特性：default 接口\n\n```java\ninterface Function {\n    void test();\n\n    default void testDefault() {\n        System.out.println(\"default修饰的接口可以有方法体\");\n    }\n}\n\n// default 修饰的接口可以不被重写\nclass Base implements Function {\n\n    @Override\n    public void test() {\n        System.out.println(\"Base类重写Function接口中的方法\");\n    }\n}\n\n// default 修饰的接口也可以重写\nclass Boost implements Function {\n\n    @Override\n    public void test() {\n        System.out.println(\"Boost类重写Function接口中的方法\");\n    }\n\n    @Override\n    public void testDefault() {\n        System.out.println(\"Boost类重写Function接口中的default方法\");\n    }\n}\n\npublic class TestInterface2 {\n    public static void main(String[] args) {\n        Base base = new Base();\n        Boost boost = new Boost();\n\n        base.test();        // Base类重写Function接口中的方法\n        base.testDefault();    // default修饰的接口可以有方法体\n        boost.test();        // Boost类重写Function接口中的方法\n        boost.testDefault();// Boost类重写Function接口中的default方法\n    }\n}\n```\n\n【注意】default 修饰的接口可以不被重写\n\n### 总结\n\n```shell\n1、接口是对类的扩展，通过接口可以让类拥有更多更强的功能\n2、接口中只有全局常量和抽象方法，所以不能实例化\n3、接口的实现类必须重写所有方法，或者是个抽象类\n4、接口可以多实现\n5、接口可以单继承，也可以多继承\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java泛型","url":"/posts/JavaGenericity.html","content":"\n## 泛型\n\n### 概述\n\nJava 泛型是 JavaSE1.5 中引入的一个新特性，其本质是参数化类型，也就是说所操作的数据类型被指定为一个参数（type  parameter）这种参数类型在定义的时候是宽泛的，而在使用的时候是确定的。可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。\n\n### 泛型的优点\n\n```shell\n1、提高了程序的安全性(类型安全)\n2、提高了程序的可扩展性、可重用性\n3、将运行期遇到的问题转移到了编译期\n4、省去了类型强转的麻烦(Object类对象)\n```\n\n### 泛型格式\n\n```java\n泛型标识符：<自定义无意义英文大写单字母占位符>\n    常用格式：\n        <T> Type\n        <E> Element\n        <K> Key\n        <V> Value\n\n泛型类：把泛型定义在类上\n    格式:class 类名<泛型类型1,…>\n        【注意】泛型类型必须是引用类型\n\n泛型方法：把泛型定义在方法上\n    格式:public <泛型类型> 返回类型 方法名(泛型类型 .)\n\n泛型接口：把泛型定义在接口上\n    格式:public  interface 接口名<泛型类型1…>\n```\n\n### 泛型方法\n\n案例代码 1\n\n```java\npublic class GenericityMethodDemo {\n    public static void main(String[] args) {\n        System.out.println(getData(100));\n        System.out.println(getData(\"Java\"));\n        System.out.println(getData('A'));\n        System.out.println(getData(false));\n    }\n\n    /**\n     * 泛型方法\n     * 格式：\n     *         泛型限定符 返回值类型 方法名(泛型类型 参数名) {}\n     *\n     * @param <T> 泛型限定符\n     * @param t 任意类型的参数\n     * @return 返回任意类型参数\n     */\n    public static <T> T getData(T t) {\n        return t;\n    }\n}\n```\n\n案例代码 2\n\n```java\npublic class GenericityMethodDemo2 {\n    public static void main(String[] args) {\n        Integer[] intArr = {1, 2, 3};\n        String[] stringArr = {\"4\", \"5\", \"6\"};\n\n        // 自定义学生类，其中包含name和age两个成员变量\n        Student[] students = {new Student(\"张三\", 1), new Student(\"李四\", 2), new Student(\"王五\", 3)};\n\n        printArray(intArr);\n        printArray(stringArr);\n        printArray(students);\n    }\n\n    /**\n     * 遍历任意类型的数组\n     *\n     * @param <T> 泛型限定符\n     * @param t 任意类型的数组\n     */\n    public static <T> void printArray(T[] t) {\n        for (int i = 0; i < t.length; i++) {\n            System.out.println(t[i]);\n        }\n    }\n}\n```\n\n【注意】\n\n```shell\n1、要求形式参数列表中必须有一个参数是当前自定义泛型，因为需要通过参数来约束当前方法运行过程中泛型对应的具体数据类型是哪一个\n\n2、返回值类型可以使用自定义泛型，而且是被形式参数列表中传入的泛型对应具体的数据类型控制\n\n3、方法体内也可以使用自定义泛型，同时也是被参数当中泛型对应具体数据类型约束监控\n```\n\n### 泛型类\n\n```java\npublic class GenericityClassDemo {\n    public static void main(String[] args) {\n        Number<Integer> num1 = new Number<Integer>(100);\n        Number<String> num2 = new Number<String>(\"100\");\n        System.out.println(num1.getT());\n        System.out.println(num2.getT());\n    }\n}\n\n/**\n * 泛型类，把泛型定义到类上，整个类内都可以使用。是对泛型方法的封装\n * @param <T> 泛型标识符\n */\nclass Number<T> {\n    private T t;\n\n    // Constrator、setters、getters\n}\n```\n\n【注意】\n\n```shell\n1、类内可以直接使用对应的类名声明泛型\n2、类内使用的泛型具体数据类型是在创建当前类对象时约束\n3、在创建当前类对象时没有约束泛型对应的具体数据类型，那么所有使用到泛型的位置都是Object类型，有悖于泛型使用原则\n4、如果类声明过了泛型，那么类中所有使用此泛型的方法都同时被声明，即无法使用其他类型\n5、泛型类中定义的静态方法不能直接使用类声明的泛型，因为泛型需要在创建对象时声明，而静态方法在类加载时就加载完成，此时泛型还没有声明。如果静态方法想要使用泛型，只能自己声明自己使用\n```\n\n泛型接口\n\n案例代码 1\n\n```java\ninterface USB {}\n\nclass Mouse implements USB {}\n\nclass Keyboard implements USB {}\n\ninterface PC<T> {\n    // 接口中的常量不能使用泛型\n\n    T use(T t);\n}\n\n/*\n *  实现类实现接口时不指定泛型类型,\n *  需要在创建对象时明确\n */\nclass MyPC<T> implements PC<T> {\n    @Override\n    public T use(T t) {\n        return t;\n    }\n}\n\n/*\n * 实现类实现接口时，接口中泛型的类型已经明确，\n * 实现的方法也是明确的\n */\nclass YourPC implements PC<Mouse> {\n    @Override\n    public Mouse use(Mouse t) {\n        return t;\n    }\n}\n\npublic class GenericityInterfaceDemo {\n    public static void main(String[] args) {\n        // 创建对象时明确泛型的类型\n        MyPC<Keyboard> myPC = new MyPC<Keyboard>();\n\n        Keyboard keyboard = myPC.use(new Keyboard());\n\n        System.out.println(keyboard);\n\n        System.out.println(\"-----------------\");\n\n        // 声明类时已经明确泛型的类型，所以这里的类型已经是明确的\n        YourPC yourPC = new YourPC();\n\n        Mouse mouse = yourPC.use(new Mouse());\n\n        System.out.println(mouse);\n    }\n}\n```\n\n案例代码 2\n\n```java\n/**\n * 自定义一个比较器接口\n * @param <T> 泛型\n */\ninterface Comparable<T> {\n    /**\n     * 这是一个比较方法，实现类应该实现这个方法以达到比较的目的\n     *\n     * @param t 传入被比较的对象\n     * @return 负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。\n     */\n    public abstract int compareTo(T t);\n}\n/**\n * 自定义父类，实现比较器接口\n */\nclass Father implements Comparable<Father>{\n    private String name;\n    private int age;\n\n    // Constrator、setters、getters\n\n    @Override\n    public int compareTo(Father f) {\n        return this.age - f.age;\n    }\n}\n\npublic class GenericityInterfaceDemo {\n    public static void main(String[] args) {\n        Father father1 = new Father(\"小明父亲\", 30);\n        Father father2 = new Father(\"小红父亲\", 29);\n\n        if (father1.compareTo(father2) < 0) {\n            System.out.println(\"小红父亲年长：\" + father2.getAge());\n        } else {\n            System.out.println(\"小明父亲年长：\" + father1.getAge());\n        }\n    }\n}\n```\n\n【注意】\n\n```shell\n1、接口中的成员变量不能使用泛型，因为static、final\n2、泛型接口的实现类可以指定泛型的类型，也可以不指定，如果在实现类中明确了数据类型，创建对象时就不需要再进行明确\n```\n\n### 泛型通配符\n\n> 在泛型中，？ 表示未知类型，被称为通配符。通配符可以在各种情况下使用：可以作为形式参数、成员变量、局部变量的类型，也可以作为返回值类型。但是，通配符不能用于泛型方法调用、泛型类实例创建对象或者父类的类型实际参数\n\n表示全部类型，类似 Object。区别于 T，T 只是占位符，而 ？是数据类型\n\n```java\n<?>\n```\n\n【使用场景】\n\n```shell\n1、当一个方法可以用Object类提供的功能来实现时，泛型通配符是使用的\n\n2、若代码使用了泛型类中的方法，而这些方法又是不依赖于参数化类型的，可以使用泛型通配符\n```\n\n案例代码\n\n```java\nclass Grade<T> {\n    private T t;\n\n    // Constructor、setter and getter、toString\n\n    public void show() {\n        System.out.println(\"show\" + this);\n    }\n}\n\nclass School {\n    // 这里使用泛型通配符，表示可以传入任意类型\n    public void showGrade(Grade<?> grade) {\n        grade.show();\n    }\n}\n\npublic class GenericityWildCardDemo {\n    public static void main(String[] args) {\n        School school = new School();\n\n        school.showGrade(new Grade<Student>(new Student()));\n        school.showGrade(new Grade<Teacher>(new Teacher()));\n    }\n}\n```\n\n#### 泛型上限\n\n表示以 T 为父类的所有子类（包括父类）\n\n```java\n<? extends T>\n```\n\n#### 泛型下限\n\n表示以 E 为子类的所有父类（包括子类）\n\n```java\n<? super E>\n```\n\n案例代码\n\n```java\nclass School {\n    public void showGrade(Grade<?> grade) {\n        grade.show();\n    }\n\n    // 泛型上限，Person类本身及其子类都可以使用\n    public void showExtends(Grade<? extends Person> grade) {\n        System.out.println(grade);\n    }\n\n    // 泛型下限，Person类本身及其父类都可以使用\n    public void showSuper(Grade<? super Person> grade) {\n        System.out.println(grade);\n    }\n}\n\npublic class GenericityWildCardDemo {\n    public static void main(String[] args) {\n        School school = new School();\n\n        school.showGrade(new Grade<Student>(new Student()));\n        school.showGrade(new Grade<Teacher>(new Teacher()));\n\n        // 泛型上限，可以声明子类的类型\n        school.showExtends(new Grade<Student>());\n        // 泛型下限，可以声明父类的类型\n        school.showSuper(new Grade<Object>());\n    }\n}\n```\n\n### 泛型推断\n\n> JDK1.7 新特性，可以省略实例化对象时尖括号内的类型\n\n案例代码\n\n```java\npublic class GenericityInferDemo {\n    public static void main(String[] args) {\n        // 泛型推断\n        Grade<Student> grade = new Grade<>();\n\n        // 得到对应的类型\n        Student student = grade.getT();\n    }\n}\n```\n\n### 总结\n\n> 1、泛型就是泛化的类型，本质是参数化类型，是 jdk1.5 引入的新特性，用在类、接口和方法上，即泛型类，泛型接口和泛型方法\n>\n> 2、为了解决利用继承 Object 来实现通用性导致的强制类型转换和可能发生的类型转换异常的问题。\n>\n> 3、泛型的好处是确保了编译时期的类型安全，和避免了强制类型转换的麻烦\n>\n> 4、缺陷是因为泛型使用了类型擦除机制，jvm 运行之前会将泛型信息擦除掉，这样做是为了兼容 jdk1.5 之前的代码，但是也会导致通过反射可以跳过泛型的问题，因为运行期间并没有泛型的限制\n>\n> 5、泛型通配符？代表任意类型，泛型上限<? extends T>，泛型下限<? super T>\n>\n> 6、jdk1.7 新特性泛型推断，声明变量时定义过泛型得话，在实例化对象时可以省略类型，但是还要加<>，否则还是原类型\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java代码块","url":"/posts/JavaCodeBlock.html","content":"\n## 代码块\n\n在 Java 中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程)\n\n### 构造代码块\n\n```java\n格式：\n    {\n\n    }\n```\n\n#### 注意\n\n```shell\n1、用于给对象初始化，多个构造方法中相同的代码存放到一起，每次调用构造方法都会执行，并且在构造方法前执行\n2、只有创建对象时调用，类不能调用\n3、构造代码块可以有多个，建议只写一个\nclass Person {\n    {\n        System.out.println(\"Person构造代码块执行\");\n    }\n\n    public Person() {\n        System.out.println(\"Person构造方法执行\");\n    }\n}\n\npublic class TestPerson {\n    public static void main(String[] args) {\n        System.out.println(\"main方法\");\n        new Person();\n        new Person();\n    }\n}\n```\n\n### 静态代码块\n\n```java\n格式：\n    static {\n\n    }\n```\n\n#### 注意\n\n```shell\n1、用于给类进行初始化，在加载的时候就执行，并且只执行一次\n2、优先级高于主函数\n3、静态代码块可以有多个，顺序执行，建议只写一个\nclass Person {\n    static {\n        System.out.println(\"Person静态代码块执行\");\n    }\n\n    public Person() {\n        System.out.println(\"Person构造方法执行\");\n    }\n}\n\npublic class TestPerson {\n    static {\n        System.out.println(\"静态代码块1执行\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main方法\");\n        new Person();\n        new Person();\n    }\n\n    static {\n        System.out.println(\"静态代码块2执行\");\n    }\n}\n```\n\n结果\n\n```shell\n静态代码块1执行\n静态代码块2执行\nmain方法\nPerson静态代码块执行\nPerson构造方法执行\nPerson构造方法执行\n```\n\n### 代码块相关执行顺序\n\n```java\npublic class Father {\n    public Father() {\n        System.out.println(\"父类构造方法执行~~~\");\n    }\n\n    {\n        System.out.println(\"父类构造代码块执行~~~\");\n    }\n\n    static {\n        System.out.println(\"父类静态代码块执行~~~\");\n    }\n\n    public static void function() {\n        System.out.println(\"父类静态成员方法执行~~~\");\n    }\n}\n\npublic class Son extends Father{\n    public Son() {\n        System.out.println(\"子类构造方法执行~~~\");\n    }\n\n    {\n        System.out.println(\"子类构造代码块执行~~~\");\n    }\n\n    static {\n        System.out.println(\"子类静态代码块执行~~~\");\n    }\n\n    public static void function() {\n        System.out.println(\"子类静态成员方法执行~~~\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main方法执行~~~\");\n        new Son();\n    }\n}\n```\n\n结果\n\n```shell\n父类静态代码块执行~~~\n子类静态代码块执行~~~\nmain方法执行~~~\n父类构造代码块执行~~~\n父类构造方法执行~~~\n子类构造代码块执行~~~\n子类构造方法执行~~~\n```\n\n### 面试题\n\n执行顺序\n\n```java\npublic class Test {\n    static Test test1 = new Test();\n    static Test test2 = new Test();\n\n    static {\n        System.out.println(\"静态代码块\");\n    }\n\n    {\n        System.out.println(\"构造代码块\");\n    }\n\n    public Test() {\n        System.out.println(\"构造方法\");\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"main方法\");\n        new Test();\n    }\n}\n```\n\n结果\n\n```shell\n构造代码块\n构造方法\n构造代码块\n构造方法\n静态代码块\nmain方法\n构造代码块\n构造方法\n```\n\n### 总结\n\n> 1、构造代码块用于给对象初始化，每次创建对象都会调用构造代码块，并且执行顺序在构造方法之前\n>\n> 2、静态代码块用于给类初始化，当类被加载的时候就会调用静态代码块（只执行一次），执行顺序在 main 方法之前\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java常用API","url":"/posts/JavaAPI.html","content":"\n## API 概述\n\n> API(Application Programming Interface) 应用程序编程接口\n\n编写一个机器人程序去控制机器人踢足球，程序就需要向机器人发出向前跑、向后跑、射门、抢球等各种命令，没有编过程序的人很难想象这样的程序如何编写。但是对于有经验的开发人员来说，知道机器人厂商一定会提供一些用于控制机器人的 Java 类，这些类中定义好了操作机器人各种动作的方法。其实，这些 Java 类就是机器人厂商提供给应用程序编程的接口，大家把这些类称为 Xxx Robot API。本章涉及的 Java API 指的就是 JDK 中提供的各种功能的 Java 类。\n\n## 学习汉语和学习编程的异同点\n\n相同点\n\n- 基本语法\n- 大量成语\n- 写文章的手法和技巧\n\n不同点\n\n- 学习汉语 必须先学后用\n- 学习编程 可以现用现学\n\n## Object 类\n\nObject 类是类层次结构的根类，所有类都直接或者间接的继承自该类\n\n### 构造方法\n\n```java\npublic Object()\n```\n\n【注意】Object 只有一个无参构造方法\n\n### toString()\n\n#### 作用\n\n用来返回对象的字符串表示形式\n\n```java\npublic String toString()\n```\n\n返回值为：包名.类名@当前对象在内存空间中的首地址\n\n```java\ngetClass().getName() + '@' + Integer.toHexString(hashCode())\n```\n\n#### 重写 toString()\n\n由于默认情况下的数据对我们来说没有意义，一般会重写该方法用以展示对象的字段信息\n\n```java\npublic class Student {\n    String name;\n    int age;\n\n    // 重写 toString 方法\n    @Override\n    public String toString() {\n        return \"Student [name=\" + name + \", age=\" + age + \"]\";\n    }\n}\n```\n\n测试\n\n```java\npublic class TestStudent {\n    public static void main(String[] args) {\n        Student student = new Student(\"Buffer\",23);\n        System.out.println(student);\n    }\n}\n```\n\n结果\n\n```shell\nStudent [name=Buffer, age=23]\n```\n\n#### 总结\n\n> toString 方法用来展示一些对象的基本信息：完整的包名.类名@堆内存地址，通常我们用快捷键来重写这个方法来获取我们需要的数据信息\n\n### equals()\n\n#### 作用\n\n用来比较两个对象的地址是否相同\n\n```\npublic boolean equals(Object obj) {\n        return (this == obj);\n}\n```\n\n如果调用此方法的对象与 obj 的地址相同(即为同一个对象)，返回 true，否则返回 false\n\n#### 重写 equals()思路\n\n一般需要重写 equals() 方法用以判断两个对象的字段是否相同\n\n```shell\n1、判断两个对象的地址是否相同\n2、判断两个对象的类型是否一致\n3、判断两个对象所存储的数据是否相同\n```\n\n#### 重写 equals()\n\n```java\npublic class Student {\n    String name;\n    int age;\n\n    // 重写 equals 方法\n    @Override\n    public boolean equals(Object obj) {\n\n        // 判断是否是同一个对象(地址相同)，如果是返回 true\n        if (this == obj) {\n            return true;\n        }\n\n        // 判断数据类型是否一致，如果不一致返回 false\n        if (!(obj instanceof Student)) {\n            return false;\n        }\n\n        // 强制类型转换为当前类对象\n        Student student = (Student) obj;\n\n        // 所有字段全部满足时返回 true ，否则返回false\n        return this.name.equals(student.name) && this.age == student.age;\n    }\n}\n```\n\n测试\n\n```java\npublic class TestStudent {\n    public static void main(String[] args) {\n        Student student1 = new Student(\"Buffer\",23);\n        Student student2 = new Student(\"Banlance\",22);\n        Student student3 = new Student(\"Buffer\",23);\n\n        System.out.println(student1.equals(student2));\n        System.out.println(student1.equals(student3));\n    }\n}\n```\n\n结果\n\n```java\nfalse\ntrue\n```\n\n【注意】基本数据类型不能使用 equals() 方法\n\n#### 总结\n\n> 1、equals 方法用来判断两个对象是否相同，默认比较的是两个对象的内存首地址。我们可以通过重写 equals 方法实现对两个对象的比较\n>\n> 2、注意 equals 方法的调用者，不同的调用者调用方法是不一样的\n\n### hashCode()\n\n#### 作用\n\n返回对象的哈希码值，**具有唯一指向性**\n\n```java\npublic int hashCode()\n```\n\n#### 重写 hashCode()\n\nhashCode 方法要求必须和 equals() 方法的结果是对应的，如果两个对象的 equals 的结果为 true ，那这两个对象的 hashCode 的值一定相同，所以**只要重写了 equals 方法，就必须重写 hashCode 方法**\n\n```java\npublic class Student {\n    String name;\n    int age;\n\n    // 重写 equals 方法\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n\n        if (!(obj instanceof Student)) {\n            return false;\n        }\n\n        Student student = (Student) obj;\n\n        return this.name.equals(student.name) && this.age == student.age;\n    }\n\n    // 重写 hashCode 方法\n    @Override\n    public int hashCode() {\n        // 调用 Objects 工具类的 hash 方法，根据传入的参数生成一个指定的 hashCode 值\n        return Objects.hash(name, age);\n    }\n}\n```\n\n测试\n\n```java\npublic class TestStudent {\n    public static void main(String[] args) {\n        Student student1 = new Student(\"Buffer\",23);\n        Student student2 = new Student(\"Banlance\",22);\n        Student student3 = new Student(\"Buffer\",23);\n\n        System.out.println(student1.equals(student2));\n        System.out.println(student1.equals(student3));\n\n        System.out.println(student1.hashCode());\n        System.out.println(student2.hashCode());\n        System.out.println(student3.hashCode());\n    }\n}\n```\n\n结果\n\n```shell\nfalse\ntrue\n1892650872\n247063595\n1892650872\n```\n\nstudent1 和 student3 的 equals 方法返回值是 true ，所以他们的 hashCode 值相同\n\n#### 总结\n\n> 1、hashCode()用来获取当前对象的哈希值，表示对象的唯一标识。如果重写 equals()则必须重写 hashCode()方法\n>\n> 2、equals 相同 hashCode 一定相同，hashCode 相同 equals 不一定相同\n\n### getClass()\n\n获取当前对象的 Class 对象（字节码对象），直接打印会显示包含完整的包名,类名的信息\n\n```java\npublic final native Class<?> getClass();\nclass Cat {}\n\npublic class GetClassDemo {\n    public static void main(String[] args) {\n        Cat cat = new Cat();\n        System.out.println(cat.getClass());\n    }\n}\n```\n\n### finalize()\n\n```java\nprotected void finalize()\n```\n\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\n\n### 总结\n\n> Object 类是所有类的基类，提供了一个无参的构造方法和一些公共方法\n>\n> 通过重写 toString 方法来获取对象中的数据\n>\n> 通过重写 equals 方法和 hashCode 方法来判断两个对象是否相同，这两个方法必须同时重写\n>\n> getClass 用来获取 Class 对象\n>\n> finalize 方法用于垃圾回收，不可控\n\n## System 类\n\n`System` 类包含一些有用的类字段和方法。它不能被实例化。\n\n在 `System` 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。\n\n### 成员变量\n\n```java\n// 标准输入流，常用于键盘录入\npublic final static InputStream in = null\n\n// 标准输出流，常用于打印信息\npublic final static PrintStream out = null;\n\n// 标准错误输出流，常用于打印错误信息\npublic final static PrintStream err = null;\npublic class SystemFieldDemo {\n    public static void main(String[] args) {\n        // 通过Scanner测试标准输入\n        Scanner sc = new Scanner(System.in);\n\n        String next = sc.next();\n\n        // 通过System.out.print测试标准输出流\n        System.out.println(next);\n\n        sc.close();\n\n        // 通过System.err.print测试标准输出流\n        System.err.println(\"打印错误报告\");\n    }\n}\n```\n\n### 构造方法\n\n构造方法私有化，无法创建对象\n\n```java\n/** Don't let anyone instantiate this class */\nprivate System() {\n}\n```\n\n### arraycopy()\n\n这个方法表示复制数组，从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。\n\n```java\npublic static native void arraycopy(Object src,  int  srcPos,\n                                        Object dest, int destPos,\n                                        int length);\n```\n\n参数解释\n\n> src - 源数组。\n> srcPos - 源数组中的起始位置。\n> dest - 目标数组。\n> destPos - 目标数据中的起始位置。\n> length - 要复制的数组元素的数量。\n\n```java\npublic class ArraycopyDemo {\n    public static void main(String[] args) {\n        // 创建一个长度为5的int类型数组arr\n        int[] arr = new int[5];\n\n        // 为数组arr赋值\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = i;\n        }\n\n        // 遍历数组arr\n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(arr[i]);\n        }\n\n        System.out.println(\"------------------\");\n\n        // 创建一个新的长度为5的int类型数组newArr\n        int[] newArr = new int[5];\n\n        // 调用System的arraycopy方法，分别传入对应的参数\n        System.arraycopy(arr, 0, newArr, 0, 5);\n\n        // 遍历newArr数组\n        for (int i = 0; i < newArr.length; i++) {\n            System.out.println(newArr[i]);\n        }\n    }\n}\n```\n\n### currentTimeMillis()\n\n返回以毫秒为单位的当前时间。\n\n```java\npublic static native long currentTimeMillis();\n```\n\n【注意】\n\n> 1、这个方法的返回值是 long 类型\n>\n> 2、当前时间与协调世界时 1970 年 1 月 1 日午夜之间的时间差（以毫秒为单位测量）\n\n```java\npublic class CurrentTimeMillsDemo {\n    public static void main(String[] args) {\n\n        long currentTimeMillis = System.currentTimeMillis();\n\n        System.out.println(\"毫秒：\" + currentTimeMillis);\n        System.out.println(\"年：\" + currentTimeMillis/1000/60/60/24/365);\n\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        String date = sdf.format(currentTimeMillis);\n\n        System.out.println(date); // 2020-10-06 17:53:02\n    }\n}\n```\n\n### gc()\n\n运行垃圾回收器。在此之前会调用 Object 的 finalize()\n\n```java\npublic static void gc()\n```\n\n> System.gc()可用于垃圾回收。当使用 System.gc()回收某个对象所占用的内存之前，通过要求程序调用适当的方法来清理资源。在没有明确指定资源清理的情况下，Java 提高了默认机制来清理该对象的资源，就是调用 Object 类的 finalize()方法。finalize()方法的作用是释放一个对象占用的内存空间时，会被 JVM 调用。而子类重写该方法，就可以清理对象占用的资源，该方法有没有链式调用，所以必须手动实现。\n\n```java\nclass Person {\n    private String name;\n    private int age;\n\n    // 构造方法，getter、setter方法、toString方法\n\n    /*\n     * 通过重写finalize方法验证调用gc会执行此方法\n     */\n    @Override\n    protected void finalize() throws Throwable {\n        System.out.println(\"执行finalize方法回收垃圾：\" + this);\n        super.finalize();\n    }\n}\n\npublic class GcDemo {\n    public static void main(String[] args) {\n        System.out.println(new Person(\"张三\", 16));\n        System.gc();\n    }\n}\n```\n\n> 从程序的运行结果可以发现，执行 System.gc()前，系统会自动调用 finalize()方法清除对象占有的资源，通过 super.finalize()方式可以实现从下到上的 finalize()方法的调用，即先释放自己的资源，再去释放父类的资源。\n>\n> 但是，不要在程序中频繁的调用垃圾回收，因为每一次执行垃圾回收，jvm 都会强制启动垃圾回收器运行，这会耗费更多的系统资源，会与正常的 Java 程序运行争抢资源，只有在执行大量的对象的释放，才调用垃圾回收最好\n\n### exit()\n\n终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。\n\n```java\npublic static void exit(int status)\npublic class ExitDemo {\n    public static void main(String[] args) {\n        System.out.println(\"程序执行开始\");\n        // 执行此方法后关闭虚拟机，程序不会再向下执行\n        System.exit(0);\n        System.out.println(\"程序执行结束\");\n    }\n}\n```\n\n### 总结\n\n> System 类提供了一些和系统相关的类字段和方法，便于我们和底层进行交互。\n>\n> 比较常用的就是 arraycopy()和 currentTimeMills()，其他不需要关注\n\n## Scanner 类\n\n一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。\n\n### 类声明\n\n```java\npublic final class Scanner implements Iterator<String>, Closeable {}\n```\n\n> 这里我们需要关注三个点：\n>\n> 1、final 修饰，不能被继承\n>\n> 2、实现了 Iterator 接口(迭代器接口)，主要使用其中的 hasNext 方法和 next 方法\n>\n> 3、实现了 Closeable 接口，主要使用其中的 close 方法\n\n```java\n// 用来判断是否还有下一个元素录入\npublic boolean hasNext()\n\n// 用来接收录入的数据\npublic String next()\n\n// 用来关闭资源(输入流)\npublic void close()\n```\n\n### 构造方法\n\n从指定的扫描输入流构造一个 Scanner\n\n```java\npublic Scanner(InputStream source)\n```\n\n案例代码\n\n```java\npublic class Demo1 {\n    public static void main(String[] args) {\n        // java.util.Scanner.Scanner(InputStream source)\n        // 使用构造方法，传入一个标准输入流，创建一个Scanner对象\n        Scanner sc = new Scanner(System.in);\n    }\n}\n```\n\n### next()\n\n```java\n// 此方法用于接收从键盘录入的字符串\npublic String next()\n```\n\n案例代码\n\n```java\npublic class Demo1 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 从键盘录入一个字符串\n        String str = sc.next();\n\n        System.out.println(str);\n    }\n}\n```\n\n### nextInt()\n\n#### 常用方法\n\n```java\n// 此方法用于从键盘获取一个int类型的数据\npublic int nextInt()\n```\n\n案例代码\n\n```java\npublic class Demo1 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 从键盘录入一个字符串\n        int num = sc.nextInt();\n\n        System.out.println(num);\n    }\n}\n```\n\n#### 方法的重载：nextInt(int radix)\n\n```java\n// 指定进制数从键盘录入一个int类型的数据\npublic int nextInt(int radix)\n```\n\n> int radix 参数表示一个进制数，如果从键盘录入的数据超过了指定的进制数就会报错，默认是 10\n\n案例代码\n\n```java\npublic class Demo5 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        /*\n         * 8表示接收8进制内的数，及0~7\n         *\n         * 从键盘录入的数据中不能出现8及其以上的数字，如果有会报错：\n         * InputMismatchException 输入类型不匹配异常\n         */\n        int num = sc.nextInt(8);\n\n        System.out.println(num);\n    }\n}\n```\n\n#### 相关方法：用法类似，要求触类旁通\n\n```java\npublic String nextLine()\npublic byte nextByte()\npublic byte nextByte(int radix)\npublic short nextShort()\npublic long nextLong()\npublic float nextFloat()\npublic double nextDouble()\npublic BigInteger nextBigInteger()\n```\n\n### hasNextInt()\n\n```java\n// 如果此扫描器的输入中有另一个标记，则返回 true。在等待要扫描的输入时，此方法可能阻塞。扫描器将不执行任何输入。\npublic boolean hasNext()\n```\n\n> 此方法可用于合法性判断\n\n案例\n\n```java\npublic class Demo2 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        if (sc.hasNextInt()) {\n            System.out.println(sc.nextInt());\n        } else {\n            System.out.println(\"输入的数据类型有误\");\n        }\n    }\n}\n```\n\n其他相关方法\n\n```java\npublic boolean hasNext()\npublic boolean hasNextLine()\npublic boolean hasNextBoolean()\npublic boolean hasNextByte()\npublic boolean hasNextShort()\npublic boolean hasNextLong()\npublic boolean hasNextFloat()\npublic boolean hasNextDouble()\n```\n\n### 扩展：回车换行问题\n\n```java\npublic class Demo3 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int num = sc.nextInt();\n        String str = sc.nextLine();\n\n        System.out.println(\"str:\" + str + \"，num:\" + num);\n    }\n}\n```\n\n> 当从键盘录入第一个数字后，敲下的回车键实际是两个字符：\\r\\n，所以键盘实际是录入了这两个字符并且结束，显示的效果和没有录入字符串相同\n>\n> 补充：\n>\n> \\r：回车，回到行首\n>\n> \\n：换行\n>\n> 电脑上的回车键(Enter 键)实际上是回车式换行，会先执行回车，后执行换行\n\n扩展：多行录入\n\n可以通过 hasNext 的重载方法来实现多行录入\n\n```java\n// 如果从键盘录入指定的pattern标记，则返回true，否则返回false\npublic boolean hasNext(String pattern)\n```\n\n案例\n\n```java\npublic class Demo4 {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        StringBuffer sb = new StringBuffer();\n\n        // 将#作为结束的标记，当遇到#时结束循环\n        while (!sc.hasNext(\"#\")) {\n            sb.append(sc.next());\n        }\n\n        System.out.println(sb);\n    }\n}\n```\n\n### 总结\n\n> Scanner 通过标准输入流来从键盘输入，后期不会用到，目前常用的方法为 nextXxx()和 hasNextXxx()\n\n## Math 类\n\nMath 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。\n\n### 成员变量\n\n> 静态常量，全大写，通过类名调用\n\n```java\n// 比任何其他值都更接近 e（即自然对数的底数）的 double 值\npublic static final double E = 2.7182818284590452354;\n\n// 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值\npublic static final double PI = 3.14159265358979323846;\n```\n\n### 构造方法\n\n> 构造方法私有化，不能创建对象\n\n```java\nprivate Math() {}\n```\n\n### 成员方法\n\n> 所有方法全部都被 static 修饰，可以通过类名直接调用\n\n```java\n// 获取绝对值\npublic static int abs(int a)\n\n// 对数据进行向上取整\npublic static double ceil(double a)\n\n// 对数据进行向下取整\npublic static double floor(double a)\n\n// 获取最大值\npublic static int max(int a,int b)\n\n// 获取最小值\npublic static int min(int a, int b)\n\n// 获取a的b次幂\npublic static double pow(double a,double b)\n\n// 随机数，范围：[0.0, 1.0)，注意左闭右开，包含左边不包含右边，\npublic static double random()\n\n// 四舍五入\npublic static int round(float a)\n\n// 获取正平方根\npublic static double sqrt(double a)\n```\n\n案例代码\n\n```java\npackage com.fc.r.math;\n\npublic class MathDemo1 {\n    public static void main(String[] args) {\n        // 自然对数的底\n        System.out.println(\"Math.E:\" + Math.E);\n        // π\n        System.out.println(\"Math.PI:\" + Math.PI);\n\n        System.out.println(\"-----------------\");\n\n        // 绝对值\n        System.out.println(\"abs:\" + Math.abs(-1));\n        System.out.println(\"abs:\" + Math.abs(1));\n\n        System.out.println(\"-----------------\");\n\n        // 向上取整\n        System.out.println(\"ceil:\" + Math.ceil(12.34));\n        System.out.println(\"ceil:\" + Math.ceil(12.56));\n\n        System.out.println(\"-----------------\");\n\n        // 向下取整\n        System.out.println(\"floor:\" + Math.floor(12.34));\n        System.out.println(\"floor:\" + Math.floor(12.56));\n\n        System.out.println(\"-----------------\");\n\n        // 最大最小值\n        System.out.println(\"max:\" + Math.max(12.34, 56.78));\n        System.out.println(\"max:\" + Math.max(12.34, Math.max(56.78, 100)));\n        System.out.println(\"min:\" + Math.min(12.34, 56.78));\n\n        System.out.println(\"-----------------\");\n\n        // a的b次方\n        System.out.println(\"pow:\" + Math.pow(2, 10));\n\n        System.out.println(\"-----------------\");\n\n        // 随机数1~10\n        System.out.println(\"random:\" + (int) (Math.random() * 10 + 1));\n\n        System.out.println(\"-----------------\");\n\n        // 四舍五入\n        System.out.println(\"round:\" + Math.round(12.34));\n        System.out.println(\"round:\" + Math.round(12.56));\n\n        System.out.println(\"-----------------\");\n\n        // 获取正平方根\n        System.out.println(\"sqrt:\" + Math.sqrt(16));\n    }\n}\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java面向对象","url":"/posts/JavaOOP.html","content":"\n# Java 面向对象\n\n## 面向对象概念\n\n### 什么是 Object 对象对象\n\n相当于中文语义”东西”。Object 是指一个具体事物实例，比如飞机、狗、运气、哲学等等看得见的，看不见的，有形的，无形的，具体的，抽象的都是对象，总之“一切皆 object”。\n\n### 面向对象 ObjectOriented\n\n面向对象是指面向客观事物之间的关系。人类日常的思维方式是面向对象的，自然界事物之间的关系是对象与对象之间的关系。\n\n**优点**\n\n- 直观，高效，与人类的思维习惯一致\n- 信息隐藏，提高了程序的可维护性和安全性\n- 提高了程序的可重用性\n\n### 面向对象定义\n\n首先根据客户需求抽象出业务对象；\n\n然后对需求进行合理分层，构建相对独立的业务模块；\n\n之后设计业务逻辑，利用多态、继承、封装、抽象的编程思想，实现业务需求\n\n最后通过整合各模块，达到高类聚、低耦合的效果，从而满足客户要求\n\n### 面向对象分析 OOAOOA/面向对象设计 OODOOD\n\nOOADObjectOrientAnalysisDesign 面向对象分析和设计，面向对象分析不设计 ObjectOrientAnalysisDesign 面向对象分析和设计，面向对象分析不设计是现在软件企业广为采用的一项有效技术。OOAD 方法要求在设计中要映射现实世界中指定问题域中的对象和实体，例如：顾客、汽车和销售人员等。这就需要设计要尽可能低接近现实世界，即以最自然的方式表述实体。\n\n> **优点：**为能够构建与现实世界相对应的问题模型，并保持他们的结构、关系和行为模式\n\n### 面向对象概念\n\n```shell\n1、类型(类)指一个名词概念，如：客人、菜品、厨师\n\n2、引用(变量)指引用具体概念实例的代词，如：某人、特价菜\n\n3、对象(东西)指具体概念的个体实例，如：张三丰是个人、一盘大盘鸡\n    如上三者关系之间的关系可以体现为：“今天的特价菜是一盘大盘鸡”\n4、行为(方法)\n\n5、多态 行为或引用，在具体情形下会发生变化的现象。\n    如：“一只动物”可以是“一匹马”、“一头驴”、“一只猴子”，多态的\n6、封装 任何对象实例都是尽可能封装，减少暴露，它的实现细节对你是透明的(看不到的)。比如：只能看到汽车的壳子、轮胎等，看不到发动机\n\n7、继承 概念的继承关系\n```\n\n### 面向对象思想\n\n```shell\n1、面向对象是基于面向过程的编程思想\n\n2、万物皆对象\n\n3、对象具有唯一性\n\n4、任何对象都具有一定的特征和行为；特征是事物的基本描述，行为是事物的功能\n\n5、类是一组相关的属性和方法的集合，是一个抽象的概念\n\n6、对象是类的具体存在\n\n7、在一组相同或相似的对象中，抽取出共性的特征和行为，保留所关注的部分就是类的抽取\n\n8、类是模板、图纸，通过类创造的对象就是实体\n```\n\n## 面向对象特征\n\n面向对象的编程语言有封装、继承、抽象、多态等四个主要的特征\n\n### 封装\n\n#### 概述\n\n是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。核心是归纳总结\n\n封装是保证软件部件具有优良的模块性的基础。\n\n封装的目标：实现软件部件的“高内聚、低耦合”，防止程序相互依赖性而带来的变动影响。\n\n面向对象的封装就是把描述一个对象的属性和行为的代码封装在一个“模块”中，也就是一个类中，属性用变量定义，行为用方法进行定义，方法可以直接访问同一个对象中的属性。通常情况下，只要记住让变量和访问这个变量的方法放在一起，将一个类中的成员变量全部定义成私有的，只有这个类自己的方法可以访问到这些成员的变量，这就基本实现了对象的封装，就很容易找到分配到这些类的方法了，就基本上算是会面向对象的编程了。\n\n> 把对同一事物进行操作的方法和相关的方法放在同一个类中，把方法和它操作的数据放在同一个类中。\n\n#### 特点\n\n> 提高代码的复用度、安全性，不必关心具体细节，便于开发\n\n#### JavaBean 规范化封装\n\n```shell\n1. 要求Java中的所有实体类成员变量全部私有化，最少提供一个无参数构造方法，对应成员变量实现setter和getter方法\n2. JavaBean规范，是为了后期开发汇总更好的代码适配度，提高代码运行的统一性，能够满足框架的使用\n3. JavaBean规范只是一个规范，而且是作为一个基础规范，操作都是可以使用快捷键来完成的！！！\nclass Person {\n    private String name;\n    private int age;\n    private char sex;\n    private boolean alive;\n\n    public Person() {}\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n    public char getSex() {\n        return this.sex;\n    }\n\n    public boolean isAlive() {\n        return alive;\n    }\n\n    public void setAlive(boolean alive) {\n        this.alive = alive;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public void setSex(char sex) {\n        this.sex = sex;\n    }\n}\n```\n\n### 继承\n\n#### 概念\n\n把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容。这个关系叫继承。\n\n```java\n关键字：extends\n\n格式:\n    class Son extends Father {\n\n    }\n\n//一个孩子只能有一个父亲\n//一个父亲可以有多个孩子\n```\n\n#### 特点\n\n> 1. Java 为单继承，一个类只能有一个直接父类，但可以多级继承，属性和方法逐级叠加\n> 2. 构造方法只可服务于本类，不可继承，子类执行构造方法前会默认调用父类的无参构造方法。可以通过 super 去访问父类的构造方法\n> 3. private 修饰的属性和方法不能被继承\n\n#### extends\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        // 创建一个父类对象\n        Father father = new Father();\n\n        // 父类调用父类的属性和方法\n        father.name = \"父\";\n        System.out.println(father.name);\n        father.game();\n\n        System.out.println(\"-------------\");\n\n        // 创建一歌子类对象\n        Son son = new Son();\n\n        // 子类调用子类的属性和方法\n        son.age = 16;\n        System.out.println(son.age);\n        son.study();\n\n        // 子类调用父类的属性和方法(public修饰)\n        son.name = \"子\";\n        System.out.println(son.name);\n        son.game();\n\n\n        /*\n         * 子类调用父类private修饰的属性和方法\n         *\n         * 报错\n         * The field Father.suffer is not visible\n         * The method cook() from the type Father is not visible\n         *\n         * 由此可知子类不能调用父类私有化的属性和方法\n         */\n//        son.suffer = 10;\n//        son.cook();\n    }\n}\n\npublic class Father {\n    public String name;\n\n    private int suffer;\n\n    public void game() {\n        System.out.println(\"下棋\");\n    }\n\n    private void cook() {\n        System.out.println(\"做饭\");\n    }\n}\n\npublic class Son extends Father{\n    public int age;\n\n    public void study() {\n        System.out.println(\"子类 -- 学习\");\n    }\n}\n```\n\n#### 优点\n\n> 1. 提高了代码的复用性\n> 2. 提高了代码的维护性\n> 3. 让类与类之间产生了一个关系，是多态的前提\n\n#### 缺点\n\n> 1. 让类的耦合性增强。这样某个类的改变，就会影响到其他和该类相关的类\n> 2. 打破了封装性\n\n#### 总结\n\n> 1. Java 中只有单继承\n> 2. 子类可以继承父类的非私有属性和方法（非 private 修饰的）\n> 3. 执行子类的构造方法前会默认执行父类的无参构造方法\n\n### 抽象\n\n不能实例化的类就是抽象类，用 abstract 修饰\n\n##### 构成\n\n```java\nabstract class 类名 {\n    成员变量\n    构造方法\n    成员方法\n        非抽象方法\n        抽象方法\n}\n```\n\n##### 要求\n\n```shell\n1、抽象类和抽象方法必须用关键字 abstract 修饰\n2、抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类\n3、abstract 修饰的方法没有方法体，且子类必须重写\n4、抽象类不能实例化，因为 abstract 类中有 abstract 方法\n5、抽象类的子类\n        也可以是一个抽象类，可以重写也可以不重写父类的抽象方法。\n        可以是一个具体类。这个类必须重写抽象类中的所有抽象方法。(可以实例化)\npublic class TestSon {\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.play();\n    }\n}\n\n// 抽象类\nabstract class Father {\n    String name;\n    int age;\n\n    public Father() {\n    }\n\n    public void eat() {\n        System.out.println(\"吃饭\");\n    }\n\n    // 抽象方法\n    abstract public void play();\n}\n\nclass Son extends Father {\n    // 抽象方法的重写\n    @Override\n    public void play() {\n        System.out.println(\"玩游戏\");\n    }\n}\n```\n\n### 多态\n\n**二者具有直接或间接的继承关系时，父类引用指向子类对象，从而产生多种形态；接口的引用指向实现接口的类对象也是多态**\n\n#### 特点\n\n多态场景下，父类引用调用方法，如果被子类重写过，优先执行子类重写过后的方法\n\n```java\npublic class testCar{\n    public static void main(String[] args) {\n        // 父类引用指向子类对象\n        Vehicle vehicle = new Car();\n\n        // 优先执行子类重写过的方法\n        vehicle.run();    // Car run！！！\n    }\n}\nclass Vehicle {\n    public void run() {\n        System.out.println(\"Vehicle run！！！\");\n    }\n}\nclass Car extends Vehicle {\n    @Override\n    public void run() {\n        System.out.println(\"Car run！！！\");\n    }\n}\n```\n\n#### 应用场景一\n\n使用父类作为方法形参实现多态，使方法参数的类型更为宽泛\n\n```java\npublic class TestCar {\n    public static void main(String[] args) {\n        Vehicle vehicle = new Car();\n        vehicle.type = \"小汽车\";\n\n        Bike bike = new Bike();\n        bike.type = \"自行车\";\n\n        Bus bus = new Bus();\n        bus.type = \"公交车\";\n\n        Employee employee = new Employee(\"你的迪丽热巴\");\n        employee.goHome(vehicle);\n        employee.goHome(bus);\n    }\n}\n\nclass Employee {\n    String name;\n\n    public Employee() {\n    }\n\n    public Employee(String name) {\n        this.name = name;\n    }\n\n    public void goHome(Vehicle vehicle) {\n        System.out.println(this.name + \"乘坐\" + vehicle.type + \"交通工具回家\");\n    }\n}\n\nclass Vehicle {\n    String type;\n\n    public void run() {\n        System.out.println(\"Vehicle run！！！\");\n    }\n}\n\nclass Bus extends Vehicle {\n    @Override\n    public void run() {\n        System.out.println(\"Bus run！！！\");\n    }\n}\n\nclass Car extends Vehicle {\n    @Override\n    public void run() {\n        System.out.println(\"Car run！！！\");\n    }\n}\n\nclass Bike extends Vehicle {\n    @Override\n    public void run() {\n        System.out.println(\"Bike run！！！\");\n    }\n}\n```\n\n#### 应用场景二\n\n使用父类作为方法返回值实现多态，使方法可以返回不同子类对象\n\n```java\npublic Vehicle buyVehicle(int money) {\n        Vehicle vehicle = null;\n\n        if (money >= 100) {\n            Bus bus = new Bus();\n            bus.speed = 60;\n            bus.price = 1230000.0;\n            bus.seatNum = 16;\n            bus.type = \"公交车\";\n            vehicle = bus;\n\n        } else if (money >= 30) {\n            Car car = new Car();\n            car.price = 310000.0;\n            car.speed = 90;\n            car.type = \"小汽车\";\n            car.brand = \"BMW\";\n            vehicle = car;\n\n        } else if (money >= 1) {\n            Bike bike = new Bike();\n            bike.type = \"捷安特自行车\";\n            bike.speed = 40;\n            bike.price = 2000.0;\n            bike.color = \"红色\";\n            vehicle = bike;\n        }\n\n        return vehicle;\n    }\n```\n\n#### 向上装箱与向下拆箱\n\n```java\nclass Animal{}\n\nclass Cat extends Animal{}\n\nclass Dog extends Animal{}\n\nclass Fish extends Animal {}\n\npublic class Test {\n    public static void main(String[] args) {\n        showAnimal(new Animal());    // code.polymorphic.animal.Animal@7852e922\n        // 向上转型\n        showAnimal(new Cat());    // code.polymorphic.animal.Cat@4e25154f\n        // 向上转型\n        showAnimal(new Dog());    // code.polymorphic.animal.Dog@70dea4e\n        // 向上转型\n        showAnimal(new Fish());    // code.polymorphic.animal.Fish@5c647e05\n\n        System.out.println(\"----------------------\");\n\n        Animal animal = getAnimal();\n        // 向下转型\n        Cat cat = (Cat) getCat();\n        // 向下转型\n        Dog dog = (Dog) getDog();\n        // 向下转型\n        Fish fish = (Fish) getFish();\n\n        System.out.println(animal);    // code.polymorphic.animal.Animal@33909752\n        System.out.println(cat);    // code.polymorphic.animal.Cat@55f96302\n        System.out.println(dog);    // code.polymorphic.animal.Dog@3d4eac69\n        System.out.println(fish);    // code.polymorphic.animal.Fish@42a57993\n    }\n\n    /**\n     * 展示动物\n     * @param animal\n     */\n    public static void showAnimal(Animal animal) {\n        System.out.println(animal);\n    }\n\n    /**\n     * 得到动物\n     * @return 返回一个Animal对象\n     */\n    public static Animal getAnimal() {\n        return new Animal();\n    }\n\n    /**\n     * 得到猫\n     * @return 返回一个Cat对象\n     */\n    public static Animal getCat() {\n        return new Cat();\n    }\n\n    /**\n     * 得到狗\n     * @return 返回一个Dog对象\n     */\n    public static Animal getDog() {\n        return new Dog();\n    }\n\n    /**\n     * 得到鱼\n     * @return 返回一个Fish对象\n     */\n    public static Animal getFish() {\n        return new Fish();\n    }\n}\n```\n\n#### instanceof 关键字\n\n用于判断当前对象是否是某个类，或者其子类、实现类的实例。如果是返回 true，否则返回 false。\n\n```\n/**\n * 动物类\n */\nclass Animal {\n}\n\n/**\n * 老虎类\n */\nclass Tiger extends Animal {\n\n}\n\n/**\n * 熊猫类\n */\nclass Panda extends Animal {\n\n}\n\n/**\n * 猴子类\n */\nclass Monkey extends Animal {\n\n}\n\npublic class AnimalDemo {\n    public static void main(String[] args) {\n        Animal ani = getAnimal();\n\n        if (ani instanceof Panda) {\n            // ani一定是panda对象或子类对象\n            Panda panda2 = (Panda) ani;\n            System.out.println(\"这是熊猫：\" + panda2);\n            showPanda(panda2);\n        } else {\n            System.out.println(\"这是动物：\" + ani);\n        }\n    }\n\n    // 获取动物，返回一个Panda对象\n    public static Animal getAnimal() {\n        return new Panda();\n    }\n\n    // 展示熊猫对象\n    public static void showPanda(Panda panda) {\n        System.out.println(panda);\n    }\n}\n```\n\n【注意】**使用 instanceof 关键字做判断时， instanceof 操作符的左操作数必须和右操作数存在继承或实现关系**\n\n#### 总结\n\n> 1. 父类引用指向子类对象，接口引用指向实现类对象\n> 2. instanceof 用以比较对象是否是类或父类的实例，接口的实现类\n\n## 访问权限权限修饰符\n\n### Java 中的访问修饰符\n\n|           | 类内部 | 同包下 | 子类中 | 非同包 |\n| --------- | ------ | ------ | ------ | ------ |\n| public    | √      | √      | √      | √      |\n| protected | √      | √      | √      | ×      |\n| 默认不写  | √      | √      | ×      | ×      |\n| private   | √      | ×      | ×      | ×      |\n\n### public 公共的公共的关键字\n\n### protected 受保护的受保护的关键字\n\n### private 私有的私有的关键字\n\n```java\n1、可以修饰成员变量和成员方法\n\n2、被private修饰的变量和方法仅本类中可用\n\n3、被private修饰的变量需要提供get、set方法供类外调用使用\n\n4、boolean类型的 get 方法比较特殊：\n\n    public boolean isName(String name){\n        return name;\n    }\n```\n\n> 在使用 Eclipse 写 Java 程序同时按住 shift+Alt+s 选择“Generate Getters and Setters”可以自动写出 set、get 的方法\n\n```java\npublic class Dog {\n    private String name;\n    int age;\n    public String getName() {\n        return this.name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    private void function() {\n        System.out.println(\"method be execute!\");\n    }\n\n    public void executeFunction() {\n        this.function();\n    }\n}\n```\n\n### 总结\n\n> 1. 般我们最常用的就是 private 和 public，建议任何情况下都使用访问修饰符对变量和方法进行限制\n> 2. public 权限最高，整个项目中都可以访问（同一个项目），private 权限最小，只能在本类中使用\n> 3. 被 private 修饰的变量和方法可以通过提供公共的方法对其进行访问\n\n## 匿名对象\n\n### 概述\n\n没有名字的对象，是对象的一种简化表示形式\n\n### 特性\n\n一次性，每次使用都是一个新的对象\n\n### 使用情景\n\n> 1、对象调用方法仅使用一次，然后等待销毁\n>\n> 2、作为实际参数传递\n\n```java\npublic class TestDog{\n    public static void main(String[] args) {\n        // 对象调用方法仅使用一次\n        new Dog().sleep();\n\n        // 作为实际参数传递\n        useDog(new Dog());\n    }\n\n    public static void useDog(Dog dog) {\n        dog.sleep();\n    }\n}\n\nclass Dog {\n    String name;\n    int age;\n\n    public void sleep() {\n        System.out.println(\"小狗睡觉.....\");\n    }\n}\n```\n\n### 优点\n\n提高开发效率，简化代码结构\n\n## 类和对象\n\n### 类\n\n类是对某一类事物的描述，是抽象的、概念上的定义。**类是模板，包含了一类事物所共有的特征属性属性和行为方法方法**\n\n> 属性描述：学号、姓名、性别、年龄、身高、体重、地址、电话、微信、QQ…\n>\n> 行为描述：吃饭、睡觉、上班、学习、娱乐…\n\n### 对象\n\n**对象是类的具体体现（**[**属性和方法**](https://localhost:63342/ialoe.github.io-master/posts/36.html?_ijt=4djrf4sgdibf0v57aogg3jvm4k)**），是具体的、独一无二的个体。**\n\n以班长为例：\n\n> 属性描述：班长的学号、班长的姓名、班长的身高…\n>\n> 行为描述：班长吃饭、班长睡觉、班长学习…\n\n### 类和对象的关系\n\n类是对象的抽象，对象是类的具体实现\n\n### 类的定义\n\n类是一种自定义的数据类型\n\n```java\n格式：\n    class 类名 {\n        成员变量;// Fieldi\n\n        成员方法;// Method\n    }\n\nclass：\n    定义类的关键字\n\n类名：\n    大驼峰命名，首字母大写，见名知意\n    类名就是一种数据类型（自定义引用的数据类型），就是模板的名字\n\n成员变量（属性/特征描述）：\n    定义在类中，方法外的变量，用来描述类的特征\n\n成员方法（行为描述）：\n    定义在类中，用来描述类的功能\n```\n\n### 总结\n\n> Java 中的类和对象\n>\n> - 类是对象的抽象，具有公共的特征和行为，对象是类的具体实现，具有唯一的特征和行为\n\n> 基础数据类型与类和对象\n>\n> - 类就是一种自定义的数据类型，由类名，属性和方法构成\n> - 对象就是一种数据类型的数据，由对象名，属性和方法构成\n\n> 类和对象的定义和使用\n>\n> - 格式和规范，一定要按照标准\n\n> **注意**\n\n```shell\n大写开头的都是类\n小写开头的都是变量\n带()的都是方法\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java方法","url":"/posts/JavaMethod.html","content":"\n# Java 方法\n\n## 为什么要使用方法\n\n### 生活中的方法（工具）\n\n螺丝刀，锤子，扳手\n\n> 1、提高复用度，可重复使用\n>\n> 2、提高效率\n\n开发中使用方法来实现同样的效果，为了解决复用和效率的问题\n\n## 概念\n\n实现特定功能的一段代码，可以被反复使用\n\n## 方法的构成\n\n```shell\n固定格式：\n    public static\n返回值类型：\n    表示方法执行完成后返回的数据类型\n    如果没有返回值类型就用 void ，如果有就使用对应的返回值类型\n方法名：\n    小驼峰命名，见名知意，动宾结构\n形参列表：\n    用来接收用户传入的数据，可以是基本数据类型或者引用数据类型，需要声明局部变量。\n    如果不需要形参就写 ()，如果有多个就写多个\n方法体：\n    {}\n```\n\n> 注意：\n\n> 1. 固定的格式（public static）不要问，因为不影响我们写代码，后期会讲！！！\n> 2. 方法要写上文档注释，为了更方便地阅读代码\n\n## 方法声明格式\n\n```java\npublic static returnType methodName(dataType FormerParameter) {\n    method body;\n}\n\npublic static 返回值类型 方法名(数据类型 形参名) {\n    方法体;\n}\n```\n\n## 声明位置\n\n定义在类中，与其他方法（main 方法）并列\n\n## 无返回值方法调用\n\n```java\nmothodName(actualParameter);\n方法名(实参);\n```\n\n> 注意：\n\n> 方法和变量最大的区别就是方法后面有小括号，即便没有参数也有小括号\n>\n> 小驼峰\n\n### 无参无返回值调用\n\n```java\nclass TestMethod1 {\n    public static void main(String[] args) {\n        printHelloWorld();\n    }\n\n    /**\n    * 打印Hello World\n    */\n    public static void printHelloWorld() {\n        System.out.println(\"Hello World\");\n    }\n}\n```\n\n> 注意\n>\n> 1. main 方法是程序的入口，所有的代码和方法都需要在 main 方法中被完成和调用\n> 2. 方法名的后面一定要跟\n> 3. 方法和其他方法的关系是并列关系\n\n### 有参无返回值调用\n\n```java\nimport java.util.Scanner;\n\nclass TestMethod3 {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.println(\"请输入一个数：\");\n        int num = scanner.nextInt();\n\n        printIntNum(num);\n    }\n\n    /**\n    * 展示用户传入的int类型数据\n    *\n    * @param num 这里需要传入一个int类型的数据\n    */\n    public static void printIntNum(int num) {\n        System.out.println(\"您输入的数为：\" + num);\n    }\n}\n```\n\n> 注意：\n>\n> 1. 如果方法声明时带有形式参数，那么方法调用时就必须携带实际参数 1\n> 2. 如果方法声明时没有形式参数，方法调用时就不能有实参\n> 3. 声明时有几个形式参数，调用时就传入几个实际参数，形参实参个数不一样编译会报错\n> 4. 实参与形参的数据类型不一样，编译器会报错\n> 5. 实参与形参的顺序不一样，编译器会报错\n\n## 形参与实参\n\n> 形参：用来接收调用该方法时传递的参数。只有在被调用的时候才分配内存空间，一旦调用结束，就释放内存空间。因此仅仅在方法内有效。\n> 实参：方法调用时用于传入的数据，用来给形参赋值，数据类型要求一致\n\n### 形参举例\n\n```java\n  public void swap(int a, int b) {\n         int temp = a;\n         a = b;\n         b = temp;\n         System.out.println(\"a:\" + a + \" b:\" + b);\n     }\n 这里边的a,b就是形参，temp是一个局部变量，方法结束，在栈空间中就会被销毁\n```\n\n### 实参举例\n\n```java\n 调用上面的方法\n swap(1,2);\n 其中1和2就是实际的参数值，就叫实参\n```\n\n## 返回值\n\n方法中的返回值有两种情况，即有返回值和无返回值，如果定义方法时有返回值类型，就需要返回相对应的数据类型\n\n```java\n基本数据类型\n    值传递，不改变自身\n引用数据类型\n    引用传递，改变自身\nvoid\n    无返回值\n1、一个方法只能有一个返回值\n2、分支结构的每一个分支都需要正确的返回值\n3、返回值可以接收也可以不接收\n```\n\n### return 关键字\n\n#### 作用\n\n结束当前方法，返回至调用方法处，如果定义了返回值类型就返回对应类型的数据\n\n【注意】[数据类型一致化](https://localhost:63342/ialoe.github.io-master/posts/35.html?_ijt=bqlst5qgc5f4q088n5220dj5j)\n\n#### 格式\n\n```java\nreturn 需要返回的数据;\n```\n\n### 注意\n\n```shell\n1、单一职能原则，一个方法只做一件事\n2、注意形参和实参数据类型一致化\n3、返回值类型和参数没有关系\n4、方法名要符合小驼峰命名规则\n5、return的下一行代码不会执行\n```\n\n## 有返回值方法调用\n\n### 无参有返回值的方法：give me five\n\n```java\nclass TestMethod1 {\n    public static void main(String[] args) {\n        System.out.println(giveMeFive());\n    }\n\n    /**\n    * 返回一个整数 5\n    *\n    * @return 5 int类型\n    */\n    public static int giveMeFive() {\n        return 5;\n    }\n}\n```\n\n### 有参有返回值的方法：两个数求和\n\n```java\npublic class MethodDemo6 {\n    public static void main(String[] args) {\n        /*\n         * 调用自定义getSumOfTwoNumber方法，需要两个int类型的参数，并得到一个int类型的返回值\n         *\n         * 参数列表一定要和方法声明上的参数类型完全一致\n         */\n        int total = getSumOfTwoNumber(1, 2);\n\n        System.out.println(total);\n    }\n\n    /**\n     * 两个整数进行求和\n     *\n     * @param num1 求和的第一个数\n     * @param num2 求和的第二个数\n     * @return 返回两个参数的和，int类型\n     */\n    public static int getSumOfTwoNumber(int num1, int num2){\n        return num1 + num2;\n    }\n}\n```\n\n> 注意:调用带有多参数的方法，要求传入的参数数据类型，个数和顺序还有数据类型必须和方法声明一致\n\n### 规范化 return\n\n在一个方法中，return 出现的次数要尽可能得少，为了提高阅读性和逻辑性\n\n```java\nclass TestMethod4 {\n    public static void main(String[] args) {\n        System.out.println(getCompare(3,2));\n    }\n\n    /**\n    * 比较大小，返回较大的那个数\n    *\n    * @param num1 int类型\n    * @param num2 int类型\n    * @return int类型的结果\n    */\n    public static int getCompare(int num1, int num2) {\n        return num1 > num2 ? num1 : num2;\n    }\n}\n```\n\n### 总结\n\n```shell\n1、break 是退出当前循环结构，return 是退出当前方法\n\n2、如果返回值类型是 void ，可以返回 null 或者不返回或者 return;\n\n3、一个方法可以有多个 return，但只能有一个返回值\n\n4、返回值可以接收也可以不接收，由调用者决定如何调用\n\n5、分支结构里的每一个分支都需要有正确的返回值\n\n6、对返回值的处理方式因情况而定，可以打印、参与运算或者当做其他方法的实参\n\n7、调用带有多参数的方法，要求传入的参数数据类型，个数和顺序和类型必须和方法声明一致\n```\n\n> 注意:方法具有单一职能原则，一个函数只做一件事\n\n## 方法重载【Overload】\n\n### 概念\n\n一个类或者接口中定义多个相同名称的方法\n\n### 要求\n\n```shell\n1、必须在同一个类中\n2、方法名必须一致\n3、参数必须不一致(个数，顺序，类型)\n4、与访问修饰符、返回值类型无关\npublic class MethodDemo9 {\n    public static void main(String[] args) {\n        // 调用同名方法，传入不同的参数列表，即可实现方法的重载\n        play();\n        play(\"英雄联盟\");\n        play(\"红色警戒\", 2);\n        play(1, \"DNF\");\n    }\n\n    public static void play() {\n        System.out.println(\"玩王者荣耀\");\n    }\n\n    public static void play(String gameName) {\n        System.out.println(\"玩\" + gameName);\n    }\n\n    public static void play(String gameName, int time) {\n        System.out.println(\"玩\" + gameName + time + \"小时\");\n    }\n\n    public static void play(int time, String gameName) {\n        System.out.println(\"玩\" + gameName + time + \"小时\");\n    }\n\n    /*\n     * Duplicate method play(String, int) in type MethodDemo9\n     *\n     * 跟返回值类型无关，只关注方法名和参数类型\n     */\n//    public static String play(String gameName, int time) {\n//        return \"玩\" + gameName + time + \"小时\";\n//    }\n}\n```\n\n### 优点\n\n满足需求多样化，屏蔽使用差异，灵活、方便\n\n### 总结\n\n> 方法的重载我们只关注方法名和参数类型，要求方法名必须一致，参数列表必须不一致（个数，顺序，类型）\n\n## 局部变量\n\n### 概念\n\n在方法内部或者形参列表上定义的变量（包括 main 方法）\n\n### 作用域\n\n从定义局部变量的那一行到所在的代码块结束\n\n```java\nfor (int i = 1; i <= 10; i++) {\n\n}\n\nfor (int i = 1; i <= 10; i++) {\n\n}\n```\n\n【注意】两个 for 循环中，i 循环变量分别属于不同的大括号以内，不同的作用域空间，并不冲突\n\n### 生存期\n\n从方法被调用的时刻算起到函数返回调用处的时刻结束\n\n```java\nfor (int i = 1; i <= 10; i++) {\n\n}\n\nSystem.out.println(i); // 报错，找不到符号\n```\n\n【注意】for 循环结束时局部变量 i 的生存期结束，在 for 循环外无法使用 i\n\n### 单一性，不能重名\n\n```java\n// 报错！\nfor (int i = 1; i <= 10; i++) {\n    for (int i = 1; i <= 10; i++) {\n\n    }\n}\n```\n\n【注意】在一个方法内局部变量不能多次定义\n\n### 值传递\n\n```java\nclass Test {\n    public static void main(String[] args) {\n        int num = 5;\n        test(num);\n\n        System.out.println(num);    // 5\n    }\n\n    public static void test(int num) {\n        num = 10;\n    }\n}\n```\n\n【注意】基本数据类型作为参数传递给局部变量时，传递的是值，局部变量的更改不影响实参本身\n\n| ![](https://files.islu.cn/medias/reward/loading.gif#id=x2spE&originalType=binary&ratio=1&status=done&style=none) |\n| ---------------------------------------------------------------------------------------------------------------- |\n| ![](https://files.islu.cn/medias/reward/loading.gif#id=IS8Ok&originalType=binary&ratio=1&status=done&style=none) |\n\n### 引用传递\n\n```java\npublic class MethodDemoC {\n    public static void main(String[] args) {\n        int[] arr = new int[5];\n\n        System.out.println(\"调用方法前：\" + arr[0]);\n\n        test(arr);\n\n        System.out.println(\"调用方法后：\" + arr[0]);\n    }\n\n    public static void test(int[] arr) {\n        arr[0] = 1;\n    }\n}\n```\n\n【注意】引用数据类型传递时传递的是地址，局部变量直接作用于实参本身\n\n| 引用传递分析图                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------- |\n| More Actions![](https://files.islu.cn/medias/reward/loading.gif#id=Zpdob&originalType=binary&ratio=1&status=done&style=none) |\n\n### 总结\n\n1. 局部变量声明在函数中，从定义的那一行开始到函数结束时被销毁\n2. 局部变量必须先赋值再使用\n3. 局部变量不能重复定义\n4. 值传递：基本数据类型的传递不改变实参\n5. 引用传递：引用数据类型的传递会改变实参\n6. Java 中只有值传递，引用传递传递的是地址值\n\n## 构造方法\n\n### 引言\n\n> 构造方法很重要，但是比较鸡肋\n\n### 定义\n\n构造方法（`Constructor`）的名称和类名相同，没有返回值类型。\n\n### 作用\n\n类中的特殊方法，用于创建对象，在创建对象的时候会执行一些初始化操作，如给成员属性赋初值\n\n### 格式\n\n```java\n格式：\n    类名([参数...]){}\n    Student(){}\n```\n\n注意：格式问题\n\n> 1、构造方法的方法名与类名完全相同\n>\n> 2、构造方法没有返回值类型\n>\n> 3、创建对象时，触发构造方法的调用，不可手动调用\n>\n> 4、如果没有声明构造方法，编译器默认生成无参构造方法\n>\n> 5、如果定义了有参构造方法，编译器就不会创建无参构造方法\n>\n> 【强制要求】\n\n```shell\n无论什么时候，都要加上一个无参构造方法！！！\n```\n\n### 构造方法的使用\n\n```java\n// 自定义有参构造方法，并给name属性赋值\nDog(String n) {\n    name = n;\n}\n\n// 自定义无参构造方法\nDog(){}\n```\n\n### 构造方法的重载\n\n```java\npublic Dog(String n){\n    name = n;\n}\n\npublic Dog(String n, int i){\n    name = n;\n    age = i;\n}\n```\n\n### 总结\n\n> 1. 构造方法是用来创建对象，在创建对象的过程中会进行初始化操作（为对象赋值）\n> 2. 构造方法也是方法，除了没有返回值，其他的都跟方法一样\n\n> 按照方法参数列表的类型、个数、顺序去匹配，如果没有找到对应的就会报错\n>\n> 1. 无论什么时候，都一定要给一个无参构造方法\n\n### 扩展：反编译\n\n```shell\njavap -c -l -private 类名.class\n```\n\n### 扩展：对象的创建过程\n\n```shell\n1、类加载\n2、内存中开辟对象空间\n3、为各个属性赋予初始值\n4、执行构造方法中的代码\n5、将对象的地址赋值给变量\n```\n\n## 方法重写【@Override】\n\n开发中父类的方法不一定适用于子类，因为父类方法不能更改，在子类中新增方法会造成代码的冗余，而且不符合逻辑\n\n### 要求\n\n> 1. 应用于继承和实现接口\n> 2. 方法的返回值类型，方法名，形参列表与父类一致\n> 3. 使用`@Override`注解来标识\n> 4. 重写方法的访问修饰符权限不能低于父类\n>    private < 默认什么都不写什么都不写 < protected < public\n\n```java\n/*\n *十二生肖类的继承+方法重写\n */\nclass rat {\n    private String name;// 名字\n    private int ranking;// 排名\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getRanking() {\n        return ranking;\n    }\n\n    public void setRanking(int ranking) {\n        this.ranking = ranking;\n    }\n\n    public void skill() {\n        System.out.print(\"打洞\");\n    }\n\n    public void print() {\n        System.out.print(name + \"\\t\" + ranking + \"\\t\");\n        skill();\n        System.out.println();\n    }\n}\n\nclass cow extends rat {\n    public void skill() {\n        System.out.print(\"耕田\");\n    }\n}\n\nclass tiger extends rat {\n    public void skill() {\n        System.out.print(\"打斗\");\n    }\n}\n\nclass rabbit extends rat {\n    public void skill() {\n        System.out.print(\"躲避\");\n    }\n}\n\nclass dragon extends rat {\n    public void skill() {\n        System.out.print(\"呼风唤雨\");\n    }\n}\n\nclass snake extends rat {\n    public void skill() {\n        System.out.print(\"游走\");\n    }\n}\n\nclass horse extends rat {\n    public void skill() {\n        System.out.print(\"飞奔\");\n    }\n}\n\nclass sheep extends rat {\n    public void skill() {\n        System.out.print(\"吃草\");\n    }\n}\n\nclass monkey extends rat {\n    public void skill() {\n        System.out.print(\"模仿\");\n    }\n}\n\nclass chicken extends rat {\n    public void skill() {\n        System.out.print(\"啄食\");\n    }\n}\n\nclass dog extends rat {\n    public void skill() {\n        System.out.print(\"游泳\");\n    }\n}\n\nclass pig extends rat {\n    public void skill() {\n        System.out.print(\"吃\");\n    }\n}\n```\n\n### 优点\n\n既沿袭了父类的方法名，又实现了子类的扩展\n\n### 总结\n\n> 1. 方法的重写能够在不新增方法的情况下实现子类的扩展\n> 2. 方法重写要求方法声明格式和父类完全一致（访问修饰符不能小于父类）\n> 3. `@Overrid`关键字用来开启格式检测，如果不一致就会报错\n","tags":["Java"],"categories":["学习笔记"]},{"title":"Java关键词总结","url":"/posts/JavaKeyword.html","content":"\n# Java 关键字\n\n## this 关键字\n\n### 概述\n\nthis 代表所在类的对象引用，即当前对象\n\n> new 创建出来的对象\n>\n> 调用方法的对象\n\n### 作用\n\n1、调用本类中的属性和方法（区别成员变量和局部变量）\n\n2、调用本类中的其他构造方法：this\n\n```shell\n格式：\n    this([参数...]);\n\n会根据参数列表调用对应的构造方法\npublic Rabbit(String color) {\n    // 调用本来中的属性\n    this.color = color;\n}\n\npublic Rabbit(String color, int age, double weight) {\n    // 调用本类中的其他构造方法\n    this(color);\n\n    this.age = age;\n    this.weight = weight;\n}\n```\n\n【注意】\n\n```shell\n1、this()只能在构造方法中使用\n2、this()只能在第一行\n3、构造方法中不能同时出现两个this()，因为2\n4、不能自己调用自己，不能相互调用\n```\n\n### 规范化 this\n\n```java\nclass Son {\n    String name;\n    int age;\n    float salary;\n\n    public Son() {\n    }\n\n    public Son(String name) {\n        // 调用Son(String name, int age, float salary)\n        this(name, 0, 0.0F);\n    }\n\n    public Son(String name, int age) {\n        // 调用Son(String name, int age, float salary)\n        this(name, age, 0.0F);\n    }\n\n    public Son(String name, int age, float salary) {\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n}\n```\n\n### 总结\n\n> - this 表示的是当前对象\n> - this 可以调用本类中的属性和方法，最常用与区分成员变量和局部变量\n> - this 还可以调用本类中的构造方法，但是要注意有坑\n\n## super 关键字\n\n### 概述\n\n> super 指父类对象，用来区分父类和子类，用于调用父类的属性和方法\n>\n> 用法和 this 非常类似：this 指当前对象，super 指父类对象\n\n### 调用父类的属性和方法\n\n```java\npublic class Father {\n    public int age = 60;\n\n    public void play() {\n        System.out.println(\"下象棋\");\n    }\n}\n\npublic class Son extends Father {\n    public int age = 16;\n\n    @Override\n    public void play() {\n        System.out.println(\"玩游戏\");\n    }\n\n    public void showAge() {\n        int age = 20;\n        System.out.println(\"局部变量：\" + age);\n        System.out.println(\"当前对象成员变量：\" + this.age);\n        System.out.println(\"父类对象成员变量：\" + super.age);\n    }\n\n    public void callPlay() {\n        // 调用当前对象的方法\n        this.play();\n        // 调用父类对象的方法\n        super.play();\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        Son son = new Son();\n\n        son.showAge();\n\n        son.callPlay();\n    }\n}\n```\n\n### 调用父类的构造方法\n\n默认调用父类的无参构造，且必须在代码的第一行\n\n```java\nclass Father {\n    private String name;\n\n    public Father() {\n        System.out.println(\"Father's Constrator be performed\");\n    }\n\n    public Father(String name) {\n        System.out.println(\"Father's Constrator be performed with name\");\n    }\n}\n\nclass Son extends Father {\n    private int age;\n\n    public Son() {\n        super();\n        System.out.println(\"Son's Constrator be performed\");\n    }\n\n    public Son(String name, int age) {\n        super(name);\n        this.age = age;\n        System.out.println(\"Son's Constrator be performed with name and age\");\n    }\n}\n\npublic class TestSon {\n    public static void main(String[] args) {\n        Son son = new Son();\n    }\n}\n```\n\n> 注意：`super()` 和`this()` 代码不能共存都必须在首行都必须在首行，但是实际效果其实是可以的，如果不写 super 也会自动调用\n\n### 总结\n\n> 1. super 指父类对象，对比 this 关键字，使用方法都一样\n> 2. super 和 this 代码不能共存都必须在首行都必须在首行，但是实际效果其实是可以的，如果不写 super 也会自动调用\n> 3. 父类的属性要交给父类的构造方法去操作，没什么事就不要去使用 super 来调用父类的构造方法了\n\n## final 关键字\n\n### 概述\n\nfinal 表示最终的，用来修饰变量，方法和类\n\n```shell\n1、final 修饰的局部变量只能被赋值一次\n2、final 修饰的成员变量只能被赋值一次，并且必须在声明时就赋值\n3、final 修饰的基本类型变量是一个常量(只能被赋值一次)，引用类型变量不可修改地址，如对象\n4、final 修饰的方法不能被重写\n5、final 修饰的类不能被继承\npackage com.fc.j._final;\n/*\n * final修饰的局部变量\n */\npublic class FinalDemo1 {\n    public static void main(String[] args) {\n        // 测试final修饰的修饰的变量\n        final int num;\n\n        num = 10;\n\n        System.out.println(num);\n\n        /*\n         * 被final修饰的变量只能赋值一次\n         *\n         * The final local variable num may already have been assigned\n         *\n         * 被final修饰的局部变量num可能已经被赋值\n         */\n        // num = 20;\n    }\n}\n\n// final修饰的类不能被继承，断子绝孙\nclass Father {\n    /*\n     * final 修饰的成员变量必须在声明时就赋值\n     *\n     * The blank final field age may not have been initialized\n     * 空白的final成员变量可能未被初始化\n     */\n     // final int age;\n    final int age = 16;\n\n    public final void play() {\n        System.out.println(\"下棋\");\n    }\n}\n\nclass Son extends Father {\n    /*\n     *  Cannot override the final method from Father\n     *  无法重写被final修饰的方法\n     */\n//    @Override\n//    public final void play() {\n//\n//    }\n}\n```\n\n### 特点\n\nfinal 修饰可以保证安全性，比如数组的长度属性，String 类，这些都是 final 修饰的，保证不可变\n\n### 总结\n\n> 1、final 表示最终的，可以修饰变量，属性和方法\n>\n> 2、final 修饰的基本数据类型的成员变量只能被赋值一次\n>\n> 3、final 修饰的引用数据类型的成员变量地址不可变，但不影响地址所指向的对象的操作\n>\n> 4、final 修饰的方法不能被重写\n>\n> 5、final 修饰的类不能被继承\n\n## static 关键字\n\n### 概述\n\nstatic 关键字方便在**没有创建对象的情况下来进行调用方法和变量**优先级高于对象优先级高于对象，可以用来修饰类的成员方法、类的成员变量，另外可以编写 static 代码块来优化程序性能\n\n### static 变量\n\nstatic 变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。\n\n```java\npublic class PersonDemo {\n    public static void main(String[] args) {\n        Person person1 = new Person(\"张三\", 16);\n        Person person2 = new Person(\"李四\", 17);\n        Person person3 = new Person(\"王五\", 18);\n        Person person4 = new Person(\"赵六\", 19);\n\n        /*\n         * The static field Person.address should be accessed in a static way\n         * 静态成员变量应该通过静态的方式访问（注意这里是应该，不是必须）\n         *\n         * Change access to static using 'Person' (declaring type)\n         * 使用Person声明类型来更改对静态的访问\n         * 通过类名来操作成员变量：Person.address\n         */\n        System.out.println(\"姓名：\" + person1.name + \" 年龄：\" + person1.age + \" 地址：\" + Person.address);\n        System.out.println(\"姓名：\" + person2.name + \" 年龄：\" + person2.age + \" 地址：\" + Person.address);\n        System.out.println(\"姓名：\" + person3.name + \" 年龄：\" + person3.age + \" 地址：\" + Person.address);\n        System.out.println(\"姓名：\" + person4.name + \" 年龄：\" + person4.age + \" 地址：\" + Person.address);\n\n        // 通过类名直接调用static修饰的成员变量，此时是没有对象的\n        System.out.println(\"没有对象：\" + Person.address);\n\n        /*\n         *  Cannot make a static reference to the non-static field Person.name\n         *\n         *  将name添加static后没有报错\n         */\n//        System.out.println(\"没有对象：\" + Person.name);\n\n        /*\n         * 通过对象调用statice修饰的成员方法\n         *\n         * The static method test() from the type Person should be accessed in a static way\n         */\n        // person1.testStatic();\n\n        // 通过类名直接调用静态方法\n        Person.testStatic();\n    }\n}\n```\n\n#### 总结\n\n```shell\n1、通过类名调用静态成员变量，因为静态变量与对象无关\n2、静态变量被所有对象共享，一处更改处处更改\n```\n\n### static 方法\n\nstatic 方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有 this 的，因为它不依附于任何对象，既然都没有对象，就谈不上 this 了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。\n\n```java\npublic class Person {\n    public String name = \"张三\";\n    public int age;\n    public static String address = \"郑州\";\n\n    public Person() {\n        super();\n    }\n\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n\n    // 自定义static修饰的成员方法\n    public static void testStatic() {\n        /*\n         * 静态方法不能调用非静态方法\n         * Cannot make a static reference to the non-static method test() from the type Person\n         */\n        // test();\n        System.out.println(\"static mothed\");\n\n        /*\n         * 不能再静态方法中使用this关键字\n         *\n         * Cannot use this in a static context\n         */\n        // this.name;\n    }\n\n    public void test() {\n        System.out.println(\"method\");\n    }\n}\n```\n\n#### 总结\n\n```shell\n1. static修饰的方法不能访问本类中的非静态变量和方法，不能使用this和super\n2. 通过类名来调用静态成员方法，工具类的应用很广泛\n```\n\n### 总结\n\n> 1. static 修饰的成员变量和方法都是对象所共享的资源，对其进行的操作回作用于所有对象。\n> 2. static 修饰的成员变量和方法依赖于类不依赖于对象，即没有对象\n> 3. static 修饰的成员变量和成员方法都可以通过类名调用，没有对象\n> 4. 静态不能调用费静态，不能使用 this 关键字，没有对象\n> 5. 静态变量常和 final 关键字搭配作为常量使用，静态方法常用于工具类\n\n## abstract 关键字\n\n不能实例化的类就是抽象类，用 abstract 修饰\n\n### 构成\n\n```java\nabstract class 类名 {\n    成员变量\n    构造方法\n    成员方法\n        非抽象方法\n        抽象方法\n}\n```\n\n### 要求\n\n```shell\n1、抽象类和抽象方法必须用关键字 abstract 修饰\n2、抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类\n3、abstract 修饰的方法没有方法体，且子类必须重写\n4、抽象类不能实例化，因为 abstract 类中有 abstract 方法\n5、抽象类的子类\n        也可以是一个抽象类，可以重写也可以不重写父类的抽象方法。\n        可以是一个具体类。这个类必须重写抽象类中的所有抽象方法。(可以实例化)\npublic class TestSon {\n    public static void main(String[] args) {\n        Son son = new Son();\n        son.play();\n    }\n}\n\n// 抽象类\nabstract class Father {\n    String name;\n    int age;\n\n    public Father() {\n    }\n\n    public void eat() {\n        System.out.println(\"吃饭\");\n    }\n\n    // 抽象方法\n    abstract public void play();\n}\n\nclass Son extends Father {\n    // 抽象方法的重写\n    @Override\n    public void play() {\n        System.out.println(\"玩游戏\");\n    }\n}\n```\n","tags":["Java"],"categories":["学习笔记"]},{"title":"emoji表情符号","url":"/posts/Emoji.html","content":"\n## 常用符号\n\n> ❤❥웃유♋☮✌☏☢☠✔☑♚▲♪✈✞÷↑↓◆◇⊙■□△▽¿─│♥❣♂♀☿Ⓐ✍✉☣☤✘☒♛▼♫⌘☪≈←→◈◎☉★☆⊿※¡━┃♡ღ ツ\n>\n> ☼☁❅♒✎©®™Σ✪✯☭➳ 卐 √↖↗●◐Θ◤◥︻〖〗┄┆℃℉°✿ϟ☃☂✄¢€£∞✫★½✡×↙↘○◑⊕◣◢︼【】┅┇☽☾✚〓\n>\n> ▂▃▄▅▆▇█▉▊▋▌▍▎▏↔↕☽☾ の•▸◂▴▾┈┊①②③④⑤⑥⑦⑧⑨⑩ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ ㍿ ▓♨♛❖♓☪✙\n>\n> ┉┋☹☺☻ت ヅツッシ Üϡﭢ™℠℗©®♥❤❥❣❦❧♡۵웃유ღ♋♂♀☿☼☀☁☂☄☾☽❄☃☈⊙☉℃℉❅✺ϟ☇♤♧♡♢♠♣\n>\n> ♥♦☜☞☝✍☚☛☟✌✽✾✿❁❃❋❀⚘☑✓✔√☐☒✗✘ ㄨ ✕✖✖⋆✢✣✤✥❋✦✧✩✰✪✫✬✭✮✯❂✡★✱✲✳✴✵✶✷✸✹✺✻✼❄❅❆❇❈❉❊†☨✞✝☥☦☓☩☯☧☬\n>\n> ☸✡♁✙♆。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？！～—ˉ ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴々﹟#\n>\n> ﹩$﹠&﹪%_﹡﹢﹦﹤‐￣ ¯―﹨ˆ˜﹍﹎+=<＿_-\\ˇ~﹉﹊（）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】︵︷︿︹︽\\*﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼☩☨☦✞✛✜✝✙✠✚†‡◉○◌◍◎●◐◑◒◓◔◕◖◗❂☢⊗⊙◘◙◍⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌\n>\n> ≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱㊣㊎㊍㊌㊋㊏㊐㊊㊚㊛㊤㊥\n>\n> ㊦㊧㊨㊒㊞㊑㊒㊓㊔㊕㊖㊗㊘㊜㊝㊟㊠㊡㊢㊩㊪㊫㊬㊭㊮㊯㊰㊙ ㉿ 囍 ♔♕♖♗♘♙♚♛♜♝♞♟ℂℍℕℙℚℝℤℬℰℯℱℊℋℎℐℒℓℳℴ℘ℛℭ℮ℌℑℜℨ♪♫♩♬♭♮♯°øⒶ☮✌☪✡☭✯ 卐 ✐✎✏\n>\n> ✑✒✍✉✁✂✃✄✆✉☎☏➟➡➢➣➤➥➦➧➨➚➘➙➛➜➝➞➸♐➲➳⏎➴➵➶➷➸➹➺➻➼➽←↑→↓↔↕↖↗↘↙↚↛↜↝\n>\n> ↞↟↠↡↢↣↤↥↦↧↨➫➬➩➪➭➮➯➱↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹↺↻↼↽↾↿⇀⇁⇂⇃⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇕\n>\n> ⇖⇗⇘⇙⇚⇛⇜⇝⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪➀➁➂➃➄➅➆➇➈➉➊➋➌➍➎➏➐➑➒➓㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡ\n>\n> ⓢⓣⓤⓥⓦⓧⓨⓩ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵ⅠⅡⅢⅣⅤ\n>\n> ⅥⅦⅧⅨⅩⅪⅫⅬⅭⅮⅯⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹⅺⅻⅼⅽⅾⅿ┌┍┎┏┐┑┒┓└┕┖┗┘┙┚┛├┝┞┟┠┡┢┣┤┥┦┧┨┩┪┫\n> ┬┭┮┯┰┱┲┳┴┵┶┷┸┹┺┻┼┽\n> ┾┿╀╁╂╃╄╅╆╇╈╉╊╋╌╍╎╏\n> ═║╒╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡╢╣╤╥╦╧╨╩╪╫╬◤◥◄►▶◀◣◢▲\n>\n> ▼◥▸◂▴▾△▽▷◁⊿▻◅▵▿▹◃❏❐❑❒▀▁▂▃▄▅▆▇▉▊▋█▌▍▎▏▐░▒▓▔▕■□▢▣▤▥▦▧\n>\n> ▨▩▪▫▬▭▮▯ ㋀㋁㋂㋃㋄㋅㋆㋇㋈㋉㋊㋋㏠㏡㏢㏣㏤㏥㏦㏧㏨㏩㏪㏫㏬㏭㏮㏯㏰㏱㏲\n>\n> ㏳㏴㏵㏶㏷㏸㏹㏺㏻㏼㏽㏾㍙㍚㍛㍜㍝㍞㍟㍠㍡㍢㍣㍤㍥㍦㍧㍨㍩㍪㍫㍬㍭㍮㍯㍰㍘\n>\n> ☰☲☱☴☵☶☳☷☯\n\n## 特殊符号\n\n> ♠♣♧♡♥❤❥❣♂♀✲☀☼☾☽◐◑☺☻☎☏✿❀№↑↓←→√×÷★℃℉°◆◇⊙■□△▽¿½☯✡ ㍿卍卐 ♂♀✚〓㎡♪♫♩♬\n>\n> ㊚㊛囍㊒㊖ Φ♀♂‖KaTeX parse error: Expected ‘EOF’, got ‘&’ at position 3: @\\*&̲#※卍卐 Ψ♫♬♭♩♪♯♮⌒¶∮…\n\n## 编号序号\n\n> ①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳⓪\n>\n> ❶❷❸❹❺❻❼❽❾❿⓫⓬⓭⓮⓯⓰⓱⓲⓳⓴\n>\n> ㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽⑾⑿⒀⒁⒂⒃⒄⒅⒆⒇\n>\n> ⒈⒉⒊⒋⒌⒍⒎⒏⒐⒑⒒⒓⒔⒕⒖⒗⒘⒙⒚⒛\n>\n> ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫⅰⅱⅲⅳⅴⅵⅶⅷⅸⅹ\n>\n> ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ\n>\n> ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵\n\n## 数学符号\n\n> ﹢﹣×÷±/=≌∽≦≧≒ ﹤﹥ ≈≡≠=≤≥<>≮≯∷∶∫∮∝∞∧∨∑∏∪∩∈∵∴⊥∥∠⌒⊙√∟⊿㏒㏑%\n>\n> ‰⅟½⅓⅕⅙⅛⅔⅖⅚⅜¾⅗⅝⅞⅘≂≃≄≅≆≇≈≉≊≋≌≍≎≏≐≑≒≓≔≕≖≗≘≙≚≛≜≝≞≟\n>\n> ≠≡≢≣≤≥≦≧≨≩⊰⊱⋛⋚∫∬∭∮∯∰∱∲∳%℅‰‱øØπ\n\n## 爱心符号\n\n> ♥❣ღ♠♡♤❤❥\n\n## 标点符号\n\n> 。，、＇：∶；?‘’“”〝〞ˆˇ﹕︰﹔﹖﹑•¨….¸;！´？！～—ˉ ｜‖＂〃｀@﹫¡¿﹏﹋﹌︴\n>\n> 々﹟#﹩$﹠&﹪%_﹡﹢﹦﹤‐￣ ¯―﹨ˆ˜﹍﹎+=<＿_-\\ˇ~﹉﹊\n>\n> （）〈〉‹›﹛﹜『』〖〗［］《》〔〕{}「」【】\n>\n> ︵︷︿︹︽\\*﹁﹃︻︶︸﹀︺︾ˉ﹂﹄︼❝❞\n\n## 单位符号\n\n> °′″＄￥〒￠￡％＠℃℉ ﹩﹪‰﹫㎡㏕㎜㎝㎞㏎m³㎎㎏㏄º○¤%$º¹²³\n\n## 货币符号\n\n> €£Ұ₴$₰¢₤¥₳₲₪₵ 元 ₣₱฿¤₡₮₭₩ރ 円 ₢₥₫₦zł﷼₠₧₯₨Kčर₹ƒ₸ ￠\n\n## 箭头符号（含推导&转换符号）\n\n> ↑↓←→↖↗↘↙↔↕➻➼➽➸➳➺➻➴➵➶➷➹▶►▷◁◀◄«\n>\n> »➩➪➫➬➭➮➯➱⏎➲➾➔➘➙➚➛➜➝➞➟➠➡➢➣➤➥➦➧➨\n>\n> ↚↛↜↝↞↟↠↠↡↢↣↤↤↥↦↧↨⇄⇅⇆⇇⇈⇉⇊⇋⇌⇍⇎⇏⇐⇑⇒⇓⇔⇖⇗⇘⇙\n>\n> ⇜↩↪↫↬↭↮↯↰↱↲↳↴↵↶↷↸↹☇☈↼↽↾↿⇀⇁⇂⇃⇞⇟⇠⇡⇢⇣⇤⇥⇦⇧⇨⇩⇪↺↻⇚⇛♐\n\n## 符号图案\n\n> ✐✎✏✑✒✍✉✁✂✃✄✆✉☎☏☑✓✔√☐☒✗✘ ㄨ ✕✖✖☢☠☣✈★☆✡ 囍㍿ ☯☰☲☱☴☵☶☳☷\n>\n> ☜☞☝✍☚☛☟✌♤♧♡♢♠♣♥♦☀☁☂❄☃♨웃유❖☽☾☪✿♂♀✪✯☭➳ 卍卐 √×■◆●○◐◑✙☺☻\n>\n> ❀⚘♔♕♖♗♘♙♚♛♜♝♞♟♧♡♂♀♠♣♥❤☜☞☎☏⊙◎☺☻☼▧▨♨◐◑↔↕▪▒◊◦▣▤▥▦▩◘◈◇\n>\n> ♬♪♩♭♪ の ★☆→ あぃ￡ Ю〓§♤♥▶¤✲❈✿✲❈➹☀☂☁【】┱┲❣✚✪✣✤✥✦❉❥❦❧❃❂❁❀✄☪☣☢☠☭ღ▶▷◀◁\n>\n> ☀☁☂☃☄★☆☇☈⊙☊☋☌☍ⓛⓞⓥⓔ╬『』∴☀♫♬♩♭♪☆∷﹌の ★◎▶☺☻►◄▧▨♨◐◑↔↕↘▀▄█▌\n>\n> ◦☼♪ の ☆→♧ ぃ￡ ❤▒▬♦◊◦♠♣▣۰•❤•۰►◄▧▨♨◐◑↔↕▪▫☼♦⊙●○①⊕◎Θ⊙¤ ㊣ ★☆♀◆◇◣◢◥▲▼△▽⊿◤◥\n>\n> ✐✌✍✡✓✔✕✖♂♀♥♡☜☞☎☏⊙◎☺☻►◄▧▨♨◐◑↔↕♥♡▪▫☼♦▀▄█▌▐░▒▬♦◊◘◙◦☼♠♣▣▤▥▦▩◘◙◈\n>\n> ♫♬♪♩♭♪✄☪☣☢☠♯♩♪♫♬♭♮☎☏☪♈ºº₪¤큐«»™♂✿♥ 　 ◕‿-｡　｡◕‿◕｡\n\n## 希腊字母\n\n> ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩ\n>\n> αβγδεζνξοπρσηθικλμτυφχψω\n\n## 俄语字母\n\n> АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвг\n>\n> деёжзийклмнопрстуфхцчшщъыьэюя\n\n## 汉语拼音\n\n> āáǎàōóǒòēéěèīíǐìūúǔùǖǘǚǜüêɑńňɡ ㄅㄆㄇㄈㄉ\n>\n> ㄊㄋㄌㄍㄎㄏㄐㄑㄒㄓㄔㄕㄖㄗㄘㄙㄚㄛㄜㄝㄞ\n>\n> ㄟㄠㄡㄢㄣㄤㄥㄦㄧㄨㄩ\n\n## 中文字符\n\n> 零壹贰叁肆伍陆柒捌玖拾佰仟万亿吉太拍艾分厘毫微\n>\n> 卍卐卄巜弍弎弐朤氺曱甴囍兀々〆のぁ〡〢〣〤〥〦〧〨〩\n>\n> ㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰\n>\n> ㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉\n\n## 日文符号\n\n> ぁあぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてで\n>\n> とどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎ\n>\n> わゐゑをんゔゕゖァアィイゥウェエォオカガキギクグケゲコゴサザシジスズセゼソゾタ\n>\n> ダチヂッツヅテデトドナニヌネノハバパヒビピフブプヘベペホボポマミムメモャヤュユ\n>\n> ョヨラリルレロヮワヰヱヲンヴヵヶヷヸヹヺ・ーヽヾヿ゠ㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ\n\n## 制表符号\n\n> ─ ━│┃╌╍╎╏┄ ┅┆┇┈ ┉┊┋┌┍┎┏┐┑┒┓└ ┕┖┗ ┘┙┚┛├┝┞┟┠┡┢┣ ┤┥┦┧┨┩┪┫┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳\n>\n> ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻┼ ┽ ┾ ┿ ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╪ ╫ ╬═║╒╓╔ ╕╖╗╘╙╚ ╛╜╝╞╟╠ ╡╢╣\n>\n> ╤ ╥ ╦ ╧ ╨ ╩ ╳╔ ╗╝╚ ╬ ═ ╓ ╩ ┠ ┨┯ ┷┏ ┓┗ ┛┳ ⊥ ﹃ ﹄┌ ╮ ╭ ╯╰\n\n## 皇冠符号\n\n> ♚ 　 ♛ 　 ♝ 　 ♞ 　 ♜ 　 ♟ 　 ♔ 　 ♕ 　 ♗ 　 ♘ 　 ♖ 　 ♟\n\n## 彩色表情符号\n\n> 🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥\n\n## 常用 emoji 符号\n\n> 😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠😈👿👹👺💀👻👽👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊💩🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬👾🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨💣☠♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯 🉐 🈹🈚🈲 🉑 🈸🈴🈳 ㊗㊙ 🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵♈♉♊♋♌♍♎♏♐♑♒♓⛎💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣🌿🚧💒☎📟💽⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝🔀🔁🔂▶⏩◀⏪🔼⏫🔽⏬📱📶📳📴♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞\n","tags":["emoji"],"categories":["学习笔记"]},{"title":"Jetbrains系列产品激活","url":"/posts/Jetbrains.html","content":"\n# **Jetbrains 系列产品激活文件**\n\n## 软件介绍\n\nJetBrains 公司旗下的 IntelliJ IDEAJava 是广泛使用的编程语言开发撰写时所用的集成开发环境。JetBrains 全家桶，包括 IntelliJ IDEA , Pycharm , Webstorm , PhpStorm , Rider Clion , RubyMine, AppCode, Goland, DataGrip , Kotlin 等 15 款产品。Jetbrains 系列产品 2020.2.3 最新激活文件，可以永久激活最新版本。\n\n> IDEA，专为 Java 编程语言开发撰写时常用的集成开发环境。\n>\n> PhpStorm，专为 Web 和 PHP 开发者打造的专业集成开发环境。\n>\n> RubyMine，针对 Ruby 和 Rails 的集成开发环境，为使用 Ruby 语言进行 Web 开发的开发人员们提供最为必需的工具和舒适便捷的开发环境。\n>\n> PyCharm，针对 Python 语言打造的轻量级 IDE，通过 Django 框架和 Google App Engine 来支持 web 开发。\n>\n> AppCode，专为 iOS/OS X 开发人员打造的智能 IDE，协助他们以更高的生产效率使用 Objective-C、Swift、C 或 C++进行苹果设备的应用开发。\n>\n> CLion，适用于 C/C++开发人员的跨平台 IDE，提供极佳的编码协助，为您节省大量时间。\n>\n> WebStorm，适用于专业 JavaScript 和前端 Web 开发人员的集成开发环境。\n>\n> DataGrip，适用于数据库与 SQL 开发人员的超级利器。\n\n## 关于激活\n\nJetbrains 全系列产品 2020.2.3 及以下版本（理论上适用目前所有新老版本）\n\n最新注册服务器(License Server)的解锁，可用它来激活你的 Jetbrains IDE。\n\n支持 Activation Code 注册码激活（自定义 License name）可用于离线环境。\n\n新的 agent license server：[https://fls.jetbrains-agent.com（HTTP 也可用）](<https://fls.jetbrains-agent.xn--com(http)-k31uj16d9p5j/>)\n\nJebrains 付费插件 Activation code，暂不在列表的试试 license server。\n\n> 以下 IDE 版本可成功激活：\n>\n> IntelliJ IDEA 2020.2.3 及以下\n>\n> AppCode 2019.3.7 及以下\n>\n> CLion 2019.3.5 及以下\n>\n> DataGrip 2020.2.3 及以下\n>\n> GoLand 2020.2.3 及以下\n>\n> PhpStorm 2020.2.3 及以下\n>\n> PyCharm 2020.2.3 及以下\n>\n> Rider 2019.3.4 及以下\n>\n> RubyMine 2019.3.4 及以下\n>\n> WebStorm 2020.2.3 及以下\n\n## 激活文件下载\n\n[传送门](https://share.weiyun.com/IRKRsdxn)\n\n## 使用说明\n\nJetbrains 系列产品 2020.2.3 激活文件 [v3.2.2 2020.10.27](https://share.weiyun.com/IRKRsdxn)> （支持 2020.2.3 及以下版本）\n\n> 1.使用说明：启动软件选试用（Evaluate for free）- Evaluate\n>\n> 2.将解锁激活文件 jetbrains-agent-latest.zip 拖到 IDE 欢迎界面，重启软件，会弹出配置助手\n>\n> 3.将最新安装参数->粘贴->配置助手对话框->点击为产品激活，重启即激活旗舰版至 2089 年！\n>\n> JetBrains 产品官方简体中文语言包页面（适用 JetBrains 所有产品汉化）\n\n> 启动软件，选择试用（Evaluate for free）- Evaluate, JetBrains_zh-CNLangPack_EAP.jar 汉化插件包拖到 IDE 欢迎界面重启完事。\n\n## 正版活动\n\n教育邮箱或学生证免费 1 年正版授权官方申请地址\n\n[https://sales.jetbrains.com/hc/zh-cn/articles/207154369](https://sales.jetbrains.com/hc/zh-cn/articles/207154369)\n\n创业公司 5 折正版授权官方购买地址\n\n[https://www.jetbrains.com/shop/eform/startup](https://www.jetbrains.com/shop/eform/startup)\n","tags":["Jetbrains"],"categories":["资源推荐"]},{"title":"Excel常用函数","url":"/posts/ExcelCommonlyUsedFunctions.html","content":"\n## Excel 函数\n\n### 求和函数 SUM()\n\n> **SUM**函数将为值求和。 可以将单个值、单元格引用或是区域相加，或者将三者的组合相加。\n\n1、指定数值求和\n\n```excel\n=SUM(10,20,30)\n```\n\n2、指定单元格求和：输入=sum()，在括号中间按住 ctrl 连续点击即可选择需要求和的数据\n\n```excel\n=SUM(C5,C9,C3)\n```\n\n3、也可以将指定单元格直接相加\n\n```excel\n=SUM(C2 + C4)\n```\n\n4、区域求和，输入=sum()，在括号中间按住 ctrl 选中所需要求和的数据\n\n```excel\n=SUM(C2:C11)\n```\n\n5、多个区域求和，输入=sum()，在括号中间分别按住 ctrl 选中所需要的多个区域的数据\n\n```excel\n=SUM(C2:C4,C6:C10)\n```\n\n6、配合固定值进行求和，中间使用英文的逗号分隔\n\n```excel\n=SUM(C2:C11,100)\n```\n\n### 条件求和函数 SUMIF()\n\n> 按条件求和\n\nsumif 函数的语法格式\n\n> Sumif（条件区域，求和条件，实际求和区域），第二个求和条件参数在第一个条件区域里。\n\n```excel\n=sumif(range，criteria，sum_range)\n```\n\n```excel\n=SUMIF(D2:D11,D4,C2:C11)\n```\n\n求和所有性别中性别为女的年龄\n\n### 求平均值函数 AVERAGE()\n\n> 获取平均值\n\n1、指定数值求平均值\n\n```excel\n=AVERAGE(10,20)\n```\n\n2、指定单元格求平均值:括号内按 ctrl 选择需要求平均值的单元格\n\n```excel\n=AVERAGE(C2,C8)\n```\n\n3、范围单元格求平均值\n\n```excel\n=AVERAGE(C2:C11)\n```\n\n### 求最大值函数 MAX()\n\n> 获取最大值\n\n1、指定数值求最大值\n\n```excel\n=MAX(30,40)\n```\n\n2、指定单元格求最大值\n\n```excel\n=MAX(C5,C11,C7)\n```\n\n3、指定范围单元格求最大值\n\n```excel\n=MAX(C2:C11)\n```\n\n4、指定多个范围单元格求最大值\n\n```excel\n=MAX(C3:C4,C7,C10)\n```\n\n### 求最小值函数 MIN()\n\n> 获取最小值\n\n1、指定数值求最小值\n\n```excel\n=MIN(30,40)\n```\n\n2、指定单元格求最小值\n\n```excel\n=MIN(C5,C11,C7)\n```\n\n3、指定范围单元格求最小值\n\n```excel\n=MIN(C2:C11)\n```\n\n4、指定多个范围单元格求最小值\n\n```excel\n=MIN(C3:C4,C7,C10)\n```\n\n### 计数函数 COUNT()\n\n> 获取指定单元格非空数据数值类型的个数，对于空单元格、逻辑值或者文本数据将被忽略。可以用来判断是否有空白单元格\n\n1、指定数值获取非空数值的个数\n\n```excel\n=COUNT(1,2)\n```\n\n2、获取指定单元格中非空数值的个数\n\n```excel\n=COUNT(C10,F10)\n```\n\n3、指定范围获取非空数值的个数\n\n```excel\n=COUNT(C10:C12)\n```\n\n4、指定多个范围单元格获取非空数值的个数\n\n```excel\n=COUNT(C8,C10,C12,F4:F12)\n```\n\n### 非空计数函数 COUNTA()\n\n> 统计区域内包含文本和逻辑值的单元格个数。\n>\n> 注意 counta 函数与 count 函数的区别。\n>\n> Count 函数只统计区域内包含数字的单元格个数。\n\n1、指定多个范围单元格获取非空数据的个数\n\n```excel\n=COUNTA(E4:E7,C2)\n```\n\n### 四舍五入函数 ROUND()\n\n> 对数值进行四舍五入\n\nROUND 函数语法格式：\n\n> 其中\n>\n> number 表示需要进行四舍五入的数值或单元格内容。\n>\n> num_digits 表示需要取多少位的参数。\n>\n> num_digits>0 时，表示取小数点后对应位数的四舍五入数值。\n>\n> num_digits=0 时，表示则将数字四舍五入到最接近的整数。\n>\n> num_digits< 0 时，表示对小数点左侧前几位进行四舍五入。\n\n```excel\nROUND(number, num_digits)\n```\n\n1、对指定单元格进行四舍五入\n\n```excel\n=ROUND(E7,0)\n```\n\n### 排名次函数 RANK()\n\n> 返回一列数字的数字排位。 数字的排位是相对于列表中的其他值的大小。\n\n语法：RANK(number,ref,[order])\n\n> RANK 函数语法具有下列参数：\n>\n> - **Number** 必需。 要找到其排位的数字。\n> - **Ref** 必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。\n> - **Order** 可选。 一个指定数字排位方式的数字。\n>   如果 order 为 0（零）或省略，Microsoft Excel 对数字的排位是基于 ref 为按照降序排列的列表。\n>   如果 order 不为零，Microsoft Excel 对数字的排位是基于 ref 为按照升序排列的列表。\n\n1、获取指定单元格在范围内进行排名\n\n```excel\n=RANK(C3,C2:C11)\n```\n\n### 排名次函数 RANK.EQ()\n\n```\n与RANK函数用法一致\n```\n\n> 返回一列数字的数字排位。 其大小与列表中其他值相关；如果多个值具有相同的排位，则返回该组值的最高排位。\n>\n> 如果要对列表进行排序，则数字排位可作为其位置。\n\n语法\n\n> RANK.EQ(number,ref,[order])\n>\n> RANK.EQ 函数语法具有下列参数：\n>\n> - **Number** 必需。 要找到其排位的数字。\n> - **Ref** 必需。 数字列表的数组，对数字列表的引用。 Ref 中的非数字值会被忽略。\n> - **Order** 可选。 一个指定数字排位方式的数字。\n\n> 【注意】\n>\n> - 如果 Order 为 0（零）或省略，Excel 对数字的排位是基于 Ref 为按降序排列的列表。\n> - 如果 Order 不为零， Excel 对数字的排位是基于 Ref 为按照升序排列的列表。\n\n1、升序排名\n\n```excel\n=RANK.EQ(C3,C2:C11,1)\n```\n\n2、降序排名(0 可以省略)\n\n```excel\n=RANK.EQ(C3,C2:C11,0)\n```\n\n### 取整函数 INT()\n\n> 将数字向下舍入到最接近的整数。\n\n1、对指定单元格进行取整，忽略小数位\n\n```excel\n=INT(E3)\n```\n\n### 求字符串长度函数 LEN()\n\n> 返回文本字符串中的字符个数\n>\n> 【注意】数字，字符，汉字都属于一个字符，包括小数点\n\n1、对指定单元格获取长度\n\n```excel\n=LEN(E3)\n```\n\n### 左取字符串函数 LEFT()\n\n> 从文本字符串的第一个字符开始返回指定个数的字符\n\n语法\n\n> LEFT(text, [num_chars])\n>\n> 该函数语法具有下列参数：\n>\n> - **Text** 必需。 包含要提取的字符的文本字符串。\n> - num_chars\n>   可选。 指定要由 LEFT 提取的字符的数量。\n>   - num_chars 必须大于或等于零。\n>   - 如果 num_chars 大于文本长度，则 LEFT 返回全部文本。\n>   - 如果省略 num_chars，则假定其值为 1。\n\n1、获取指定单元格从左开始的第一个字符\n\n```excel\n=LEFT(F2)\n```\n\n2、获取指定单元格从左开始的指定长度个数的字符\n\n```excel\n=LEFT(F2,3)\n```\n\n### 右取字符串函数 RIGHT()\n\n> 根据所指定的字符数返回文本字符串中最后一个或多个字符\n\n语法\n\n> RIGHT(text,[num_chars])\n>\n> RIGHT 函数具有下列参数：\n>\n> - **文本** 必需。 包含要提取字符的文本字符串。\n> - **num_chars** 可选。 指定希望 RIGHT 提取的字符数。\n> - Num_chars 必须大于或等于零。\n> - 如果 num_chars 大于文本长度，则 RIGHT 返回所有文本。\n> - 如果省略 num_chars，则假定其值为 1。\n\n1、获取指定单元格从右开始的第一个字符\n\n```excel\n=RIGHT(F2)\n```\n\n2、获取指定单元格从左开始的指定长度个数的字符\n\n```excel\n=RIGHT(F2,3)\n```\n\n### 日函数 DAY()\n\n> 返回以序列数表示的某日期的天数。 天数是介于 1 到 31 之间的整数。\n\n语法\n\n> DAY(serial_number)\n>\n> DAY 函数语法具有下列参数：\n>\n> - **Serial_number** 必需。 尝试查找的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果[日期以文本形式输入](https://support.microsoft.com/zh-cn/office/%E6%9B%B4%E6%94%B9%E6%97%A5%E6%9C%9F%E7%B3%BB%E7%BB%9F%E3%80%81%E6%A0%BC%E5%BC%8F%E6%88%96%E4%B8%A4%E4%BD%8D%E6%95%B0%E5%B9%B4%E4%BB%BD%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f)，则会出现问题。\n\n用法\n\n| **日期**  |                             |          |\n| --------- | --------------------------- | -------- |\n| 2011-4-15 |                             |          |\n| **公式**  | **描述（结果）**            | **结果** |\n| =DAY(A2)  | 单元格 A2 (15) 中日期的天数 | 15       |\n\n### 月函数 MONTH()\n\n> 返回日期（以序列数表示）中的月份。 月份是介于 1（一月）到 12（十二月）之间的整数。\n\n语法\n\n> MONTH(serial_number)\n>\n> MONTH 函数语法具有下列参数：\n>\n> - **Serial_number** 必需。 尝试查找的月份的日期应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果[日期以文本形式输入](https://support.microsoft.com/zh-cn/office/%E6%9B%B4%E6%94%B9%E6%97%A5%E6%9C%9F%E7%B3%BB%E7%BB%9F%E3%80%81%E6%A0%BC%E5%BC%8F%E6%88%96%E4%B8%A4%E4%BD%8D%E6%95%B0%E5%B9%B4%E4%BB%BD%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F-aaa2159b-4ae8-4651-8bce-d4707bc9fb9f)，则会出现问题。\n\n用法\n\n| **日期**   |                        |          |\n| ---------- | ---------------------- | -------- |\n| 2011-4-15  |                        |          |\n| **公式**   | **说明**               | **结果** |\n| =MONTH(A2) | 单元格 A2 中日期的月份 | 4        |\n\n### 年函数 YEAR()\n\n> 返回对应于某个日期的年份。 Year 作为 1900 - 9999 之间的整数返回。\n\n语法\n\n> YEAR(serial_number)\n>\n> YEAR 函数语法具有下列参数：\n>\n> - **Serial_number** 必需。 要查找的年份的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。\n\n用法\n\n| **日期**  |                               |          |\n| --------- | ----------------------------- | -------- |\n| 2008-7-5  |                               |          |\n| 2010-7-5  |                               |          |\n| **公式**  | **描述（结果）**              | **结果** |\n| =YEAR(A3) | 单元格 A3 中日期的年份 (2008) | 2008     |\n| =YEAR(A4) | 单元格 A4 中日期的年份 (2010) | 2010     |\n\n### 星期函数 WEEKDAY()\n\n> 返回对应于某个日期的一周中的第几天。 默认情况下，天数是 1（星期日）到 7（星期六）范围内的整数。\n\n语法\n\n> WEEKDAY(serial_number,[return_type])\n>\n> WEEKDAY 函数语法具有下列参数：\n>\n> - **Serial_number** 必需。 一个序列号，代表尝试查找的那一天的日期。 应使用 DATE 函数输入日期，或者将日期作为其他公式或函数的结果输入。 例如，使用函数 DATE(2008,5,23) 输入 2008 年 5 月 23 日。 如果日期以文本形式输入，则会出现问题。\n> - **Return_type** 可选。 用于确定返回值类型的数字。\n\n>\n\n| **Return_type** | **返回的数字**                                                 |\n| --------------- | -------------------------------------------------------------- |\n| 1 或省略        | 数字 1（星期日）到 7（星期六）。 同 Microsoft Excel 早期版本。 |\n| 2               | 数字 1（星期一）到 7（星期日）。                               |\n| 3               | 数字 0（星期一）到 6（星期日）。                               |\n| 11              | 数字 1（星期一）到 7（星期日）。                               |\n| 12              | 数字 1（星期二）到数字 7（星期一）。                           |\n| 13              | 数字 1（星期三）到数字 7（星期二）。                           |\n| 14              | 数字 1（星期四）到数字 7（星期三）。                           |\n| 15              | 数字 1（星期五）到数字 7（星期四）。                           |\n| 16              | 数字 1（星期六）到数字 7（星期五）。                           |\n| 17              | 数字 1（星期日）到 7（星期六）。                               |\n\n备注\n\n> - Microsoft Excel 可将日期存储为可用于计算的序列号。 默认情况下，1900 年 1 月 1 日的序列号是 1，而 2008 年 1 月 1 日的序列号是 39448，这是因为它距 1900 年 1 月 1 日有 39448 天。\n> - 如果当前日期基值的 serial_number 超出范围，则 #NUM！ 返回错误。\n> - 如果 return_type 超出了上表中指定的范围，则 #NUM！ 返回错误。\n\n用法\n\n| **数据**        |                                                            |          |\n| --------------- | ---------------------------------------------------------- | -------- |\n| 2008-2-14       |                                                            |          |\n| **公式**        | **描述（结果）**                                           | **结果** |\n| =WEEKDAY(A2)    | 使用数字 1（星期日）到 7（星期六）表示的一周中的第几天 (5) | 5        |\n| =WEEKDAY(A2, 2) | 使用数字 1（星期一）到 7（星期日）表示的一周中的第几天 (4) | 4        |\n| =WEEKDAY(A2, 3) | 使用数字 0（星期一）到 6（星期日）表示的一周中的第几天 (3) | 3        |\n\n### 日期函数 DATE()\n\n> 返回表示特定日期的连续序列号。\n\n语法：\n\n> DATE(year,month,day)\n>\n> DATE 函数语法具有下列参数：\n>\n> - **Year** ：必需。**_year\\*_ 参数的值可以包含一到四位数字。Excel 将根据计算机正在使用的日期系统来解释 year\\*** 参数。默认情况下，Microsoft Excel for Windows 使用的是 1900 日期系统，这表示第一个日期为 1900 年 1 月 1 日。\n\n> **提示:** 为避免出现意外结果，请对 \\*_\\_year_\\_ 参数使用四位数字。例如，“07”可能意味着“1907”或“2007”。因此，使用四位数的年份可避免混淆。\n>\n> - 如果 \\*_\\_year_\\_ 介于 0（零）到 1899 之间（包含这两个值），则 Excel 会将该值与 1900 相加来计算年份。例如，DATE(108,1,2) 返回 2008 年 1 月 2 日 (1900+108)。\n> - 如果 \\*_\\_year_\\_ 介于 1900 到 9999 之间（包含这两个值），则 Excel 将使用该数值作为年份。例如，DATE(2008,1,2) 将返回 2008 年 1 月 2 日。\n> - 如果 \\*_\\_year_\\_ 小于 0 或大于等于 10000，则 Excel 返回 错误值 #NUM!。\n> - **Month** 必需。一个正整数或负整数，表示一年中从 1 月至 12 月（一月到十二月）的各个月。\n> - 如果 **_month\\*_ 大于 12，则 month\\*** 会从指定年份的第一个月开始加上该月份数。例如，DATE(2008,14,2) 返回表示 2009 年 2 月 2 日的序列数。\n> - 如果 **_month\\*_ 小于 1，则 month\\*** 会从指定年份的第一个月开始减去该月份数，然后再加上 1 个月。例如，DATE(2008,-3,2) 返回表示 2007 年 9 月 2 日的序列号。\n> - **Day** 必需。一个正整数或负整数，表示一月中从 1 日到 31 日的各天。\n> - 如果 **_day\\*_ 大于指定月中的天数，则 day\\*** 会从该月的第一天开始加上该天数。例如，DATE(2008,1,35) 返回表示 2008 年 2 月 4 日的序列数。\n> - 如果 **_day\\*_ 小于 1，则 day\\*** 从指定月份的第一天开始减去该天数，然后再加上 1 天。例如，DATE(2008,1,-15) 返回表示 2007 年 12 月 16 日的序列号。\n\n> **注意:** Excel 可将日期存储为连续序列号，以便能在计算中使用它们。1900 年 1 月 1 日的序列号为 1，2008 年 1 月 1 日的序列号为 39448，这是因为它与 1900 年 1 月 1 日之间相差 39,447 天。需要更改数字格式（设置单元格格式）以显示正确的日期。\n\n用法\n\n**=DATE(C2,A2,B2)** 将单元格 C2 中的年、单元格 A2 中的月以及单元格 B2 中的日合并在一起，并将它们放入一个单元格内作为日期。\n\n```excel\n=DATE(C2,A2,B2)\n```\n","tags":["Excel"],"categories":["学习笔记"]},{"title":"JavaScript加载速度","url":"/posts/JavaScriptLoadSpeed.html","content":"\n# 解决 JS 加载速度慢的问题\n\n## **传统形式加载 js 文件**\n\n```javascript\n<script type=\"text/javascript\" src=\"js调用地址\"></script>\n```\n\n## **高速加载 js 文件**\n\n```javascript\n<script type=\"text/javascript\">\n /* 请不要删除这段代码，因为这段代码起到了加速JS加载作用 */\n document.write(\"<scr\"+\"ipt src=\\\"你的js调用地址\"></sc\"+\"ript>\");\n</script>\n```\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"冷门CSS样式","url":"/posts/UnPopularCSS.html","content":"\n# 冷门但却很实用的 css 样式总汇\n\n## **::-Webkit-Input-Placeholder**\n\ninput 的 H5 placeholder 属性，很好用，可以直接定义输入文本框里面的内容，唯一的缺点就是不能更改默认显示字体的颜色，不过我们可以直接利用::input-placeholder 这个属性来设置字体颜色。\n\n```css\n::-webkit-input-placeholder {\n  /* Chrome/Opera/Safari */\n  color: pink;\n}\n::-moz-placeholder {\n  /* Firefox 19+ */\n  color: pink;\n}\n:-ms-input-placeholder {\n  /* IE 10+ */\n  color: pink;\n}\n:-moz-placeholder {\n  /* Firefox 18- */\n  color: pink;\n}\n```\n\n## **使用 clearfix 清楚浮动，解决父类高度崩塌**\n\n```css\n.clearfix {\n  zoom: 1;\n}\n.clearfix:after {\n  visibility: hidden;\n  display: block;\n  font-size: 0;\n  content: \" \"; /* 内容为空 */\n  clear: both;\n  height: 0;\n}\n```\n\n## **p::selection 选中文本后的背景色**\n\n```css\np::selection {\n  background: rgb(188, 188, 188);\n  color: #ffffff;\n}\n```\n\n## **calc function, 计算属性值**\n\n```css\ndiv {\n  width: calc(100% - 100px);\n}\n```\n\n## **outline**属性值\n\n不知道大家有没有一个困扰，就是在写 input 的时候，点击的时候总会有一个很丑的蓝色描边，但是找代码还找不到。这个其实很简单，用 outline 这个标签就可以很简单的解决掉这个烦人的问题。\n\n```css\ndiv {\n  outline: none; //移动浏览器默认的状态线\n  // outline: 5px dotted red; 也可以设置样式\n}\n```\n\n## **Webkit-Playsinline**\n\n支持 vedio 视频在手机页面内部播放，不用全屏。\n\n```css\n<video id=\"myvideo\" src=\"test.mp4\" webkit-playsinline=\"true\"></video>\n```\n\n## **Css 实现文本的各种换行状态**\n\n```css\n//不换行\nwhite-space: nowrap;\n//自动换行\nword-wrap: break-word;\nword-break: normal;\n//强制换行\nword-break: break-all;\n```\n\n## **-webkit-line-clamp**\n\n可以把 块容器 中的内容限制为指定的行数。并且在超过行数后，在最后一行显示”…” 这是正常的展示\n\n```css\ndisplay: -webkit-box; /*值必须为-webkit-box或者-webkit-inline-box*/\n-webkit-box-orient: vertical; /*值必须为vertical*/\n-webkit-line-clamp: 2; /*值为数字，表示一共显示几行*/\noverflow: hidden;\n```\n\n## **caret-color**\n\n用来定义插入光标（caret）的颜色，这里说的插入光标，就是那个在网页的可编辑器区域内，用来指示用户的输入具体会插入到哪里的那个一闪一闪的形似竖杠 | 的东西。\n\n```css\ncaret-color: red;\n```\n","tags":["CSS"],"categories":["学习笔记"]},{"title":"HTML5+CSS3命名规范","url":"/posts/HTML5AndCSS3Rename.html","content":"\n## 前言\n\n任何代码编程都有各自特点的常用命名规范，div+css 页面设计也不例外。遵守常用的 css 命名规范有利于代码的升级和扩展，也有利于让别人读懂你的 css 代码，让你的页面显得清晰有条理。\n\n## **css 文件名命名规范**\n\n> 模块：module.css\n> 基本共用：base.css\n> 布局、版面：layout.css\n> 主题：themes.css\n> 专栏：columns.css\n> 文字：font.css\n> 表单：forms.css\n> 补丁：mend.css\n> 打印：print.css\n\n## **页面结构元素 div 命名规范**\n\n> 头：header\n> 内容：content/container\n> 尾：footer\n> 导航：nav\n> 侧栏：sidebar\n> 栏目：column\n> 页面外围控制整体布局宽度：wrapper\n> 左右中：left right center\n> 登录条：loginbar\n> 标志：logo\n> 广告：banner\n> 页面主体：main\n> 热点：hot\n> 新闻：news\n> 下载：download\n> 子导航：subnav\n> 菜单：menu\n> 子菜单：submenu\n> 搜索：search\n> 友情链接：friendlink\n> 页脚：footer\n> 版权：copyright\n> 滚动：scroll\n> 内容：content\n> 标签页：tab\n> 文章列表：list\n> 提示信息：msg\n> 小技巧：tips\n> 栏目标题：title\n> 加入：joinus\n> 指南：guild\n> 服务：service\n> 注册：regsiter\n> 状态态：status\n> 投票：vote\n> 合作伙伴：partner\n\n## **页面结构**\n\n> 容器: container\n> 页头：header\n> 内容：content/container\n> 页面主体：main\n> 页尾：footer\n> 导航：nav\n> 侧栏：sidebar\n> 栏目：column\n> 页面外围控制整体布局宽度：wrapper\n> 左右中：left right center\n\n## **颜色命名-使用颜色的名称或者 16 进制代码**\n\n```css\n.red {\n  color: red;\n}\n.f60 {\n  color: #f60;\n}\n.ff8600 {\n  color: #ff8600;\n}\n```\n\n## **字体大小命名-直接使用“font+字体大小”作为名称**\n\n```css\n.font12px {\n  font-size: 12px;\n}\n.font9pt {\n  font-size: 9pt;\n}\n```\n\n## **对齐样式命名-使用对齐目标的英文名称**\n\n```css\n.left {\n  float: left;\n}\n.bottom {\n  float: bottom;\n}\n```\n\n## **标题栏样式命名-使用“类别+功能”的方式命名**\n\n```css\n.barnews {\n}\n.barproduct {\n}\n```\n\n## **注释书写规范**\n\n1.  行间注释-直接写于属性值后面，如：\n\n```css\n.search {\n  border: 1px solid #fff; /*定义搜索输入框边框*/\n  background: url(../images/icon.gif) no-report #333; /*定义搜索框的背景*/\n}\n```\n\n2.  整段注释-分别在开始及结束地方加入注释，如：\n\n```css\n/*=====搜索条=====*/\n.search {\n  border: 1px solid #fff;\n  background: url(../images/icon.gif) no-repeat #333;\n}\n/*=====搜索条结束=====*/\n```\n\n## **注意事项**\n\n> 1、一律小写；\n> 2、尽量用英文；\n> 3、尽量不缩写，除非一看就明白的单词；\n> 4、属性的值一定要用双引号（“”）括起来，且一定要有值如 class=”divcss5”，id=”divcss5”；\n> 5、每个标签都要有开始和结束，且要有正确的层次，排版有规律工整。\n","tags":["HTML","CSS"],"categories":["学习笔记"]},{"title":"Hexo-报错解决记录","url":"/posts/HexoError.html","content":"\n## hexo generate (hexo g)\n\n### Cannot read property ‘count’ of undefined\n\n```sh\nFATAL Something's wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html\nTypeError: Cannot read property 'count' of undefined\n    at Hexo.module.exports (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\hexo-baidu-url-submit\\lib\\generator.js:4:41)\n    at Hexo.tryCatcher (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\util.js:16:23)\n    at Hexo. (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\method.js:15:34)\n    at C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\hexo\\lib\\hexo\\qipao.js:380:22\n    at tryCatcher (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\util.js:16:23)\n    at MappingPromiseArray._promiseFulfilled (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\map.js:68:38)\n    at MappingPromiseArray.PromiseArray._iterate (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\promise_array.js:115:31)\n    at MappingPromiseArray.init (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\promise_array.js:79:10)\n    at MappingPromiseArray._asyncInit (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\map.js:37:10)\n    at _drainQueueStep (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\async.js:97:12)\n    at _drainQueue (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\async.js:86:9)\n    at Async._drainQueues (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\async.js:102:5)\n    at Immediate.Async.drainQueues [as _onImmediate] (C:\\Users\\L\\Desktop\\MyBlog-matery\\node_modules\\bluebird\\js\\release\\async.js:15:14)\n    at processImmediate (internal/timers.js:439:21)\n```\n\n> 因百度主动提交插件导致，已安装插件却未完成 `_config.yml`的信息完善\n\n**解决方案**\n\n1.  完善`_config.yml`\n\n```yml\n# hexo-baidu-url-submit  百度主动推送\nbaidu_url_submit:\n  count: 80 # 提交最新的一个链接\n  host: blog.cn # 在百度站长平台中注册的域名\n  token: TGtEmSO8ZImXXXXX # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!\n  path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里\n```\n\n2.  删除百度主动推送插件\n\n```shell\nnpm remove hexo-baidu-url-submit\nhexo clean\nhexo g\n```\n\n### 部署或本地预览网页为空白\n\n运行`hexo g` 命令没有问题，但是编辑器打开 `public` 文件生成的 `index.html`中代码未自动生成\n\n> 因 node.js 的版本过高\n\n**解决方案**\n\n降低 node.js 版本，建议使用 node.js (12.13.0)\n\n[node.js 12.X 版本传送门](https://nodejs.org/dist/latest-v12.x/)\n\n### 代码高亮问题({}被编译成#234)\n\n在你博客的根目录。\n输入指令 `npm uninstall hexo --save` 卸载 现在的版本\n在输入 `npm install hexo@加要安装的版本 --save`即可\n\neg:`npm install hexo@4.2.0 --save`\n\n### 卜蒜子统计未显示问题\n\n在`matery.css`中添加如下代码\n\n```css\n#busuanzi_container_site_pv,\n#busuanzi_value_site_pv,\n#busuanzi_container_site_uv {\n  display: inline !important;\n}\n```\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Hexo更文自动打开编辑器","url":"/posts/HexoAutoOpenTypora.html","content":"\n# 更新博客文章自动打开编辑器\n\n## 在博客文件根目录`scripts`中新建`new.js`文件\n\n```javascript\nvar spawn = require(\"child_process\").exec;\n\n// Hexo 2.x 用户复制这段\n// hexo.on('new', function(path){\n//   spawn('start  \"markdown编辑器绝对路径.exe\" ' + path);\n// });\n\n// Hexo 3 用户复制这段\nhexo.on(\"new\", function (data) {\n  spawn('start  \"D:TyporaTypora.exe\" ' + data.path);\n});\n```\n\nD:\\Typora\\Typora.exe 为编辑器绝对路径\n\n### 运行命令`hexo cl&&hexo g&&hexo d`后即可\n\n### 新建文章命令`hexo new \"文章名\"`\n\n## 可选项：\n\n### 更改`scaffolds`文件夹中`post.md`内容\n\n### 可将默认生成文件头部格式更改为\n\n```markdown\n---\ntitle: { { title } }\ndate: { { date } }\nupdate: { { date } }\nauthor: aloeJun # 文章作者\nimg: /source/images/xxx.jpg # 文章特征图\ntop: true # 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章\ncover: false # 表示该文章是否需要加入到首页轮播封面中\ncoverImg: /images/1.jpg # 表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片\npassword: # 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256(https://www.jsons.cn/sha/) 加密后的密码，防止被他人识破\ntoc: false # 是否开启 TOC(目录)，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项\nmathjax: false # 是否开启数学公式支持 ，本文章是否开启 mathjax\nsummary: # 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要\ncategories: 工具 # 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类\ntags: # 文章标签，一篇文章可以多个标签\n  - blog\n  - hexo\n---\n```\n","tags":["Typora","Hexo"],"categories":["经验分享"]},{"title":"Hexo-友联监控","url":"/posts/HexoSupervisoryControl.html","content":"\n# 添加友链监测页\n\n## 效果\n\n> 年久失修   详细效果请部署后自行查看\n\n图标皆来自 [Font Awesome 中文网](https://www.fontawesome.com.cn/) 如有更好推荐，欢迎留言\n\n有免费版也有付费版，以下只针对免费版。\n\n## 简介\n\n- Uptime Robot 是一个网站监控服务，每 5 分钟检查一次你设定的网站 或服务器，最多可以免费检查 50 个网站。\n- 如果你的网站或者服务器宕机时，Uptime Robot 会通过邮件提醒你。\n- 有多种监控方式、支持自定义域名\n\n## 使用\n\n1.  访问官网，注册账号 ： [传送门](https://uptimerobot.com/)\n2.  注册账号\n3.  添加监视器。点击`add new monitor`\n    勾选“**Alert Contacts To Notify**“会有邮箱提醒。\n    若想添加本博客同款，至此请继续阅读 Matery 模板\n\n    > 有四种监控方式，分别为**Http(s)\\*\\_、\\_Ping**、**Port**、**Keyword**，在这里我选择 Http(s)来监控我的网站，选择**Ping**来监控我的服务器。**Port**一般用于 VPS 监控。\n\n4.  打开公共状态页。\n    点击上方[**My Settings**](https://uptimerobot.com/dashboard#mySettings)，选择右下角**Add Public Status Pages**。填写**名称**，以及**Logo**以及**自定义域名**和是否设置密码。\n    自定义域名我是用的 **bkjw.rogn.top**，还得去域名控制台添加一下解析信息，记录类型为**CNAME**，记录值为**stats.uptimerobot.com**\n    > 虽然我没有用它自动生成的页面，但不排除会有需要的\n\n## Matery 模板\n\n### 新建页面\n\n```shell\nhexo new _page supervise\n```\n\n修改`supervise`目录下的`index.md`的格式\n\n```yml\n---\ntitle: supervise\ntype: \"supervise\"\nlayout: \"supervise\"\ndate: 2020-12-07 13:04:17\n---\n```\n\n### 在主题配置文件中添加导航\n\n```yml\n友链监测:\n  url: /supervise\n  icon: fa fa-desktop\n```\n\n### 添加 supervise.ejs\n\n在 `matery/layout` 下新建 `supervise.ejs`\n\n```ejs\n<style>\ntable,td,th{border:0}.card-supervise{padding:24px;border-radius:0 0 2px 2px}.wname{font-size:16px}.card-panel{padding:0;color:#fff}.supervise_details{margin:38px 0 15px -4px;font-size:1.6rem;font-weight:700;line-height:1.7rem}.panel-heading{font-size:20px}.teal{margin-right:5px}.check>tbody>tr>td{padding-top:11px;padding-bottom:11px}.check th{text-align:center}.check .center{text-align:center;vertical-align:middle}.check .sertitle{vertical-align:middle}.status-success{color:#5cb85c}.status-warning{color:#f0ad4e}.status-danger{color:#d9534f}#server-container{border-bottom:1px solid #ddd}.barl>td{border-top:none!important;padding:0!important}.barl .progress{margin:0;border-radius:0;height:8px;box-shadow:none}.barl .progress .progress-bar{box-shadow:none;opacity:.7}.barl .progress .progress-bar:hover{opacity:1}.barl .progress .progress-bar-default{background-color:#efefef}.progress .tooltip .tooltip-inner .ttime{color:#a3a3a3;font-size:11px}.credit{font-size:12px;color:#bbb}.credit a{color:#999}.credit .pipe{padding-left:6px;padding-right:6px;color:#ddd}\n\n</style>\n<%- partial('_partial/bg-cover') %>\n    <main class=\"content\" style=\"min-height: 131px;\">\n        <div class=\"container chip-container\">\n            <div class=\"card\">\n                <div class=\"card-content\">\n                    <div class=\"tag-title center-align\"><i class=\"fa fa-desktop\"></i>&nbsp;&nbsp;友链状态监测</div>\n                    <div class=\"supervise_details\">本页面是友情链接状态监控，展示了全部链接的当前运行状态。</div>\n                    <hr>\n                    <div class=\"panel panel-info\">\n                        <div class=\"panel-heading\">各友情链接当前状态</div>\n                        <div class=\"panel-body\">\n                            <div id=\"panel-heading\" class=\"alert alert-warning hide\" role=\"alert\">\n                                <b>当前状态：</b>部分友链发生异常，我们将尽快修复。\n                            </div>\n                            <div id=\"stattip-ok\" class=\"alert alert-success hide\" role=\"alert\">\n                                <b>当前状态：</b>所有友链正常运行中，没有发现异常。\n                            </div>\n                            <div id=\"stattip-load\" class=\"alert alert-info\" role=\"alert\">\n                                <b>当前状态：</b>正在检测运行状态，请稍候..\n                            </div>\n                            <div class=\"table-responsive\">\n                                <table class=\"table table-hover check\">\n                                    <thead>\n                                    <tr id=\"server-title\">\n                                    </tr>\n                                    </thead>\n                                    <tbody id=\"server-container\"></tbody>\n                                </table>\n                            </div>\n                        </div>\n                        <div class=\"alert alert-info\" style=\"text-align:center;margin-bottom:0\">\n                            距离下次监测刷新时间:\n                            <span class=\"fa fa-refresh\"></span> <span id=\"last-update\"></span>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </main>\n    <script type=\"template/mustache\" id=\"server-template\">\n        <tr class=\"{{alert}}\">\n            <td rowspan=\"2\" class=\"sertitle\">\n                <span class=\"card-panel {{label}}\"><span class=\"fa fa-{{statusicon}}\"style=\"padding-left: 2px;\"></span> {{statustxt}}</span>\n                <span class=\"wname\">{{friendlyname}}</span>\n            </td>\n            {{#charts}}\n            <td class=\"center\">\n                <span class=\"status-{{uptype}} set-tooltip\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"{{uptime}}\"><span class=\"fa fa-{{upsign}}\"></span></span>\n            </td>\n            {{/charts}}\n        </tr>\n        <tr class=\"{{alert}} barl\">\n            <td colspan=\"8\" class=\"barls\">\n                <div class=\"progress\">\n                    {{#progress}}\n                    <div class=\"progress-bar progress-bar-{{types}} set-tooltip\" style=\"width: {{len}}%\" data-toggle=\"tooltip\" data-placement=\"top\" title=\"{{stattip}}\"></div>\n                    {{/progress}}\n                </div>\n            </td>\n        </tr>\n    </script>\n    <script>function date(n,t){function e(n,t){return(n+=\"\").length<t?new Array(++t-n.length).join(\"0\")+n:n}var u=t?new Date(1e3*t):new Date,r=[\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],o={1:\"st\",2:\"nd\",3:\"rd\",21:\"st\",22:\"nd\",23:\"rd\",31:\"st\"},a=[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],i={d:function(){return e(i.j(),2)},D:function(){return i.l().substr(0,3)},j:function(){return u.getDate()},l:function(){return r[i.w()]},N:function(){return i.w()+1},S:function(){return o[i.j()]?o[i.j()]:\"th\"},w:function(){return u.getDay()},z:function(){return(u-new Date(u.getFullYear()+\"/1/1\"))/864e5>>0},W:function(){var n,t=i.z(),e=364+i.L()-t,r=(new Date(u.getFullYear()+\"/1/1\").getDay()||7)-1;return e<=2&&(u.getDay()||7)-1<=2-e?1:t<=2&&4<=r&&6-r<=t?(n=new Date(u.getFullYear()-1+\"/12/31\"),date(\"W\",Math.round(n.getTime()/1e3))):1+(r<=3?(t+r)/7:(t-(7-r))/7)>>0},F:function(){return a[i.n()]},m:function(){return e(i.n(),2)},M:function(){return i.F().substr(0,3)},n:function(){return u.getMonth()+1},t:function(){var n;return 2==(n=u.getMonth()+1)?28+i.L():1&n&&n<8||!(1&n)&&7<n?31:30},L:function(){var n=i.Y();return 3&n||!(n%100)&&n%400?0:1},Y:function(){return u.getFullYear()},y:function(){return(u.getFullYear()+\"\").slice(2)},a:function(){return 11<u.getHours()?\"pm\":\"am\"},A:function(){return i.a().toUpperCase()},B:function(){var n=60*(u.getTimezoneOffset()+60),t=3600*u.getHours()+60*u.getMinutes()+u.getSeconds()+n,e=Math.floor(t/86.4);return 1e3<e&&(e-=1e3),e<0&&(e+=1e3),1==String(e).length&&(e=\"00\"+e),2==String(e).length&&(e=\"0\"+e),e},g:function(){return u.getHours()%12||12},G:function(){return u.getHours()},h:function(){return e(i.g(),2)},H:function(){return e(u.getHours(),2)},i:function(){return e(u.getMinutes(),2)},s:function(){return e(u.getSeconds(),2)},O:function(){var n=e(Math.abs(u.getTimezoneOffset()/60*100),4);return n=0<u.getTimezoneOffset()?\"-\"+n:\"+\"+n},P:function(){var n=i.O();return n.substr(0,3)+\":\"+n.substr(3,2)},c:function(){return i.Y()+\"-\"+i.m()+\"-\"+i.d()+\"T\"+i.h()+\":\"+i.i()+\":\"+i.s()+i.P()},U:function(){return Math.round(u.getTime()/1e3)}};return n.replace(/[\\\\]?([a-zA-Z])/g,function(n,t){return ret=n==t&&i[t]?i[t]():t,ret})}</script>\n    <script src=\"<%- theme.jsDelivr.url %><%- url_for('/js/mustache.min.js') %>\"></script>\n    <script src=\"<%- theme.jsDelivr.url %><%- url_for('/js/uptimerobot.js') %>\"></script>\n    <script src=\"<%- theme.jsDelivr.url %><%- url_for('/js/upscuits.js') %>\"></script>\n    <script type=\"text/javascript\">jQuery(document).ready(myApp.dashboard.init)</script>\n```\n\n### 引入 JS 文件\n\n1.  下载 JS 文件\n    [mustache.min.js](https://cdn.jsdelivr.net/gh/ialoe/ialoe.github.io@master/js/mustache.min.js)\n    [upscuits.js](https://cdn.jsdelivr.net/gh/ialoe/ialoe.github.io@master/js/upscuits.js)\n2.  新建 JS 文件\n    配置 JS 文件中 `uptimerobot.js` 内容\n\n```javascript\nvar __apiKeys = [\n  \"xxxxxxxxxx\", // API 1\n  \"xxxxxxxxxx\", // API 2\n];\n//https://uptimerobot.com/ 设置要监控的域名或者ip 获取到key\n\n// refresh interval (in seconds 暂定五分钟)\nvar __refresh = 300;\n```\n\n### 获取 API\n\n将 API 复制到`uptimerobot.js` 中即可\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Hexo-导航页","url":"/posts/HexoNavigationPage.html","content":"\n# Hexo 添加导航页\n\n## 效果\n\n> 年久失修，详细效果请自己部署后查看\n\n## 新建页面\n\n首先新建页面，执行下面的命令\n\n`hexo new page navigate`\n\n修改`navigate`目录下的`index.md`的格式\n\n```markdown\n---\ntitle: 导航\ndate: 2020-10-18 15:19:14\ntype: \"navigate\"\nlayout: \"navigate\"\n---\n```\n\n## 在主题配置文件中添加导航\n\n```yml\n# main menu navigation url and icon\n# 配置菜单导航的名称、路径和图标icon.\nmenu:\n  Index:\n    url: /\n    icon: fas fa-home\n  标签:\n    url: /tags\n    icon: fas fa-tags\n  时光轴:\n    url: /archives\n    icon: fas fa-hourglass-half\n  留言板:\n    url: /contact\n    icon: fas fa-comments\n  关于:\n    url: /about\n    icon: fas fa-user-circle\n  友情链接:\n    url: /friends\n    icon: fas fa-address-book\n  Select:\n    icon: fas fa-life-ring\n    children:\n      - name: 导航\n        url: /navigate\n        icon: fas fa-location-arrow\n      - name: 相册\n        url: /galleries\n        icon: fas fa-image\n```\n\n## 添加 navigate 页面\n\n在 `matery/layout` 下新建 `navigate.ejs`\n\n```ejs\n<style>\ndd,dl,dt,form,h1,h2,h3,h4,h5,h6,li,p,ul{margin:0;padding:0;font-size:14px;font-weight:400}img{border-style:none}li{list-style:none;float:left}a{text-decoration:none}.card{background-color:rgba(25,240,229,0);width:96%;margin-left:2%}.baidu{float:left;margin-left:100px}.baidu form{position:relative}.Select-box ul{height:40px;position:absolute;left:-1px;top:0;z-index:9999;background:#fff;border:1px solid #ccc;border-top:none;overflow:hidden}.Select-box li{width:60px;line-height:40px;font-size:14px;color:#484848;border:0;cursor:pointer}.Select-box li:hover{background:#3385ff;color:#fff}.Select-box .this_s{color:#317ef3}.Select-box .this_s:hover{background:#fff;color:#317ef3}.qingkong{position:absolute;right:120px;top:12px;width:18px;height:18px;background:rgba(0,0,0,.1);border-radius:18px;line-height:16px;color:#666;cursor:pointer;text-align:center;font-size:14px;display:none}.qingkong:hover{background:rgba(0,0,0,.2)}.qingkong:active{background:rgba(0,0,0,.3)}.baidu-2{width:100%;height:110px;margin:0 auto;background:0 0;padding-top:50px}.baidu-2 form{width:520px;margin:0 auto}.baidu-2 input{padding:13px 8px;opacity:.9;font-size:15px}#Select-2{float:left}.Select-box-2{text-align:center;float:left;position:relative}.Select-box-2 ul{height:46px;position:absolute;left:0;top:1px;z-index:9999;background:rgba(255,255,255,.9);border:1px solid #ccc;border-top:none;overflow:hidden}.Select-box-2 li{width:60px;line-height:46px;font-size:15px;color:#484848;border:0;cursor:pointer}.Select-box-2 li:hover{background:#3385ff;color:#fff}.Select-box-2 .this_s{color:#317ef3}.Select-box-2 .this_s:hover{background:0 0;color:#317ef3}#kw-2{width:335px;outline:0;border:1px solid #ccc;background:rgba(255,255,255,.2);color:#000;padding-left:70px;font-weight:700}#su-2{width:90px;background:#00f;border:none;border-top:#3385ff 1px solid;border-bottom:1px solid #2d78f4;color:#fff;cursor:pointer;outline:0}#su-2:hover{background:#00f;border-bottom:1px solid #00f}#su-2:active{background:#00f;box-shadow:inset 1px 1px 3px #00f;-webkit-box-shadow:inset 1px 1px 3px #00f}.jj-list-tit{font-size:16px;line-height:25px;color:#fff;width:100%;padding-left:38.5%}.jj-list-con{overflow:hidden;margin:0 auto}.jj-list-con li{width:31.333%;margin:1%}.link-3{display:block;background:rgba(0,0,0,.35);color:#fff;font-size:13px;text-align:center;line-height:35px;padding:4px 0;border-radius:2px;transition:all .2s}.link-3:hover{background:rgba(0,0,0,.45);font-size:15px;font-weight:700}@media only screen and (max-width:584px){.navi-height{height:1300px}.link-box{margin-top:5%}.large-screen{display:none}}@media only screen and (min-width:584px) and (max-width:993px){.navi-height{height:800px}.link-box{margin-top:5%}.large-screen{display:none}}@media only screen and (min-width:993px){.navi-height{position:absolute;width:100%;height:100%}}.page-footer{display:none}\n\n</style>\n<div class=\"navi-height bg-cover pd-header\">\n    <div class=\"link-box container\">\n        <div class=\"baidu baidu-2 large-screen\">\n            <form name=\"f\" action=\"https://www.baidu.com/\" target=\"_blank\">\n                <div id=\"Select-2\">\n                    <div class=\"Select-box-2\" id=\"baidu\">\n                        <ul style=\"height:46px\">\n                            <li class=\"this_s\">百 · 度</li>\n                            <li class=\"bing_s\">必 · 应</li>\n                            <li class=\"google_s\">谷 · 歌</li>\n                            <li class=\"baidu_s\">百 · 度</li>\n                        </ul>\n                    </div> <input name=\"wd\" id=\"kw-2\" maxlength=\"100\" autocomplete=\"off\" type=\"text\">\n                </div>\n                <div class=\"qingkong\" id=\"qingkong\" title=\"清 · 空\" style=\"display:none\">x</div> <input value=\"搜 · 索\" id=\"su-2\" type=\"submit\">\n                <ul class=\"keylist\"></ul>\n            </form>\n        </div>\n        <div class=\"row tags-posts\">\n            <div class=\"col s12 m6 l4 friend-div aos-init\" data-aos=\"zoom-in-up\">\n                <div class=\"card\">\n                    <div class=\"jj-list-tit\">娱乐 · 影视</div>\n                    <ul class=\"jj-list-con\">\n                        <li><a href=\"https://www.jd.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">京东</a>\n                        </li><li><a href=\"https://www.taobao.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">淘宝</a></li>\n                        <li><a href=\"https://www.tmall.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">天猫</a></li>\n\n                        <li><a href=\"https://v.qq.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">腾讯视频</a></li>\n                        <li><a href=\"https://www.iqiyi.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">爱奇艺</a></li>\n                        <li><a href=\"https://www.bilibili.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">哔哩哔哩</a> </li>\n                        <li><a href=\"https://music.163.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">网易云音乐</a></li>\n                        <li><a href=\"https://y.qq.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">QQ音乐</a></li>\n                        <li><a href=\"https://www.kugou.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">酷狗音乐</a></li>\n                    </ul>\n                </div>\n            </div>\n            <div class=\"col s12 m6 l4 friend-div aos-init\" data-aos=\"zoom-in-up\">\n                <div class=\"card\">\n                    <div class=\"jj-list-tit\">社区 · Code</div>\n                    <ul class=\"jj-list-con\">\n                        <li><a href=\"https://www.mobaijun.com/contact/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">留言</a></li>\n                        <li><a href=\"https://github.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">GitHub</a></li>\n                        <li><a href=\"https://coding.net/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">Coding</a></li>\n                        <li><a href=\"https://juejin.im/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">掘金</a></li>\n                        <li><a href=\"https://gitee.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">码云</a></li>\n                        <li><a href=\"https://www.csdn.net/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">CSDN</a></li>\n                        <li><a href=\"https://www.jianshu.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">简书</a></li>\n                        <li><a href=\"https://segmentfault.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">思否</a></li>\n                        <li><a href=\"https://cloud.tencent.com/developer/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">云+社区</a></li>\n                    </ul>\n                </div>\n            </div>\n            <div class=\"col s12 m6 l4 friend-div aos-init\" data-aos=\"zoom-in-up\">\n                <div class=\"card\">\n                    <div class=\"jj-list-tit\">实用 · 工具</div>\n                    <ul class=\"jj-list-con\">\n                        <li><a href=\"https://mdnice.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">Markdown编辑器</a></li>\n                        <li><a href=\"https://translate.google.cn/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">谷歌翻译</a></li>\n                        <li><a href=\"https://www.uupoop.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">在线PS</a></li>\n                        <li><a href=\"https://www.processon.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">思维导图</a></li>\n                        <li><a href=\"https://wallhaven.cc/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">超清壁纸</a></li>\n                        <li><a href=\"https://cli.im/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">二维码生成</a></li>\n                        <li><a href=\"https://tool.cc/pic-resizer/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">图片在线压缩</a></li>\n                        <li><a href=\"https://www.iconfont.cn/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">阿里巴巴图标库</a></li>\n                        <li><a href=\"https://my.openwrite.cn/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">OW分发</a></li>\n                    </ul>\n                </div>\n            </div>\n            <div class=\"col s12 m6 l4 friend-div aos-init\" data-aos=\"zoom-in-up\">\n                <div class=\"card\">\n                    <div class=\"jj-list-tit\">编程 · 学习</div>\n                    <ul class=\"jj-list-con\">\n                        <li><a href=\"https://www.oschina.net/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">开源中国</a></li>\n                        <li><a href=\"https://htmldog.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">HTML狗</a></li>\n                        <li><a href=\"https://www.icourse163.org/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">中国大学慕课</a></li>\n                        <li><a href=\"https://www.imooc.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">慕课网</a></li>\n                        <li><a href=\"https://www.wxapp-union.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">小程序</a></li>\n                        <li><a href=\"https://www.runoob.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">菜鸟教程</a></li>\n                        <li><a href=\"https://blog.51cto.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">51CTO</a></li>\n                        <li><a href=\"https://www.shiyanlou.com/library/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">实验楼</a></li>\n                        <li><a href=\"https://spring.io/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">Spring</a></li>\n                    </ul>\n                </div>\n            </div>\n            <div class=\"col s12 m6 l4 friend-div aos-init\" data-aos=\"zoom-in-up\">\n                <div class=\"card\">\n                    <div class=\"jj-list-tit\">资讯 · 趋势</div>\n                    <ul class=\"jj-list-con\">\n                        <li><a href=\"https://www.huxiu.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">虎嗅</a></li>\n                        <li><a href=\"https://insights.stackoverflow.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">技术调查</a></li>\n                        <li><a href=\"https://www.asciiworld.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">摸鱼</a></li>\n                        <li><a href=\"https://sspai.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">少数派</a></li>\n                        <li><a href=\"https://zh.wikihow.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">WikeHom</a></li>\n                        <li><a href=\"https://www.awesomes.cn/rank?sort=hot\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">前端趋势</a></li>\n                        <li><a href=\"https://github-trending.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">GitHub趋势</a></li>\n                        <li><a href=\"https://www.tiobe.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">编程趋势</a></li>\n                        <li><a href=\"https://trends.google.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">Google趋势</a></li>\n                    </ul>\n                </div>\n            </div>\n            <div class=\"col s12 m6 l4 friend-div aos-init\" data-aos=\"zoom-in-up\">\n                <div class=\"card\">\n                    <div class=\"jj-list-tit\">搜索 · 其他</div>\n                    <ul class=\"jj-list-con\">\n                        <li><a href=\"https://ac.scmor.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">谷歌镜像</a></li>\n                        <li><a href=\"https://www.pansoso.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">网盘搜索</a></li>\n                        <li><a href=\"https://tool.mkblog.cn/music/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">音乐搜索</a></li>\n                        <li><a href=\"https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">又拍云</a></li>\n                        <li><a href=\"https://carbon.now.sh/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">代码图片</a></li>\n                        <li><a href=\"https://www.zhipin.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">Boos</a></li>\n                        <li><a href=\"https://www.fontawesome.com.cn/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">图标库</a></li>\n                        <li><a href=\"https://www.qvdv.com/tools/qvdv-guid.html\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">在线工具</a>\n                        </li>\n                        <li><a href=\"https://zhongguose.com/\" rel=\"external nofollow noreferrer\" class=\"link-3\" target=\"_blank\">中国色</a></li>\n                    </ul>\n                </div>\n            </div>\n        </div>\n        <script>$(\".Select-box ul\").hover(function(){$(this).css(\"height\",\"auto\")},function(){$(this).css(\"height\",\"40px\")}),$(\".Select-box-2 ul\").hover(function(){$(this).css(\"height\",\"auto\")},function(){$(this).css(\"height\",\"46px\")}),$(\".Select-box li\").click(function(){var t=$(this).attr(\"class\"),s=$(this).html();\"baidu_s\"==t&&(t=\"https://www.baidu.com/s\",_name=\"wd\"),\"google_s\"==t&&(t=\"https://www.google.com/search\",_name=\"q\"),\"bing_s\"==t&&(t=\"https://www.bing.com/search\",_name=\"q\"),$(\".baidu form\").attr(\"action\",t),$(\".this_s\").html(s),$(\"#kw\").attr(\"name\",_name),$(\".Select-box ul\").css(\"height\",\"40px\")}),$(\".Select-box-2 li\").click(function(){var t=$(this).attr(\"class\"),s=$(this).html();\"baidu_s\"==t&&(t=\"https://www.baidu.com/s\",_name=\"wd\"),\"google_s\"==t&&(t=\"https://www.google.com/search\",_name=\"q\"),\"bing_s\"==t&&(t=\"https://www.bing.com/search\",_name=\"q\"),$(\".baidu form\").attr(\"action\",t),$(\".this_s\").html(s),$(\"#kw-2\").attr(\"name\",_name),$(\".Select-box-2 ul\").css(\"height\",\"48px\")})</script>\n    </div>\n</div>\n```\n\n## 预览部署\n\n执行相关命令\n\n预览\n\n`hexo cl&&hexo g&&hexo s`\n\n部署\n\n`hexo cl&&hexo g&&hexo d`\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Hexo-live2D添加","url":"/posts/HexoLive2D.html","content":"\n### 安装插件\n\n`npm install --save hexo-helper-live2d`\n\n等待加载就 OK！\n\n### 添加配置\n\nhexo 的配置文件 `_config.yml` 中添加如下配置:\n\n```yaml\n# 看板娘\nlive2d:\n  enable: true # 是否开启看板娘\n  scriptFrom: local\n  pluginRootPath: live2dw/\n  pluginJsPath: lib/\n  pluginModelPath: assets/\n  tagMode: false\n  log: false\n  model:\n    use: live2d-widget-model-shizuku # 模型名称\n  display:\n    superSample: 2 # rate for super sampling rate 超采样等级\n    position: right # Left of right side to show 显示位置：左或右\n    width: 150 # Width to the canvas which shows the model canvas的长度\n    height: 300 # Height to the canvas which shows the model canvas的高度\n    hOffset: 75 # Horizontal offset of the canvas canvas水平偏移\n    vOffset: -20 # Vertical offset of the canvas canvas垂直偏移\n  mobile:\n    show: true # Whether to show on mobile device 是否在移动设备上显示\n    scale: 0.5 # Scale on mobile device 移动设备上的缩放\n  react:\n    opacity: 0.7 # opacity 透明度\n  name:\n    canvas: \"live2dcanvas\" # ID name of the canvas canvas元素的ID\n    div: \"live2d-widget\" # ID name of the div div元素的ID\n  dev:\n    border: false # Whether to show border around the canvas 在canvas周围显示边界\n  dialog:\n    enable: false # Display dialog 显示人物对话框\n    hitokoto: false # Enable hitokoto 使用一言API\n```\n\n### 选择模型\n\n下面提供模型参考图可根据需求选择\n\n---\n\n>  年久失修   自己动手  丰衣足食\n\n---\n\n### 模型参考示例\n\n可根据下列模型昵称选择自己喜欢的，如 hijiki 一只黑色的猫\n\n进行安装模型时\n`npm install --save live2d-widget-model-hijiki`\n\n> 参考图提供 width,height 可供参考(配置文件 `_config.yml` 下修改)\n","tags":["Hexo"],"categories":["经验分享"]},{"title":"Java基础笔记","url":"/posts/JavaBasics.html","content":"\n# Java 基础\n\n## Java 语言特点\n\n1. 跨平台( 一次开发，到处运行)\n2. 面向对象(万物皆对象)\n\n## Java 开发运行环境\n\nJDK:Java 开发工具集(开发人员需要安装)[window 配置 JDK](https://ialoe.top/posts/57766.html)\n\nJVM:java 虚拟机\n\nJRE:java 运行环境（运行 java 程序必须安装）\n\n注:java 程序最终是运行在 jvm 虚拟机上的，不同的操作系统上可以安装其对应版本的 jvm，这样就实现了跨平台\n\n## java 程序开发的步骤\n\n1.  编写源代码 (后缀.java)\n\n```java\npublic class HelloWorld{\n    public static void main(String[] args){\n        System.out.println(\"Hello World！\");\n    }\n}\n```\n\n2.  编译                 (后缀.class)\n    `javac 文件名.java`\n3.  运行\n    `java 文件名`\n\n## java 类的结构\n\n```java\npublic \tclass 类名{\n    public static void main(String[] args){\n\n    }\n}\n```\n\nmain 方法是 Java 程序的入口\n\n## 语法规则\n\n### 输出语句\n\n```java\nSystem.out.println(\"输出内容\");\t\t//输出完后自动换行--》System.out.print(\"\\n\");\nSystem.out.print(\"输出内容\");\t\t//输出完后不自动换行\n```\n\n### 转义字符\n\n```\n\\n\t\t换行符\n\\t\t\t大空格(Tab键)\n```\n\n### 注释\n\n```\n//\t\t单行注释\n\n/*\n *\t\t多行注释\n */\n```\n\n### 变量\n\n内存中一块储存空间的表示\n\n#### 变量的数据类型\n\n1.  基本类型(8 种)\n\n- byte  1 个字节\n- char          2 个字节\n- short         2 个字节\n- int             4 个字节\n- long          8 个字节\n- float          4 个字节\n- double      8 个字节\n- boolean    1 个字节\n\n自动     小——》大\n强制     大——》小\n大小是根据占用字节判断\nbyte—》short—》int—》long—》float—》double\nchar——》int 自动\nfloat——》int 强制 (int)12.3f\n\n2.  引用类型\n    String 数组 对象 除了八种基本类型之外的都属于引用数据类型\n\n- 比较相等\n  - Java 基本数据类型(8 种)\n    - 相等 ==\n    - 不相等    !=\n  - String\n    - 相同 `字符串1.equals(字符串2)`\n      - true\n    - 不相同    `!字符串1.equals(字符串2)`\n      - false\n\n#### 变量的声明和使用\n\n1. 先声明后赋值\n   1. 声明变量 数据类型 变量名；\n   1. 变量名 = 变量值；\n   1. 使用\n2. 声明并赋值\n   1. 声明变量 数据类型 变量名 = 变量值；\n   1. 使用\n\n#### 变量的命名规则\n\n1. 字母,数字,下划线,$,但是不能以数字开头\n2. 不能与关键词重名\n3. 见名知义\n4. 多个单词组成时，第一个单词小写其余单词开头首字母大写。 如:myScore\n\n#### 键盘接收\n\n1.  初始化 Scanner 对象\n    `Scanner input=new Scanner(System.in);`\n2.  在程序中导入 Scanner 类\n    在类的外面写`import java.util.Scanner;`\n3.  从键盘接收数据赋值给变量\n\n```java\nString name=input.next();//接收到String类型值\nint age=input.nextInt();//接收到int类型的值\ndouble score=input.nextDouble();//接收到double类型的值\n```\n\n### 数组\n\n#### 声明和使用步骤\n\n1. 声明\n2. 分配空间\n3. 赋值\n4. 使用\n5. 注意\n   - 声明同时分配空间：`数据类型 [] 数组名=new 数据类型[数组长度];\n   - 数组下标从 0 开始         数组元素最大下标值是 `length-1`\n   - 声明的时候赋值\n     - 数据类型 [] 数组名 = new 数据类型[]{值 1,值 2,...}//后面的括号中不能写长度\n     - 数据类型 [] 数组名 = {值 1,值 2,...}//不可拆分\n\n#### 遍历数组元素\n\n```java\nfor(int i=0;i<数组名.length;i++){\n\tSystem.out.println(数组名[下标]);\n}\n```\n\n#### 数组的应用\n\n1.  数组排序\n    使用 Arrays 类 sort 方法排序,默认升序排序\n\n- 步骤\n  1. Arrays 类导入 `import java.util.Arrays`\n  1. `Arrays.sort(要排序的数组);`\n\n2.  求最大值(打擂台思想)\n\n- 思想\n  1. 设置数组第一个元素为默认最大值\n\n2.  循环数组依次与最大值比较\n\n- 关键代码\n\n```java\nint max=数组[0];\nfor(int i=0;i<数组名.length;i++){\n\tif(数组名[i]>max){\n\t\tmax=数组名[i];\n\t}\n}\n```\n\n3.  向数组中添加元素\n    实现思路\n1.  找到待插入元素的下标\n    - 循环数组,当满足   待插入元素大于当前数组元素的时候,终止循环,并用变量保存当前下标\n1.  给待插入元素腾位置\n    - 从后往前移动元素   否则会元素覆盖,丢失  i=length-1;i>找到的下标值;i--前一个元素的值   赋值给   后一个\n1.  插入元素\n    - 数组名[下标]=元素值;\n\n### 运算符\n\n#### 赋值运算符\n\n符号:  =\n\n把等号右边的值赋给左边\n\n> sum+=i;//sum=sum+i;\n\n#### 算数运算符\n\n> \\ + - \\* /(求商)  %(求余数)  ++(自增)  --(自减)\n\n#### 关系运算符\n\n> <,> ,>=,<=,  == (比较两个数是否相等)  !=（比较两数是否不等）\n\n#### 逻辑运算符\n\n> ||或 &&与 !非\n\n#### 优先级\n\n> ！＞算术运算符＞关系运算符＞＆＆＞｜｜\n>\n>     \t最高小括号,最低赋值运算符\n\n### 流程控制语句\n\n##### 流程图\n\n表示程序的运行流程\n\n- ◇ (菱形)表示判断\n- 矩形 表示代码块\n- 平行四边形   输出语句\n- 圆角矩形   开始或者结束\n\n### 选择结构\n\n1.  简单的 if 选择结构\n    语法结构：\n\n```java\nif( boolean类型的值 ){\n\t//代码块\n}\n```\n\n2.  if-else 选择结构-----用于两种分支判断的情形\n    语法结构：\n\n```java\nif(){\n\t//代码块1\n}else{\n\t//代码块2\n}\n```\n\n3.  多重 if 语句 :用于区间连续情形\n    语法结构：\n\n```java\nif(){\n\t//代码块1\n}else if(){\n\t//代码块2\n\t}else{\n\t\t//代码块3\n\t\t}\n```\n\n4.  嵌套 if 语句 :一个完整的 里面嵌套另一个完整的结构\n    语法结构：\n\n```java\nif(){\n\tif(){\n\t\t//代码块1\n\t}else{\n\t\t//代码块2\n\t}\n}else{\n\tif(){\n\t\t//代码块3\n\t}else{\n\t\t//代码块4\n\t}\n}\n```\n\n5.  switch 选择结构----用于等值判断\n    语法结构：\n\n```java\nswitch(变量){\n\tcase 常量1:\n\t\t//代码块1\n\tbreak;\n\tcase 常量2:\n\t\t//代码块2\n\tbreak;\n\tdefault:\n\t\t//代码块3\n\tbreak;\n}\n```\n\n- switch 小括号里的变量  --->整型和字符型,jdk 版本 1.7 以上 支持 String\n- break 可以省略,但是省略之后 case 之间会贯穿执行,直到遇到 break 才结束\n- 各个 case 之间常量值不能重复的\n- default 总是在最后执行的,当前面所有的 case 都匹配不上时,位置不固定\n\n### 循环结构\n\n1.  while 循环-----先判断再执行\n\n```java\n//初始化循环变量\nwhile(判断条件){\n\t\t\t\t//循环操作\n\t\t\t\t更新循环变量\n\t\t\t}\n```\n\n2.  do-while---先执行再判断\n\n```java\n//定义循环变量\ndo{\n\t//循环体\n\t//循环变量的更新\n}while(判断条件);\n```\n\n3.  for 循环---用于固定循环次数\n    执行顺序:同 while  1.变量初始化  2 条件判断  3 循环体  4 变量更新\n    for 循环中 3 个表达式均可省略,但是一般不要省略\n\n```java\nfor(循环变量初始化;条件判断;循环变量更新){\n\t\t\t\t//循环体\n\t      \t\t}\n```\n\n4.  三种循环比较\n    顺序：\n\n- 先判断后执行：while for\n- 先执行后判断：do-while\n- for 循环主要用于循环次数固定\n- 在循环条件不成立的时候，do-while 至少执行一次\n\n5.  二重循环\n    一个完整的循环结构   再嵌套另一个\n    外层循环变化一次,内层循环变化一遍\n\n```java\nfor(){\n\t   //循环体\n\t for(){\n\t \t//循环体\n\t \t}\n\t}\n```\n\n### 流程控制语句\n\n- break\n  - 单层循环中: 终止循环，执行循环外的语句\n  - 二重循环中:用在内层循环中,只能结束内层循环,执行外层剩下的代码\n- continue\n  - 单层循环:跳过本次循环，执行下一次循环\n  - 结束本层的本次循环 执行本层下一次\n\n### 解决代码中的异常\n\n- 常见的错误信息\n  - The local(局部的) variable(变量) num may not have been(可能还没有被) initialized(初始化)===>变量尚未赋值就已经使用\n  - num cannot be resolved to a variable===>变量没有声明\n  - java.util.InputMismatchException  ===>输入类型不匹配\n  - 数组下标越界  java.lang.ArrayIndexOutOfBoundsException   当访问超出了数组下标范围\n    - Array 数组\n    - index 下标\n    - outof 超出了\n    - bounds 边界\n    - Exception 异常\n- 简单的异常处理\n  - input.hasNextInt()   判断用户输入的内容是否是合法整数,合法为 true, 否则为 false\n    - 要在变量赋值之前判断\n- 程序调试\n  程序在我们的控制下一步一步执行\n  - 调试代码之前,要先分析可能出错的位置\n  - 在可能出错的地方   打断点---代码执行到断点处会暂停   行号前双击\n  - 以 debug 模式启动程序  debug as---java application\n  - 单步执行,查找错误(F6) {程序运行到断点处才会启动调试模式}\n  - 找到错误,修改代码\n","tags":["Java"],"categories":["学习笔记"]},{"title":"JavaScript基础","url":"/posts/JavaScriptBasics.html","content":"\n# JavaScript 基础\n\n## JavaScript 特点\n\n1. 用于完成 html 网页交互\n2. 脚本语言\n3. 弱类型的\n4. 客户端的脚本\n5. 解释性的，边解释边执行\n6. 区分大小写\n\n## JavaScript 组成\n\nECMAScript、浏览器对象模型(BOM)、文档对象模型(DOM)\n\n## 网页上引入 js 脚本三种形式\n\n#### 1. 网页内部使用\n\n`<script>`标签添加---->`<body></body>`后面\n\n```html\n<script>\n\t//js代码\n<script>\n```\n\n#### 2. 引入外部 js 脚本\n\n1.  添加 JavaScript 文件，在里面编写代码\n2.  在 html 页面中添加标签,引入外部文件\n    `<script type=\"text/javascript\" src=\"要引入文件的相对路径\" ></script>`\n\n#### 3. 在网页标签元素的属性中添加\n\n`<input type=\"button\" name=\"btn\" value=\"请点击\" onclick=\"alert('hello world!!!')\"/>`\n\n#### 三种引入 JavaScript 脚本的方式分别适合在什么时候用呢？\n\n- 如果在标签属性中添加，只能作用于本标签，不能实现效果的重用\n- 如果在页面内部通过 Script 标签引入，可以实现本页面的效果共享\n- 引入外部 js 文件，可以实现页面间的代码共享，保证网页结构代码和效果代码相分离\n\n## 标识符\n\n变量名，函数名，属性以及函数中的参数都属于标识符\n\n### 命名规则\n\n1. 只能包含数字，字母，下划线和$ ，但是不能以数字开头\n2. 不能包含其他符号\n3. 不能和 js 中关键字，保留字冲突\n\n## JavaScript 注释\n\n- 单行  //\n  `//注释内容`\n- 多行注释  /\\_ \\_/\n  `/*注释内容*/`\n\n## 系统弹框\n\n1.  `alert(\"\");`   警示框\n2.  `confirm(\"\");`   确认框,包含确认,取消按钮\n\n```javascript\nvar n = confirm(\"-----？\"); //得到的值是布尔类型的\nif (n) {\n  //点击了确定\n} else {\n  //点击了取消\n}\n```\n\n3.  可以让用户输入的提示框\n\n```javascript\nvar 变量名 = prompt(\"提示给用户的信息\", \"默认值\");\n```\n\n- 用户点击确定，能够返回用户输入的值\n- 用户点击取消，返回的值是 null\n\n## JavaScript 下载解析\n\n- head:   先下载 js 脚本，再显示页面----》当网络不好时，用户只能看到空白页面并且一直等待网页显示\n- body: 先显示网页内容，然后遇到 js 脚本时再下载解析---》当网络不好时，用户可以先看到没有效果的页面\n- body 后面  html2.0 不支持\n  为了优化加载速度大多使用异步加载(放在 body 后面)，先加载页面后实现效果\n\n## 变量与数据类型\n\n- console.log(\"\");   向控制台输出一句话（浏览器的控制台，f12 可以打开）多用于程序调试，观察变量的值\n- javaScript 是弱类型的，松散型的\n\n### 变量\n\n1.  声明\n\n- var 关键字声明变量\n  - 变量声明\n    - var 变量名；\n    - 同时定义多个变量： var 变量名 1,变量名 2,....;\n  - 变量赋值：\n    - var 变量名=值；\n    - 同时定义多个变量赋值： var 变量名 1=值,变量名 2=值,....;\n- let 关键字定义变量\n  - let 定义的变量，只能在定义的代码块中使用\n\n```javascript\nif (true) {\n  let a = 1;\n  var b = 2;\n  document.write(\"a=\" + a + \"<br/>\"); //可以输出\n}\ndocument.write(\"a=\" + a + \"<br/>\"); //提示变量尚未定义\ndocument.write(\"b=\" + b); //可以正常输出\n```\n\n      -  let不存在变量提升(var存在变量提升)---->必须声明赋值之后才能使用\n\n```javascript\nconsole.log(\"name\" + name); //不会报错\nconsole.log(\"age\" + age); //变量尚未定义\nvar name = \"张三\";\nlet age = 18;\n```\n\n      -  let 定义的变量会有暂时性死区\n\n```javascript\nlet num1 = 10;\nif (true) {\n  let num1 = 20;\n}\nconsole.log(\"num1=\" + num1); //此处输出10\n```\n\n      -  不允许重复的声明变量(在相同作用域中)\n\n```javascript\nlet a = 1;\nlet a = 10; //报错\n```\n\n2.  赋值\n    JavaScript 语言是弱类型的\n1.  先声明再赋值\n1.  不用声明直接赋值  x=10;//ok\n1.  常量\n    使用 const 关键字\n    语法:`const PI=3.14;`\n    注意：\n\n- 常量值是只读的，不能修改\n- 和 let 的作用域是一样的\n\n### 数据类型\n\n#### undefined\n\n表示:变量声明了，但是没有初始化\n\n```javascript\nvar x; //声明但是没有初始化\nconsole.log(x); //undefined\nconsole.log(y); //没有定义   y is not defined\n```\n\n注意：变量未初始化和变量没有定义是不同的概念\n\n#### null\n\n表示空的值\n\n跟 undefined 的区别是：undefined 变量定义了 但是跟本就没有赋值\n\n```javascript\n如:var x; 此时x的值就是undefined\nnull，变量定义了，有值，并且是值就是null\n\n如:var z=null;  一般用于对象的初始值\n```\n\n#### String 字符串\n\n语法:定义 时可以用“” 或者'  '，但是前后必须匹配\n\n```javascript\nvar str1 = \"bbb\";\nvar str2 = \" aaa\";\n```\n\n注意：\n\n- 字符串的值不能更改\n- toString()方法，可以将   数值，对象，布尔，字符串 转换成字符串\n  可以使用 String()来进行判断一个变量的值是否为 null 或 undefined\n\n```javascript\nvar num=100;\nconsole.log(num.toString());//以十进制的形式转换成字符串\nconsole.log(num.toString(2));//以二进制的形式转换成字符串\nconsole.log(num.toString(8));//以八进制的形式转换成字符串\nconsole.log(num.toString(16));//以十六进制的形式转换成字符串\n注意：null和undefined 不能调用这个方法,会报错\n```\n\n- String（）函数\n  可以将任意类型转换成 String 字符串，包括 null 和 undefined\n\n#### number\n\n可以存储任何数字，整型和浮点型\n\n```javascript\nvar n1 = 100;\nvar n2 = 90.99;\n```\n\n注意:浮点数值的最高精度是 17 位小数，但在进行算数计算时其精确度远远不如整型。\n\n#### 特殊值和方法\n\n- infinity  :当大于或小于某个界限时，该值会被自动转换为特殊值——Infinity。\n- isFinite()函数可以判断一个数值是否无穷大。\n  - 它会把参数转换为数值，如果得到的结果是 NaN、Infinity 或-Infinity，函数返回 false（假），其他情况返回 true（真）。\n- NaN:非数值（Not a Number）\n  - 任何涉及 NaN 的操作（例如 NaN/5）都会返回 NaN。\n  - NaN 与任何值都不相等，包括 NaN 本身\n- isNaN():检测一个值是否为 NaN\n  规则:\n  - isNaN 方法会把参数转换为数值，若不能转换为数值则函数返回 false。\n  - 任何不能被转换为数值的值都会导致这个函数返回 true。\n- parseInt()   解析字符串并返回一个整数或 NaN,可以解析二进制，八进制和十六进制的数值.\n- parseFloat():解析字符串并返回一个浮点数\n  - parseFloat()函数始终都会忽略前导的零，且不具备传入基数的能力\n\n#### Boolean\n\n值: true false\n\n转型函数 Boolean()\n\n规则:\n\n1. String 类型：任何非空字符串转换为 true，空字符串（\"\"）转换为 false；\n2. Number 类型：任何非零数值（包括无穷大）转换为 true，0 和 NaN 转换为 false；\n\n#### Object 类型\n\n任何对象转换为 true，null 转换为 false；\n\n注意:当遇到流程控制语句（如 if 语句）也会对数据自动执行相应的 Boolean 转换\n\n#### typeof\n\n来判断一个值或变量究竟属于哪种数据类型。\n\ntypeof 操作符返回的数据类型有以下几种：\n\n- undefined\n- boolean\n- string\n- number\n- object\n- function\n\n## 运算符\n\n表达式:JavaScript 中短语,包括变量,字面量和运算符，简单表达式可以使用运算符组合成复杂表达式\n\n### 一元运算符\n\n只有一个操作数\n\n`如:a++ a-- ++b --b`\n\n**注意:在 javascript 可以对任何值使用, 包括字符串,布尔值,浮点值和对象**\n\n```javascript\nvar a = \"89\";\na++; //90，数值字符串自动转换成数值\nvar b = \"ab\";\nb++; //NaN，字符串包含非数值转成NaN\nvar c = false;\nc++; //1，false转成数值是0，累加就是1\nvar d = 2.3;\nd++; //3.3，直接加1\n```\n\n执行顺序\n\n- ++i:先自增再运算\n  - i=i+1\n  - 其他\n- i++;先运算再自增\n  - 其他运算\n  - i=i+1\n\n### 算术运算符\n\n1.  加法\n    运算:\n1.  求和\n1.  连接(跟字符串运算)\n1.  注意:NAN 和任何类型运算都是 NAN\n\n```javascript\nvar result1 = 1 + 2; //3\nvar result2 = 1 + NaN; //NaN\t\t\t\t\t\t\t\t\t\t\t\tvar result3 = 100 + \"100\";  //100100\nvar result4 = \"10+20=\" + 10 + 20; //10+20=1020\nvar result5 = \"10+20=\" + (10 + 20); //10+20=30\nvar result6 = 10 + 20 + \"=10+20\"; //30=10+20\n```\n\n2.  减法\n    求差时遇到字符串,布尔类型,NAN,null 等非数字类型时,先按规则转换成数字,再进行减法运算\n\n```javascript\nvar result1 = 5 - true; //4,因为true被转换成了1\nvar result2 = NaN - 1; //NaN\nvar result3 = 5 - 3; //2\nvar result4 = 5 - \"\"; //5,因为\"\"被转换成了0\nvar result5 = 5 - \"2\"; //3,因为\"2\"被转换成了2\nvar result6 = 5 - null; //5,因为null被转换成了0\n```\n\n3.  乘法\n    求积时遇到字符串,布尔类型,NAN,null 等非数字类型时,先按规则转换成数字,再进行减法运算\n\n```javascript\nvar result1 = 100 * 70; //7000\nvar result2 = 100 * NaN; //NaN,只要有一个操作数为NaN即为NaN\nvar result3 = 100 * true; //100,因为true被转换成了1\nvar result4 = 100 * \"\"; //0,因为\"\"被转换成了0\nvar result5 = 100 * \"70\"; //7000,因为\"70\"被转换成了70\nvar result6 = 100 * null; //0,因为null被转换成了0\nvar result7 = 100 * \"hello\"; //NaN,因为\"hello\"被转换成了NaN\n```\n\n4.  除法\n    运算符由斜杠符号（/）表示,遇到非数字类型时先转换为数字再运算\n\n```javascript\nvar result1 = 100 / 50; // 2\nvar result2 = 100 / NaN; //NaN,只要有一个操作数为NaN即为NaN\nvar result3 = 100 / true; //100,因为true被转换成了1\nvar result4 = 100 / \"\"; //Infinity,因为\"\"被转换成了0\nvar result5 = 100 / \"50\"; //2,因为\"50\"被转换成了50\nvar result6 = 100 / null; //Infinity,因为null被转换成了0\nvar result7 = 100 / \"hello\"; //NaN,因为\"hello\"被转换成了NaN\n```\n\n5.  取模(求余)\n    %--à 求余数\n\n### 关系运算符\n\n`相等（==）、不相等（!=）、全等（===）和不全等（!==）`\n\n- == 和 === 的区别\n  - ==会进行类型转换\n  - ===不会转换类型\n- 运算规则\n  - 如果操作数都是数值，则按照数值比较\n  - 如果两个操作数都是字符串，则比较两个字符对应的字符编码值\n  - 如果一个操作数是数值，则将另一个操作数转换为数值，然后进行数值比较\n  - 如果一个操作数是一个布尔值，则先将其转换为数值，然后再执行比较\n\n### 逻辑运算符\n\n1.  &&(并且)\n    两边不全是 boolean 类型\n1.  第一个表达式转换为 false,最终的结果为第一个操作数\n1.  第一个表达式转换为 true,最终的结果为第二个操作数\n1.  || (或者)\n\n两边不全是 boolean 类型\n\n1. 第一个表达式转换为 false,最终的结果为第二个操作数\n2. 第一个表达式转换为 true,最终的结果为第一个操作数\n\n```javascript\nconsole.log(Boolean(\"1234\")); //true 非空字符串\nconsole.log(Boolean(\"\")); //false  空字符串\n\nconsole.log(Boolean(0)); // false  0\nconsole.log(Boolean(8888)); //true  非0\n\nconsole.log(Boolean(null)); // false 对象是null\nconsole.log(Boolean(new Date())); //  true 对象不是空\n\nconsole.log(Boolean(NaN)); //false\n\nconsole.log(Boolean(undefined)); //false\n```\n\n### 赋值运算符\n\n右边赋值给左边`+= -= *= /= %=`\n\n## 函数\n\n### 定义调用\n\n- 方式一\n\n```javascript\n定义:\n\tfunction 函数名(形参1,形参2,形参3,...){\n\n\t}\n调用:\n\t函数名(实参1,实参2,实参3,...);//通过函数名调用\n```\n\n- 方式二\n\n```javascript\n定义:\n\t函数定义表达式:(定义的函数是匿名函数,赋值给了一个变量)\n\tvar 变量名=function (形参1,形参2,形参3,...){\n调用: \t  \t\t\t }\n   \t变量名(实参1,实参2,实参3,...);//通过变量名调用\n```\n\n### 函数的参数\n\n1. 定义函数是传入的参数是形参\n2. 调用函数时传入的参数是实参\n3. 形参和实参没有必然联系,形参只是占位符,并且方便函数内使用\n4. javaScript 中,形参和实参的个数可以不一致,但是注意 java 中必须保持一致\n5. 获取参数的方式:argument 对象\n   - argument[0]:获得调用函数时传入的第一个实参\n   - argument[1]:获得调用函数时传入的第二个实参...以此类推\n   - argument.length 属性可以获得实参个数\n\n例子:求最大值\n\n```javascript\nfunction getMax() {\n  var max = arguments[0];\n  for (let i = 0; i < arguments.length; i++) {\n    if (max < arguments[i]) {\n      max = arguments[i];\n    }\n  }\n  alert(\"最大值是\" + max);\n}\ngetMax(10, 20, 40, 50, 60, 90, 200, 23);\n```\n\n### 函数返回值\n\n```javascript\nfunction 函数名(形参) {\n  return 返回值;\n}\nvar 变量 = 函数名(实参); //调用函数之后,返回值保存在变量里面\n//可以返回任何类型的值,包括函数\n```\n\n### 变量作用域\n\n- 全局作用域\n- 局部作用域\n  如:在函数中定义的变量局部作用域\n- 注意:如果在函数内部定义变量没有用 var 声明,直接赋值,那么将是一个全局变量\n  - 全局变量声明了之后,在程序的各个部分都可以使用,包括在函数里面\n  - 但是在函数内定义的局部变量,只能在函数内部使用\n\n### 作用域链\n\n在函数内部没有定义,就会在上一级作用域里面找\n\n由内向外的作用域中寻找变量，直到找到为止\n\n如果找到全局作用域也没找到，那么该变量的值为 undefined\n\n### 闭包\n\n可以读取一个函数内部变量函数\n\n因为变量作用域的关系，导致内部可以读取全局变量，但是外部却不能访问内部变量\n\n- 如何能从外部读取内部变量？\n  可以在函数内部再定义一个函数\n\n```javascript\nfunction f1() {\n  var n = 999;\n  function f2() {\n    alert(n); //99\t在f2函数里面访问了f1内部的局部变量\n  }\n  return f2; //JavaScript返回值可以返回任何数据类型，包括函数\n}\nvar rel = f1(); //调用f1并接收返回值\nrel(); //做到了在函数外部访问内部的局部变量\n```\n\n- 作用\n  - 读取到函数内部的变量\n  - 函数内部变量的作用范围扩大，常驻内存不会被回收\n\n不用太纠结到底怎样才算闭包，其实我们每一个写的函数都是一个简单的闭包\n\n### 立即执行函数\n\n把函数的定义和调用合在一起\n\n```javascript\n(function () {\n  alert(\"a\");\n})();\n```\n\n### 块级作用域与函数的声明\n\nES6 之前 函数不能声明在块级作用域里的，函数的声明是会全部提升至顶部\n\nES6 块级作用域里可以声明函数，但是函数声明的行为类似于 let，在块级外部是不能访问的\n\n```javascript\nif(){\n\n}\n```\n\n现如今:\n\n1. 允许在块级中声明函数】\n2. 函数的生命类似于 var,会有提升\n3. 函数的生命是会提升至头部\n\n### 函数参数的默认值\n\n在 ES6 之后，允许为参数指定默认值\n\n```javascript\nfunction f1(x, y = 18) {\n  console.log(x, y);\n}\n```\n\n1.  不允许有同名参数\n\n```javascript\nfunction f2(x, x, y = 18) {\n  //报错\n  console.log(x, x, y);\n}\n```\n\n2.  参数默认值是不能传值，每次都重新计算表达式默认的值，惰性求值\n3.  参数默认值的位置\n\n- 一般来说，定义了默认值的参数，应该是尾参数，如果为非尾参数设置默认值，实际上并没有办法省略\n- 如果不是尾参数，可以显示输入 undefined 但是 null 不行\n","tags":["JavaScript"],"categories":["学习笔记"]},{"title":"HTML笔记","url":"/posts/HTML.html","content":"\n# HTML 的笔记(上)\n\n## 什么是 HTML\n\nHTML：Hyper  Text  Markup  Language(超级文本标签语言)\n\n## HTML 页面结构\n\n有两部分组成：\n\n### 文档类型声明\n\n作用：告诉浏览器使用的是 HTML 的哪个版本\n`语法：在网页的最顶端编写：`\n`<!doctype html>`\n\n### HTML 页面部分\n\n作用：表示页面的开始和结束\n`语法：在文档类型声明的下面编写一对<html>标记`\n`<html></html>`\nHtml 标签里面有两个标签，分别是\n\n- `<head></head>`\n  作用：表示网页的头部\n- `<body></body>`\n  作用：表示网页的身体，以后页面中所有的要显示的内容，都要写在 body 标签里\n\n## HTML 语法\n\n### 标记语法\n\n标记又叫标签或者元素，在网页中表示一些功能，必须使用<>括起来，标记分为两大类\n\n#### 封闭类型标记\n\n也叫双标记，必须成对出现，有开始和结束标签。\n`语法：<标记>内容</标记>`\neg:`<html>` `<head>` `<body>` `<title>` `<p>` `<b>` `<s>`\n`<u>` `<i>` `<sup>` `<sub>` `<h1>~<h6>` `\n\n---\n\n# 这是一级标签\n\n# 这是一级标签\n\n## 这是二级标签\n\n## 这是二级标签\n\n### 这是三级标签\n\n### 这是三级标签\n\n#### 这是四级标签\n\n#### 这是四级标签\n\n##### 这是五级标签\n\n##### 这是五级标签\n\n###### 这是六级标签\n\n###### 这是六级标签\n\n# ~、` #### 取值 + left 左对齐 + center居中对齐 + right右对齐 eg:`骆驼祥子`骆驼祥子 ### 段落元素 表示一段文字,独占一行`标签：`### 预格式化 保留HTML代码中的回车和空格`语法： `网页中的图像 用于表示网络中任意资源(图片、视频、音频、文件)的位置（或路径） URL：统一资源定位符(Uniform Resource Locator) 路径的表现形式： 1.绝对路径：从文件所在的最高级目录开始查找所经过的路径 2.相对路径从当前文件位置出开始查找所经过的路径 图像的标签：`<img>` 超链接`语法：<a></a>` 属性： 取值：\n\n1.\\_self：默认值，在当前的标签页中打开新网页\n2.\\_blank：在新标签页中打开新网页 超链接的其他用法： 1.资源下载 让链接的 href 等于.rar 或者.zip 即可\n`<a href=”1.zip”>点我下载</a>` 2.电子邮件链接 `<a href=”mailto:邮箱地址”>联系我们</a>`\n`<a href=\"mailto:2831843232@qq.com\">` 3.锚点就是网页中的一个记号，通过超链接可以迅速到达记号所在的位置. 实现步骤： 4、返回顶部 `<a href=”#”>返回顶部</a>` 块级元素和行内元素 块级元素 在网页中独占一行，可以设置宽高 `比如<h1>~<h6>,<p>，<hr>，<table>、div、ul、ol、li、pre、tr、td、form` 行内元素 和其他元素在一行显示,大部分行内元素不可以设置宽高 `<a>,<img><b><s><u><i><sub><sup>,<span>`\n`可以设置宽高的行内元素有：<img> input;`\n`<span>:处理同一行文本的不同形式` 列表 作用：按照从上到下的方式来显示所有的数据，并且在数据前添加一些标识 列表的组成 由列表类型和列表项组成 1.列表类型： 有序列表:`<ol></ol>`    ---Order list\n无序列表：`<ul></ul>`   ---Unorder list 2.列表项： 用于表示列表中的数据：`<li></li>`     ---List  item 列表属性： 有序列表在属性： 无序列表的属性： 列表的嵌套 在一个列表项中又出现了一个列表 被嵌套的列表只能出现在`<li>`中，不能乱放\n![](https://cdn.jsdelivr.net/gh/isome/ialoe-article@master/HTML笔记/li嵌套.png#id=Nnsq2&originalType=binary&ratio=1&status=done&style=none) 定义列表： 通常用对某个名词的解释 语法： `<dl></dl>`  -----definition  list(定义列表) `<dt></dt>` 定义要解释的名词 `<dd></dd>` 表示定义列表中对名字的解释内容 结构标记 作用：用于描述整个网页的结构，提升标记的语义性 常用的语义标记 他们的本质都是 div 标签`<div></div>`：表示块区元素，独占一行，用于表示一个区域。是 H5 新增的语义化新标签 表格 表格是由单元格按照从左到右，从上到下的顺序排列而成的。 标签 表格：` <table></table> 行：`` ----table row 表示一行 列或单元格： ----table data 表示一个单元格 表格的属性： 被跨掉的单元格必须删除 可选标记 注意：若不对table中的数据进行分组，默认都在 表单 作用 标签  `<table></table>` 属性 可视化控件\n\n#\n\n#\n\n###\n\n####\n\n#####\n\n#####\n\n```\n相对路径口诀：\n\t\t\t同目录，直接用（直接填写图片名）\n\t\t\t子目录，先进入，再使用\n\t\t\t<img src=\"1/1.jpg\" >\n\t\t\t父目录，先返回，再使用\n\t\t\t../表示返回上一级目录\n```\n\n####\n\n1. src(必须属性)：要显示的图片的 url（相对/绝对）\n2. width：设置图片宽度，单位是 px 或%\n3. height：设置图片高度，单位是 px 或%\n4. alt：鼠标移至图片时显示的文字\n5. title：图片加载不出来时显示的文字\n\n###\n\n####\n\n- href：\n  链接到那个地址\n  此属性，必须有，如果没有此属性：`<a>标签将不具有超链接的功能<a href=\"https://www.baidu.com\">百度一下</a>`\n- target：\n  指定打开新网页的方式\n\n####\n\n#####\n\n#####\n\n#####\n\n> 第一步：定义锚点\n>\n> 第二步：链接到锚点\n\n> 方式一：使用任意标签的 id 属性定义锚点\n\n> `<h1 id=”锚点名字”>化妆品区域</h1>`\n\n> 方式二：使用 a 标签的 name 属性，定义锚点\n\n> `<a name=”锚点名字”>化妆品区域</a>`\n\n> `<a href=”#锚点名字”>化妆品</a>`\n\n#####\n\n###\n\n####\n\n####\n\n###\n\n####\n\n#####\n\n#####\n\n```html\n语法：\n<ol>\n  <li>篮球</li>\n  <li>足球</li>\n  <li>排球</li>\n  <li>台球</li>\n</ol>\n```\n\n####\n\n#####\n\n- type\n  作用：指定列表标识的类型\n- 取值：\n  - 1：按数字排列，默认值\n  - a:按小写字母排列\n  - A：按大写字母排列\n  - i:按小写罗马数字排列\n  - I：按大些罗马字母排列\n- start\n  作用：指定起始编号从几开始，是数字\n\n#####\n\n- type：\n  作用：指定列表标识的类型\n- 取值：\n  - disc   默认值，实心圆\n  - circle   空心圆\n  - square   实心方块\n  - none   不显示标识（最常用）\n\n#####\n\n#####\n\n```html\n格式：\n<dl>\n  <dt>《水浒传》</dt>\n  <dd>中国四大名著</dd>\n</dl>\n```\n\n###\n\n####\n\n1. `<header></header>`\n   作用：定义网页或某部分内容的头部\n2. `<nav></nav>`\n   作用：定义网页的导航链接部分\n3. `<section></section>`\n   作用：表示网页的主体内容\n4. `<article></article>`\n   作用：定义与文字描述相关的内容\n5. `<aside></aside>`\n   作用：定义页面中侧边栏的信息\n6. `<footer></footer>`\n   作用：定义某区域的底部信息\n\n######\n\n###\n\n####\n\n```html\n表格的写法：\n<table>\n  <tr>\n    行必须写在表里面\n    <td></td>\n    单元格必须写在row里面\n    <td></td>\n  </tr>\n  <tr></tr>\n</table>\n```\n\n####\n\n- table 的属性:\n  - width\n    设置表格的宽度，单位是 px 或%\n  - height\n    设置表格的高度，单位是 px 或%\n  - align\n    设置表格的水平对齐方式\n    left/center/right\n  - border\n    设置表格的边框宽度，默认值是 0，没有单位\n  - bgcolor\n    设置背景颜色，取值为对应颜色的英文\n  - cellspacing\n    表示单元格的外边距，就是单元格与单元格之间的距离\n  - cellpadding\n    设置单元格的内边距，就是单元格与内容的距离\n- tr 的属性：\n  - align\n    设置当前行里面内容的水平对齐方式 - 取值：left/center/right\n  - valign\n    设置当前行里面内容的垂直对齐方式 - 取值：top(顶部)middle(居中)/bottom（底部）\n  - bgcolor：\n    设置该行的背景颜色\n- td 的属性：\n  - width,设置单元格的宽度\n  - height\n  - align\n  - valign\n  - bgcolor\n  - colspan:   跨列\n  - rowspan：跨行\n\n######\n\n####\n\n- 表格的标题：`<caption></caption>`必须写在`<table>`标签的第一行，一个表格只能有一个标题\n- 所有的`<td>`标签都可以被`<th>`标签替换，table header 内容的标题\n- 行分组可以将连续的几个行，划分到一个组中，进行统一的管理。\n  - 表头行分组`<thead></thead>`表格中最上面的一行或几行，进行分组，就可以将这一行放在`<thead>`标签里\n  - 表尾行分组`<tfoot></tfoot>`表格中最后一行进行分组的话，可以放在`<tfoot>`标签中\n  - 表主体行分组`<tbody></tbody>`可以将若干个行，放在`<tbody>`中,进行统一设置\n\n######\n\n```\n+ 表格的嵌套被嵌套的表格必须写在`<td>`里面.\n```\n\n###\n\n####\n\n1. 提供可以与用户**_*交互*_**的可视化界面\n2. 收集用户信息并提交给服务器\n\n####\n\n####\n\n1. action 作用：定义表单内容被提交到哪个服务器里，后面跟 url\n2. method   作用：定义表单数据的提交方式\n   - 作用：定义表单数据的提交方式\n   - 取值：\n     1. get 默认是 get\n     1. post\n\n####\n\n- 分类\n  1.  input 元素\n  1.  textarea 多行文本域元素\n  1.  select 和 option 选项框元素\n  1.  其他元素\n- Input 元素\n  - 作用：在页面中提供各种各样的输入控件\n  - 语法：`<input>或者<input />`\n  - 属性： 1. type     指定创建输入控件的类型 - 取值 1. text   文本框 1. password 密码框 1. submit   提交按钮 1. reset   重置按钮 1. radio   单选框(单选框需要分组才能使用\n    使用 name 属性分组，让两个单选框的 name 值一致即可) 1. checkbox 多选框 1. file   文件选择框(用于上传文件) 2. value     指定控件的值 2. placeholder     占位符，默认显示在控件上的文本 2. readonly     只能看，不能改，没有值 2. disabled     禁用控件，没有值\n  - 表单辅助标签\n    - `<input type=”checkbox” id=”login”>`\n    - `<label for=”login”>下次自动登录</label>`\n\n######\n","tags":["HTML"],"categories":["学习笔记"]}]